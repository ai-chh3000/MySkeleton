# -*- coding: utf-8 -*-
# æ°´å°ï¼šğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°
# è¯´æ˜ï¼šæœ¬æ–‡ä»¶å¤´éƒ¨åªå…è®¸æ³¨é‡Šï¼›ç¦æ­¢å‡ºç°ä»»ä½•â€œè£¸æ–‡ä»¶å/è£¸ä¸­æ–‡è¡Œâ€ã€‚
import csv
import os
import inspect
import hashlib
import re
import sys
import traceback
from dataclasses import dataclass, replace
from typing import Any, Optional
from collections import defaultdict

# ==========================
# å®‰å…¨ç¡¬é—¸é—¨ï¼ˆæ¨¡æ¿åŠ å›ºï½œé”æ­»ï¼‰
# ==========================
WATERMARK_TEXT = "ğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°"

# ------------------------------------------------------------
# ğŸ“Œ æŠ½æ ·æ¢é’ˆï¼ˆå†»ç»“åŒºï½œåªç”¨äºæ‰“å°å®šä½ï½œå®Œå…¨ä¸å½±å“ç­–ç•¥é€»è¾‘ï¼‰
# è¾“å‡ºæ ¼å¼ï¼ˆæ¯æ¡ä¸€è¡Œï¼‰ï¼š
# - ğŸ¯|f=<æ–‡ä»¶å>|SB=<Sub-Batch>|N=<N_prebet=äººç±»å®é™…å–å€¼/ä¸‹æ³¨ç‚¹=å–å€¼ç‚¹=seen_all>ğŸ†—
# - ğŸ“Œ|f=<æ–‡ä»¶å>|SB=<Sub-Batch>|N=<åŒä¸Š>ï¼ˆé¢å¤–é‡‡é›†ç‚¹ï¼›ä¸ğŸ¯åŒæºåŒåæ ‡ï¼‰
# ------------------------------------------------------------
SAMPLE_PROBE_ENABLE = 1  # 1=ON, 0=OFF
SAMPLE_PROBE_K = 3  # æŠ½æ ·æ¡æ•°
SAMPLE_PROBE_PREFIX = "ğŸ¯"
SAMPLE_PROBE_PIN_PREFIX = "ğŸ“Œ"
SAMPLE_PROBE_PRINT_PIN = 1  # 1=åŒæ—¶è¾“å‡ºğŸ“Œï¼Œ0=ä»…è¾“å‡ºğŸ¯
SAMPLE_PROBE_MODE = "RANDOM_BY_NONCE"  # RANDOM_BY_NONCE / EARLIEST_BY_SB_N
SAMPLE_PROBE_RUN_NONCE = int.from_bytes(os.urandom(8), "big")  # æ¯æ¬¡è¿è¡Œä¸åŒï¼›ä»…ç”¨äºæŠ½æ ·æ’åº

# file -> (score, file, sub_batch, N_prebet)
_SAMPLE_PROBE_BEST_BY_FILE = {}
_SAMPLE_PROBE_FALLBACK = None  # (base, sub_batch, N_prebet)

# äº‹ä»¶6ï½œå…¨æ–‡ä»¶æœ€æ—©ğŸ¯ï¼ˆåŸºäºâ€œçœŸå®ä¸‹æ³¨è½ç‚¹â€ï¼‰
# file -> (key=(SB_int, N_int) or (SB_str, N_str), file, sub_batch, N_prebet)
_EARLIEST_TGT_MIN_BY_FILE = {}
_EARLIEST_TGT_CNT_BY_FILE = defaultdict(int)  # file -> candidate count


def _sample_probe_u64(s: str) -> int:
    # ç¨³å®šå“ˆå¸Œï¼šè·¨è¿›ç¨‹/è·¨å¹³å°å¯å¤ç°ï¼›ä»…ç”¨äºæŠ½æ ·æ’åºï¼ˆä¸å‚ä¸ä»»ä½•é€»è¾‘ï¼‰
    h = hashlib.md5(s.encode("utf-8"), usedforsecurity=False).hexdigest()
    return int(h[:16], 16)


def _sample_probe_fallback_update(file_name, sub_batch, idx) -> None:
    """æŠ½æ ·å…œåº•ï¼šå…³é—­ï¼ˆåªä¿ç•™ğŸ¯ä¸‹æ³¨å£å®šä½è¡Œï¼›ä¸å†è¾“å‡ºä»»ä½•å…œåº•è¡Œï¼‰ã€‚"""
    return


def _sample_probe_update(file_name, sub_batch, idx, boot_id=None) -> None:
    """
    æŠ½æ ·ï¼ˆå†»ç»“åŒºï½œåªç”¨äºæ‰“å°å®šä½ï¼‰ï¼š
    - RANDOM_BY_NONCEï¼šéšæœºåˆ†å¸ƒï¼ˆé€šè¿‡ RUN_NONCE ç¨³å®šæŠ½æ ·ï¼‰ï¼Œé¿å…â€œæ°¸è¿œ SB=1â€
    - EARLIEST_BY_SB_Nï¼šæŒ‰ (SB, N) æœ€æ—©æ‹©ä¼˜ï¼ˆç”¨äºå¯¹ç…§éªŒè¯ï¼‰
    æ³¨æ„ï¼šæŠ½æ ·åªè®°å½•â€œçœŸå®ä¸‹æ³¨è½ç‚¹çš„åæ ‡â€ï¼ˆè°ƒç”¨ç‚¹å·²ç»åœ¨ğŸ¯ç¡¬é—¸é—¨ä¹‹åï¼‰ã€‚
    """
    try:
        if not SAMPLE_PROBE_ENABLE:
            return
        if not file_name:
            return

        base = os.path.basename(str(file_name))

        def _to_int(x):
            try:
                return int(x)
            except Exception:
                return None

        sb_i = _to_int(sub_batch)
        n_i = _to_int(idx)

        # -------- äº‹ä»¶6ï½œå…¨æ–‡ä»¶æœ€æ—©ğŸ¯ï¼šæ¯æ¬¡çœŸå®ğŸ¯å‡ºç°éƒ½å‚ä¸ï¼ˆä¸å—æŠ½æ ·æ¨¡å¼å½±å“ï¼‰ --------
        _EARLIEST_TGT_CNT_BY_FILE[base] += 1
        if sb_i is None or n_i is None:
            key_min = (str(sub_batch), str(idx))
        else:
            key_min = (sb_i, n_i)
        prev_min = _EARLIEST_TGT_MIN_BY_FILE.get(base)
        if prev_min is None or key_min < prev_min[0]:
            _EARLIEST_TGT_MIN_BY_FILE[base] = (key_min, base, sub_batch, idx)

        # -------- æŠ½æ ·æ‹©ä¼˜ï¼šéšæœº or æœ€æ—© --------
        if SAMPLE_PROBE_MODE == "EARLIEST_BY_SB_N":
            order_key = key_min
            prev = _SAMPLE_PROBE_BEST_BY_FILE.get(base)
            if prev is None or order_key < prev[0]:
                _SAMPLE_PROBE_BEST_BY_FILE[base] = (order_key, base, sub_batch, idx)
            return

        # RANDOM_BY_NONCEï¼ˆé»˜è®¤ï¼‰ï¼šç”¨ç¨³å®šå“ˆå¸Œæ‰“åˆ†ï¼Œä¿è¯éšæœºåˆ†å¸ƒä¸”å¯å¤ç°
        key = f"{SAMPLE_PROBE_RUN_NONCE}|{base}|{sub_batch}|{idx}|{'' if boot_id is None else boot_id}"
        score = _sample_probe_u64(key)
        prev = _SAMPLE_PROBE_BEST_BY_FILE.get(base)  # (score, base, sb, n)
        if prev is None or score < prev[0]:
            _SAMPLE_PROBE_BEST_BY_FILE[base] = (score, base, sub_batch, idx)

    except Exception:
        # æŠ½æ ·æ¨¡å—ä¸å¾—å½±å“ä¸»æµç¨‹
        return


def _earliest_tgt_emit() -> None:
    """äº‹ä»¶6ï½œè¾“å‡ºï¼šå…¨æ–‡ä»¶æœ€æ—©ğŸ¯ï¼ˆçœŸå®ä¸‹æ³¨è½ç‚¹ï¼‰"""
    if not _EARLIEST_TGT_MIN_BY_FILE:
        return
    try:
        print("èŠ‚ç‚¹=EARLIEST_SCOPE|mode=FILE_WIDE_EARLIEST_REAL_TGT")
    except Exception:
        pass

    # æŒ‰ key_min æ’åºè¾“å‡ºï¼ˆç¨³å®šï¼‰
    items = list(_EARLIEST_TGT_MIN_BY_FILE.values())
    try:
        items.sort(key=lambda x: x[0])
    except Exception:
        pass

    for key_min, base, sb, n in items:
        try:
            cnt = int(_EARLIEST_TGT_CNT_BY_FILE.get(base, 0))
        except Exception:
            cnt = 0
        try:
            print(f"èŠ‚ç‚¹=EARLIEST_TGT|f={base}|SB={sb}|N={n}|candidate_cnt={cnt}|why=MIN_KEY")
        except Exception:
            continue

    try:
        print("èŠ‚ç‚¹=EARLIEST_ASSERT|OK=1|rule=REAL_TGT_ONLY")
    except Exception:
        pass


def _sample_probe_emit() -> None:
    """
    è¾“å‡ºæŠ½æ ·ï¼ˆå†»ç»“åŒºï¼‰ï¼š
    - æ¯ä¸ªæ–‡ä»¶æœ€å¤š 1 æ¡
    - å…¨å±€å–å‰ K æ¡
    """
    if not SAMPLE_PROBE_ENABLE:
        return

    items = list(_SAMPLE_PROBE_BEST_BY_FILE.values())
    if not items:
        return

    try:
        # RANDOMï¼šæŒ‰ score å°åˆ°å¤§ï¼›EARLIESTï¼šæŒ‰ key å°åˆ°å¤§
        items.sort(key=lambda x: x[0])
    except Exception:
        pass

    out = items[:max(1, int(SAMPLE_PROBE_K))]

    try:
        print(f"èŠ‚ç‚¹=SAMPLE_PICK|mode={SAMPLE_PROBE_MODE}|nonce={SAMPLE_PROBE_RUN_NONCE}|K={int(SAMPLE_PROBE_K)}|files={len(items)}")
    except Exception:
        pass

    for _, base, sb, n in out:
        try:
            # ğŸ¯ï¼ˆçœŸå®ä¸‹æ³¨è½ç‚¹çš„åŒæºæ‰“å°ï¼‰
            print(f"{SAMPLE_PROBE_PREFIX}|f={base}|SB={sb}|N={n}ğŸ†—")
            # ğŸ“Œï¼ˆé¢å¤–é‡‡é›†ç‚¹ï¼šä¸ğŸ¯åŒæºåŒåæ ‡ï¼‰
            if int(SAMPLE_PROBE_PRINT_PIN) == 1:
                print(f"{SAMPLE_PROBE_PIN_PREFIX}|f={base}|SB={sb}|N={n}")
        except Exception:
            continue


BUILD_TAG = "V30_UPGRADED_fix_bootid_v32_buildtag_fix|TAG20260105-01|BOOT_START_LOCK_SW|DUAL_SEEN|B1_RESET_STEP1|RUNLEN_LOCK_S|R_TRUTH|TEMP_INIT_FIRST|HYST3|DIFF_SIGN_ONLY"
# æŒ‡æ ‡é”®ï¼ˆé”æ­»ï¼‰
METRIC_KEYS = {"diff", "rate", "mean", "rate_raw", "mean_raw"}


# ==========================
# ç»Ÿä¸€è¿è§„å‡ºå£ï¼ˆè¡¥ä¸Aï½œé”æ­»ï¼‰
# ==========================
class GuardViolation(RuntimeError):
    """é—¨ç¦/å®¡è®¡è¿è§„ï¼šç»Ÿä¸€å‡ºå£ï¼Œç¦æ­¢ tracebackã€‚"""

    def __init__(self, *, code, rule_id, phase, msg, evidence, exit_code=2):
        super().__init__(msg)
        self.code = str(code)
        self.rule_id = int(rule_id) if rule_id is not None else 0
        self.phase = str(phase)
        self.msg = str(msg)
        self.evidence = str(evidence)
        self.exit_code = int(exit_code)


def _raise_guard(*, code, rule_id, phase, msg, evidence, exit_code=2):
    raise GuardViolation(code=code, rule_id=rule_id, phase=phase, msg=msg, evidence=evidence, exit_code=exit_code)


def _as_guard_from_exception(e):
    """æŠŠæœªçŸ¥å¼‚å¸¸æ˜ å°„ä¸ºå¯å®¡è®¡å•å±é”™è¯¯ï¼ˆä¸æ”¾æ¾å®¡è®¡å¼ºåº¦ï¼‰ã€‚"""
    etxt = f"{type(e).__name__}: {e}"
    loc = "UNKNOWN"
    try:
        tb = traceback.extract_tb(e.__traceback__)
        if tb:
            last = tb[-1]
            loc = f"{last.name}@L{last.lineno}"
    except Exception:
        loc = "UNKNOWN"
    return GuardViolation(
        code="UNHANDLED",
        rule_id=0,
        phase="UNKNOWN",
        msg="UNHANDLED",
        evidence=f"{etxt} | loc={loc}",
        exit_code=2,
    )


def _print_watermark_once():
    global _WATERMARK_PRINTED
    if globals().get("_WATERMARK_PRINTED", False):
        return
    print(WATERMARK_TEXT)
    _WATERMARK_PRINTED = True


def _compute_core_and_slot_fingerprints() -> None:
    """
    è®¡ç®—ä¸¤ç±»æŒ‡çº¹ï¼š
    - CORE8ï¼šé™¤ã€Œç»“æ„æ’æ§½å—ã€ä»¥å¤–çš„åŸºåº§æ ¸å¿ƒæŒ‡çº¹ï¼ˆç”¨äºé˜²å·æ¢ï¼‰
    - SLOT8ï¼šä»…ã€Œç»“æ„æ’æ§½å—ã€çš„æŒ‡çº¹ï¼ˆç”¨äºè¯†åˆ«ç»“æ„å˜åŒ–ï¼‰

    ç»“æ„æ’æ§½è¾¹ç•Œä»¥ã€Œè¦†ç›–é”šç‚¹001ã€ä¸ºå‡†ï¼ˆé¿å…è¯´æ˜æ–‡å­—/æ³¨é‡Šè¯¯ä¼¤ï¼‰ï¼š
      - # ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_BEG
      - # ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_EN
    """
    global CORE_BASE_FINGERPRINT, STRUCTURE_SLOT_FINGERPRINT, STRUCTURE_SLOT_LINE_RANGE

    try:
        with open(__file__, "r", encoding="utf-8") as f:
            src = f.read()
        lines = src.splitlines()
    except Exception:
        CORE_BASE_FINGERPRINT = None
        STRUCTURE_SLOT_FINGERPRINT = None
        STRUCTURE_SLOT_LINE_RANGE = None
        return

    ANCHOR001_BEGIN = "ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_" "BEGIN"
    ANCHOR001_END = "ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_" "END"
    begin_pat = r"^[ \t]*#\s*" + re.escape(ANCHOR001_BEGIN) + r".*$"
    end_pat = r"^[ \t]*#\s*" + re.escape(ANCHOR001_END) + r".*$"

    begin_ms = list(re.finditer(begin_pat, src, flags=re.MULTILINE))
    end_ms = list(re.finditer(end_pat, src, flags=re.MULTILINE))

    if len(begin_ms) != 1 or len(end_ms) != 1:
        raise RuntimeError(f"ç»“æ„æ’æ§½é”šç‚¹æ•°é‡å¼‚å¸¸ï¼šBEGIN={len(begin_ms)} END={len(end_ms)}")

    b = begin_ms[0]
    e = end_ms[0]

    b_start = b.start()
    b_end = b.end()
    e_start = e.start()
    e_end = e.end()

    if e_start <= b_start:
        raise RuntimeError("ç»“æ„æ’æ§½é”šç‚¹é¡ºåºå¼‚å¸¸ï¼šEND åœ¨ BEGIN ä¹‹å‰")

    # è®¡ç®—è¡Œå·èŒƒå›´ï¼ˆå«è¾¹ç•Œè¡Œï¼‰
    begin_line = src[:b_start].count("\n") + 1
    end_line = src[:e_start].count("\n") + 1
    STRUCTURE_SLOT_LINE_RANGE = (begin_line, end_line)

    # æ’æ§½æ–‡æœ¬ï¼ˆä¸å«è¾¹ç•Œè¡Œæœ¬èº«ï¼‰
    src_lines = src.splitlines()
    slot_body_lines = src_lines[begin_line: end_line - 1]
    slot_text = "\n".join(slot_body_lines).strip("\n")

    STRUCTURE_SLOT_FINGERPRINT = hashlib.sha256(slot_text.encode("utf-8")).hexdigest()

    # CORE æŒ‡çº¹ï¼šå»æ‰æ•´æ®µã€ŒBEGINè¡Œ .. ENDè¡Œã€(å«è¾¹ç•Œè¡Œ)
    # - è¿™æ ·ç­–ç•¥/ç»“æ„çš„å¯å˜èŒƒå›´åªå½±å“ SLOT8ï¼Œä¸å½±å“ CORE8
    # - ä¹Ÿé¿å…è¯´æ˜æ–‡å­—ä¸­å‡ºç°ç±»ä¼¼å­—ç¬¦å¯¼è‡´è¯¯ä¼¤
    # æ‰¾åˆ° END è¡Œå°¾ï¼ˆå«æ¢è¡Œï¼‰
    e_end2 = e_end
    if e_end2 < len(src) and src[e_end2:e_end2 + 1] == "\n":
        e_end2 += 1

    core_text = src[:b_start] + src[e_end2:]
    CORE_BASE_FINGERPRINT = hashlib.sha256(core_text.encode("utf-8")).hexdigest()


def _print_force_proof_block():
    global _PROOF_BLOCK_PRINTED
    if globals().get("_PROOF_BLOCK_PRINTED", False):
        return
    print("ã€å¼ºåˆ¶è‡ªè¯è¾“å‡ºã€‘")
    _print_switches_block("PROOF")

    # äº‹ä»¶4+ï½œPRE_L1 ç¡¬é˜€é—¨è‡ªè¯ï¼ˆåªæ‰“å°ä¸€æ¬¡ï¼›ä¸å½±å“åç»­é€»è¾‘ï¼‰
    try:
        if not globals().get("_PRE_L1_GUARD_PRINTED", 0):
            globals()["_PRE_L1_GUARD_PRINTED"] = 1
            _bak = globals().get("_L1_DECISION_DONE", 0)
            globals()["_L1_DECISION_DONE"] = 0  # å¼ºåˆ¶ PRE_L1 åœºæ™¯ï¼Œä»…ç”¨äºè‡ªè¯
            _l2_run = 1 if _stage_enabled("L2") else 0
            _l3_run = 1 if _stage_enabled("L3") else 0
            print(f"èŠ‚ç‚¹=PRE_L1_GUARD|L1_DONE=0|L2_RUN={_l2_run}|L3_RUN={_l3_run}|expect=0")
            globals()["_L1_DECISION_DONE"] = _bak
    except Exception:
        try:
            globals()["_L1_DECISION_DONE"] = globals().get("_L1_DECISION_DONE", 0)
        except Exception:
            pass

    # åŸºåº•èº«ä»½è¯ï¼ˆğŸ•çŸ­ç ï¼‰ï¼šç”±å†»ç»“åŒºæŒ‡çº¹è‡ªåŠ¨ç”Ÿæˆï¼›åªæ”¹æ’æ§½/è§„åˆ™ä¸åº”å˜åŒ–    try:
        _compute_core_and_slot_fingerprints()
    except Exception:
        pass
    core8 = ((CORE_BASE_FINGERPRINT or 'NA')[:8]).upper()
    slot8 = ((STRUCTURE_SLOT_FINGERPRINT or 'NA')[:8]).upper()
    pizza = 'ğŸ•' + core8[:4]
    print(f"åŸºåº•èº«ä»½è¯ï¼š{pizza} | CORE8={core8} | SLOT8={slot8}")
    if STRUCTURE_SLOT_LINE_RANGE and STRUCTURE_SLOT_LINE_RANGE[0] is not None:
        print(
            f"ç»“æ„æ’æ§½ï¼šç‰ˆæœ¬={STRUCTURE_SLOT_VERSION} | è¡Œå·èŒƒå›´={STRUCTURE_SLOT_LINE_RANGE[0]}..{STRUCTURE_SLOT_LINE_RANGE[1]}")
    try:
        denom = int(globals().get("_LAST_ENTRY_FOR_PROOF", 0) or 0)
        pct = (BET_IN_FORBIDDEN_SEEN / denom * 100.0) if denom > 0 else 0.0
    except Exception:
        pct = 0.0
    print(f"BET_IN_FORBIDDEN_SEEN = {BET_IN_FORBIDDEN_SEEN} ({pct:.2f}%)")
    print(f"PPBB_IDENTITY_CHECKED = {PPBB_CHECKED} | PPBB_MISMATCH = {PPBB_MISMATCH}")
    # è§£æè®¡æ•°ï¼ˆè¡¥ä¸Bï¼‰
    try:
        print(f"RATE_PARSE_FAIL_INPUT = {RATE_PARSE_FAIL_INPUT} | RATE_MISSING_RAW_INPUT = {RATE_MISSING_RAW_INPUT}")
        print(f"MEAN_PARSE_FAIL_INPUT = {MEAN_PARSE_FAIL_INPUT} | MEAN_MISSING_RAW_INPUT = {MEAN_MISSING_RAW_INPUT}")
    except Exception:
        pass
    # æ’æ§½è‡ªè¯ï¼ˆåŸºåº§/æ’æ§½åˆ†ç¦»ï¼‰
    try:
        _compute_core_and_slot_fingerprints()
        if CORE_BASE_FINGERPRINT is not None and STRUCTURE_SLOT_FINGERPRINT is not None:
            (bl, el) = STRUCTURE_SLOT_LINE_RANGE or (None, None)
            print(f"STRUCTURE_SLOT = {STRUCTURE_SLOT_NAME}@{STRUCTURE_SLOT_VERSION} | L{bl}..L{el}")
            print(f"CORE_BASE_FINGERPRINT = {CORE_BASE_FINGERPRINT[:16]}")
            print(f"STRUCTURE_SLOT_FINGERPRINT = {STRUCTURE_SLOT_FINGERPRINT[:16]}")
    except Exception as e:
        print(f"STRUCTURE_SLOT_PROOF_FAIL = {type(e).__name__}: {e}")
    if denom > 0:
        _PROOF_BLOCK_PRINTED = True


def _print_single_screen_error(gv: 'GuardViolation'):
    # ä»»ä½•å¼‚å¸¸ä¹Ÿè¦æ»¡è¶³ï¼šæ°´å° + å¼ºåˆ¶è‡ªè¯å—ï¼ˆè‹¥å·²æ‰“å°åˆ™ä¼šè‡ªåŠ¨å»é‡ï¼‰
    try:
        _print_watermark_once()
    except Exception:
        pass
    try:
        _print_force_proof_block()
    except Exception:
        pass
    try:
        _flush_audit_log("FAIL")
    except Exception:
        pass
    print(f"âŒâŒâŒ è§¦å‘æ¡ç›®={gv.rule_id} | code={gv.code} | phase={gv.phase} | evidence={gv.evidence}")


class MetricGuardRow(dict):
    """EXECUTE/SETTLE é˜¶æ®µï¼šrow å·²å»æŒ‡æ ‡åŒ–ï¼›ä»»ä½•è¯»å–æŒ‡æ ‡é”®ä¸€å¾‹ raiseã€‚"""

    def get(self, k, default=None):
        if k in METRIC_KEYS:
            raise RuntimeError(f"ILLEGAL_METRIC_ACCESS_IN_EXECUTE: {k}")
        return super().get(k, default)

    def __getitem__(self, k):
        if k in METRIC_KEYS:
            raise RuntimeError(f"ILLEGAL_METRIC_ACCESS_IN_EXECUTE: {k}")
        return super().__getitem__(k)


class ScanGuardRow(dict):
    """SCAN é˜¶æ®µï¼šrow å·²å»æŒ‡æ ‡åŒ–ï¼›ä»»ä½•è¯»å–æŒ‡æ ‡é”®ä¸€å¾‹ raiseã€‚"""

    def get(self, k, default=None):
        if k in METRIC_KEYS:
            raise RuntimeError(f"ILLEGAL_METRIC_ACCESS_IN_SCAN: {k}")
        return super().get(k, default)

    def __getitem__(self, k):
        if k in METRIC_KEYS:
            raise RuntimeError(f"ILLEGAL_METRIC_ACCESS_IN_SCAN: {k}")
        return super().__getitem__(k)


# ==========================
# å…¨å±€ç¡¬é—¸é—¨ï¼ˆNode 1 æ–°å¢ï¼‰
# ==========================
_METRIC_READ_ARMED = 0


def _arm_metric_read(*_a, **_k):
    global _METRIC_READ_ARMED
    _METRIC_READ_ARMED = 1


def _disarm_metric_read():
    global _METRIC_READ_ARMED
    _METRIC_READ_ARMED = 0


class Snapshot:
    """STAR_ROW æœ€å°ä¸å¯å˜å¿«ç…§ï¼šç¦æ­¢ç›´è¯»æŒ‡æ ‡ï¼ˆå¿…é¡»èµ° secure_read_metricï¼‰ã€‚
    Node 1 å¢å¼ºï¼šå°å­˜å€¼ï¼ˆsealed valuesï¼‰ç”¨äº REPORT é˜¶æ®µï¼Œé¿å…å†æ¬¡è¯»å–æŒ‡æ ‡ã€‚
    """
    __slots__ = (
        "_metrics", "_boot_id", "_idx", "_seen_all", "_rr", "_source",
        "_exh_pair", "_rate_mode", "_rate_bucket_l1", "_rate_bucket_r", "_rate_bucket", "_rate_raw_text",
        "_mean_raw_text",
        "_diff_val", "_rate_val", "_mean_val", "_diff_bucket", "_mean_bucket"
    )

    def __init__(self, metrics: dict, *, boot_id, idx, seen_all, rr, source="STAR_ROW", sealed_values=None):
        self._metrics = dict(metrics)
        self._boot_id = boot_id
        self._idx = int(idx)
        self._seen_all = int(seen_all)
        self._rr = rr
        self._source = source

        # å†»ç»“åŒºå…ƒä¿¡æ¯ï¼šé»˜è®¤æœªç»‘å®šï¼ˆå¿…é¡»ç”± secure_write_star_snapshot ç»‘å®šï¼‰
        self._exh_pair = None
        self._rate_mode = None
        self._rate_bucket_l1 = None
        self._rate_bucket_r = None
        self._rate_bucket = None
        self._rate_raw_text = ""
        self._mean_raw_text = ""

        # Node 1: å°å­˜å€¼ï¼ˆåªè¯»ï¼‰
        if sealed_values:
            self._diff_val = sealed_values.get("diff_val")
            self._rate_val = sealed_values.get("rate_val")
            self._mean_val = sealed_values.get("mean_val")
            self._diff_bucket = sealed_values.get("diff_bucket")
            self._mean_bucket = sealed_values.get("mean_bucket")
        else:
            self._diff_val = None
            self._rate_val = None
            self._mean_val = None
            self._diff_bucket = None
            self._mean_bucket = None

    # ---- å…ƒä¿¡æ¯ï¼ˆå…è®¸ç›´è¯»ï¼‰----
    @property
    def boot_id(self):
        return self._boot_id

    @property
    def idx(self):
        return self._idx

    @property
    def seen_all(self):
        return self._seen_all

    @property
    def rr(self):
        return self._rr

    @property
    def source(self):
        return self._source

    # ---- å†»ç»“åŒºï¼šå˜åŒ–ç‡å”¯ä¸€å…¥å£ç»‘å®šç»“æœï¼ˆå…è®¸ç›´è¯»ï¼‰----
    @property
    def exh_pair(self):
        return self._exh_pair

    @property
    def rate_mode(self):
        return self._rate_mode

    @property
    def rate_bucket_l1(self):
        return self._rate_bucket_l1

    @property
    def rate_bucket_r(self):
        return self._rate_bucket_r

    @property
    def rate_bucket(self):
        return self._rate_bucket

    # ---- Node 1: å°å­˜å€¼è®¿é—®ï¼ˆå…è®¸ REPORT é˜¶æ®µè¯»å–ï¼‰----
    @property
    def diff_val(self):
        return self._diff_val

    @property
    def rate_val(self):
        return self._rate_val

    @property
    def mean_val(self):
        return self._mean_val

    @property
    def diff_bucket(self):
        return self._diff_bucket

    @property
    def mean_bucket(self):
        return self._mean_bucket

    def _bind_rate_fields(self, *, exh_pair, rate_mode, rate_bucket_l1, rate_bucket_r, rate_bucket):
        """åªå…è®¸ç»‘å®šä¸€æ¬¡ï¼›åç»­ä»»ä½•å†æ¬¡ç»‘å®šéƒ½è§†ä¸ºæ±¡æŸ“ã€‚"""
        if self._rate_bucket is not None:
            raise RuntimeError("RATE_FIELDS_ALREADY_BOUND")
        self._exh_pair = exh_pair
        self._rate_mode = rate_mode
        self._rate_bucket_l1 = rate_bucket_l1
        self._rate_bucket_r = rate_bucket_r
        self._rate_bucket = rate_bucket

    # ---- ç¦æ­¢ dict é£æ ¼ä¸å±æ€§ç›´è¯»æŒ‡æ ‡ ----
    def get(self, *args, **kwargs):
        raise RuntimeError("SNAPSHOT_DIRECT_GET_FORBIDDEN: use secure_read_metric")

    def __getitem__(self, k):
        raise RuntimeError("SNAPSHOT_DIRECT_ITEM_FORBIDDEN: use secure_read_metric")

    def __getattribute__(self, name):
        if name in METRIC_KEYS:
            raise RuntimeError(f"SNAPSHOT_DIRECT_ATTR_FORBIDDEN: {name}")
        return object.__getattribute__(self, name)


def phase_transition(phase, to_phase):
    order = {"SCAN": 0, "DECISION": 1, "EXECUTE": 2, "SETTLE": 3, "DONE": 4, "REPORT": 9}
    if phase not in order or to_phase not in order:
        raise RuntimeError("PHASE_INVALID")
    if order[to_phase] < order[phase]:
        raise RuntimeError(f"PHASE_BACKJUMP: {phase}->{to_phase}")
    return to_phase


def advance_one_row(cursor, records, *, phase, boot_id):
    """æ¨è¿›å”¯ä¸€å…¥å£ï¼ˆé”æ­»ï¼‰ã€‚

    ç›®çš„ï¼šå¯¹å¤–åªæš´éœ²â€œé€è¡Œæ¨è¿›â€ï¼Œç¦æ­¢ä»»ä½• idx+åç§»/éšæœºè·³è½¬è¯»å–æœªæ¥è¡Œã€‚
    - cursor: å½“å‰æ¸¸æ ‡ï¼ˆintï¼‰ï¼ŒæŒ‡å‘å½“å‰è¡Œ
    - records: å½“å‰æ‰¹æ¬¡çš„è¡Œåˆ—è¡¨
    è¿”å›ï¼šnew_cursorï¼ˆintï¼‰ï¼›è‹¥è¶Šç•Œè¿”å› None

    è¯´æ˜ï¼šå‡½æ•°å†…éƒ¨ä½¿ç”¨ +1 å±äºâ€œå°è£…å†…å®ç°â€ï¼Œå¯¹å¤–ä¸æš´éœ²åç§»é‡èƒ½åŠ›ã€‚
    """
    if cursor is None:
        return None
    try:
        c = int(cursor)
    except Exception:
        raise RuntimeError(f"ADVANCE_CURSOR_INVALID: boot_id={boot_id} cursor={cursor}")
    nxt = c + 1
    if nxt < 0 or nxt >= len(records):
        return None
    return nxt


def secure_read_metric(snap, key, phase, *, who, idx, boot_id, seen_all):
    """è¯»æŒ‡æ ‡å”¯ä¸€å…¥å£ï¼ˆé”æ­»ï¼‰ã€‚

    Node 1 å¢å¼ºï¼š
      - å¿…é¡» _METRIC_READ_ARMED == 1
      - å¿…é¡» phase == "DECISION"
      - å¿…é¡» who == "STAR"
      - å¦åˆ™ç›´æ¥ raise
    """
    if _METRIC_READ_ARMED != 1:
        raise RuntimeError("METRIC_READ_NOT_ARMED")

    if key not in METRIC_KEYS:
        raise RuntimeError("METRIC_NAME_INVALID")

    # ä»…å…è®¸ STAR_ROW å¿«ç…§
    try:
        if getattr(snap, "source", None) != "STAR_ROW":
            raise RuntimeError("SNAPSHOT_SOURCE_INVALID")
    except Exception:
        raise RuntimeError("SNAPSHOT_SOURCE_INVALID")

    ok_decision = (phase == "DECISION" and who == "STAR")
    if not ok_decision:
        raise RuntimeError(f"ILLEGAL_METRIC_ACCESS: phase={phase} who={who} metric={key}")

    # seen_all é—¨ç¦ï¼šæŒ‰æœ‰æ•ˆé´çº§é…ç½® gateï¼ˆN=0 ç­‰ä»·å…³é—­ï¼‰
    boot_on, allow_from, _raw = _get_boot_filter_effective()
    min_seen = int(allow_from) if boot_on else 1
    try:
        sa = int(seen_all)
    except Exception:
        raise RuntimeError("SNAPSHOT_SEEN_PARSE_FAIL")
    if sa < min_seen:
        # ä¿æŒæ—§é”™è¯¯ç è¯­ä¹‰ï¼šä»…åœ¨ min_seen==9 æ—¶è§¦å‘
        raise RuntimeError("SNAPSHOT_SEEN_LT9")

    # ä¸€è‡´æ€§ï¼ˆå°½é‡åšï¼Œä¸å¯è§£æåˆ™ä¸é˜»æ–­ï¼‰
    try:
        if int(getattr(snap, "idx")) != int(idx):
            raise RuntimeError("SNAPSHOT_IDX_MISMATCH")
    except Exception:
        pass
    try:
        if int(getattr(snap, "seen_all")) != int(seen_all):
            raise RuntimeError("SNAPSHOT_SEEN_MISMATCH")
    except Exception:
        pass
    try:
        if str(getattr(snap, "boot_id")) != str(boot_id):
            raise RuntimeError("SNAPSHOT_BOOT_MISMATCH")
    except Exception:
        pass

    # å–å€¼ï¼ˆç”¨ object.__getattribute__ ç»•è¿‡ __getattribute__ é™åˆ¶ï¼‰
    metrics = object.__getattribute__(snap, "_metrics")
    return metrics.get(key)


def secure_write_star_snapshot(row, phase, *, seen_all, rr, boot_id, star_idx, star_snapshot_is_none, exh_pair=None):
    """å†™å¿«ç…§å”¯ä¸€å…¥å£ï¼ˆé”æ­»ï¼‰ã€‚
    - ğŸ¯æœ€ç»ˆç¡¬é—¸é—¨ï¼šrr å¿…é¡»æ˜¯ B/P
    - ç¦ä¸‹æ³¨åŒºï¼šå‘½ä¸­ç›´æ¥é˜»æ–­
    - ç¼ºå¤±æŒ‡æ ‡ï¼šrate/mean å…è®¸è½å…¥â€œæ— æ•ˆ/0â€ä»¥ä¿è¯å°å­˜ä¸ç¼ºå€¼ï¼ˆé¿å… StageSnap æ–­è¨€ï¼‰
    """
    if phase != "DECISION":
        raise RuntimeError("STAR_SNAPSHOT_PHASE_NOT_DECISION")
    if not star_snapshot_is_none:
        raise RuntimeError("STAR_SNAPSHOT_DUPLICATE")

    # Node8ï½œğŸ¯æœ€ç»ˆç¡¬é—¸é—¨ï¼ˆé”æ­»ï¼‰ï¼šrr å¿…é¡»æ˜¯ B/Pï¼ˆT æ°¸è¿œä¸å…è®¸è½ğŸ¯ï¼‰
    if rr not in ("B", "P"):
        f = row.get("file", "NA")
        sb = row.get("sub_batch", "NA")
        raise RuntimeError(
            f"STAR_SNAPSHOT_TGT_R_INVALID: rr={rr} file={f} SB={sb} N={seen_all} star_idx={star_idx} boot_id={boot_id}"
        )

    # seen_all é—¨ç¦ï¼ˆç¦ä¸‹æ³¨åŒºå¿…é¡»é˜»æ–­ï¼‰
    boot_on, allow_from, _raw = _get_boot_filter_effective()
    min_seen = int(allow_from) if boot_on else 1
    try:
        sa = int(seen_all)
    except Exception:
        raise RuntimeError("STAR_SNAPSHOT_SEEN_PARSE_FAIL")
    if sa < min_seen:
        raise RuntimeError("BET_IN_FORBIDDEN_SEEN")

    _arm_metric_read()
    try:
        tmp_snap = Snapshot(
            {
                "diff": row.get("diff"),
                "rate": row.get("rate"),
                "mean": row.get("mean"),
                "rate_raw": row.get("rate_raw"),
                "mean_raw": row.get("mean_raw"),
            },
            boot_id=boot_id,
            idx=star_idx,
            seen_all=seen_all,
            rr=rr,
            source="STAR_ROW",
        )

        d = secure_read_metric(tmp_snap, "diff", phase, who="STAR", idx=star_idx, boot_id=boot_id, seen_all=seen_all)
        r = secure_read_metric(tmp_snap, "rate", phase, who="STAR", idx=star_idx, boot_id=boot_id, seen_all=seen_all)
        m = secure_read_metric(tmp_snap, "mean", phase, who="STAR", idx=star_idx, boot_id=boot_id, seen_all=seen_all)

        rate_raw_text = secure_read_metric(
            tmp_snap, "rate_raw", phase, who="STAR", idx=star_idx, boot_id=boot_id, seen_all=seen_all
        )
        mean_raw_text = secure_read_metric(
            tmp_snap, "mean_raw", phase, who="STAR", idx=star_idx, boot_id=boot_id, seen_all=seen_all
        )

        # diff ä¸¥æ ¼ï¼š1..9
        try:
            d_int = int(float(d))
        except Exception:
            raise RuntimeError("STAR_SNAPSHOT_DIFF_PARSE_FAIL")
        if d_int == 0:
            raise RuntimeError("STAR_SNAPSHOT_DIFF_ZERO")
        if abs(d_int) > 9:
            raise RuntimeError("STAR_SNAPSHOT_DIFF_OVER_9")

        # rate ç¼ºå¤±ï¼šç”¨ 0.0 å ä½ï¼Œå¹¶å¼ºåˆ¶æ¡¶=æ— æ•ˆï¼ˆé¿å… â€œæ— æ•ˆâ€ è¢«å½“ floatï¼‰
        force_rate_invalid = 0
        if r is None:
            r = 0.0
            force_rate_invalid = 1

        # mean ç¼ºå¤±ï¼šç”¨ 0.0 å ä½ï¼Œå¹¶å¼ºåˆ¶ mean_bucket=æ— æ•ˆ
        mean_bucket = None
        if m is None:
            m = 0.0
            mean_bucket = "æ— æ•ˆ"

        mode, l1b, rb, active = _rate_quartet(exh_pair, r)
        if force_rate_invalid:
            mode = "æ— æ•ˆ"
            l1b = "æ— æ•ˆ"
            rb = "æ— æ•ˆ"
            active = "æ— æ•ˆ"

        diff_bucket = _l1_abs_diff_bucket(d_int)
        if mean_bucket is None:
            mean_bucket, _ = _l1_mean_bucket(d_int, m)

        sealed_values = {
            "diff_val": d_int,
            "rate_val": r,
            "mean_val": m,
            "diff_bucket": diff_bucket,
            "mean_bucket": mean_bucket,
        }

        final_snap = Snapshot(
            {"diff": d, "rate": r, "mean": m, "rate_raw": rate_raw_text, "mean_raw": mean_raw_text},
            boot_id=boot_id,
            idx=star_idx,
            seen_all=seen_all,
            rr=rr,
            source="STAR_ROW",
            sealed_values=sealed_values,
        )

        final_snap._bind_rate_fields(
            exh_pair=exh_pair,
            rate_mode=mode,
            rate_bucket_l1=l1b,
            rate_bucket_r=rb,
            rate_bucket=active,
        )

        _bind_raw_text_fields(final_snap, rate_raw_text, mean_raw_text)
        return final_snap

    finally:
        _disarm_metric_read()


def write_star_snapshot(phase, star_row, star_idx):
    """å”¯ä¸€å…¥å£ï¼ˆé”æ­»ï¼‰ï¼šä¸ç®¡æ™®é€š/å»¶è¿Ÿç»“æ„ï¼ŒğŸ¯=ä¸‹æ³¨å£=å–å€¼ç‚¹éƒ½å¿…é¡»å†™å¿«ç…§ã€‚"""
    rr = star_row.get("r")
    seen_all = star_row.get("seen_all")
    boot_id = star_row.get("boot_id", star_row.get("shoe_id"))

    # Node11ï½œé”æ­»ï¼šDECISION ä¸€å¾‹å†™å¿«ç…§ï¼›å…¶å®ƒé˜¶æ®µä¸€å¾‹ç¦æ­¢
    if phase != "DECISION":
        raise RuntimeError("STAR_SNAPSHOT_PHASE_NOT_DECISION")

    return secure_write_star_snapshot(
        star_row,
        phase,
        seen_all=seen_all,
        rr=rr,
        boot_id=boot_id,
        star_idx=star_idx,
        star_snapshot_is_none=True,
    )


def _to_row_lite(row):
    """å»æŒ‡æ ‡åŒ–ï¼šè¿›å…¥ EXECUTE/SETTLE çš„ row åªä¿ç•™å¿…è¦å­—æ®µã€‚"""
    keep = {
        "r": row.get("r"),
        "shoe_id": row.get("shoe_id"),
        "boot_id": row.get("boot_id", row.get("shoe_id")),
        "idx": row.get("idx"),
        "seen_all": row.get("seen_all"),
        "file": row.get("file"),
        "sub_batch": row.get("sub_batch"),
    }
    return MetricGuardRow(keep)


def guard_future_rows(records, start_j):
    """ä» start_j å¼€å§‹æŠŠåç»­è¡Œæ›¿æ¢ä¸º RowLite(MetricGuardRow)ï¼Œä»æ ¹æºå»æŒ‡æ ‡ã€‚"""
    for k in range(start_j, len(records)):
        r = records[k]
        if isinstance(r, MetricGuardRow):
            continue
        records[k] = _to_row_lite(r)
    """ä» start_j å¼€å§‹æŠŠåç»­è¡Œæ›¿æ¢ä¸º RowLite(MetricGuardRow)ï¼Œä»æ ¹æºå»æŒ‡æ ‡ã€‚"""
    for k in range(start_j, len(records)):
        r = records[k]
        if isinstance(r, MetricGuardRow):
            continue
        records[k] = _to_row_lite(r)


# ==========================
# å…¨å±€å¼€å…³ï¼ˆå¿…é¡»æ˜¾å¼å®šä¹‰ï½œé¿å… NameErrorï¼‰
# ==========================
# ç›‘æµ‹å¼€å…³ï¼š0=å…³ï¼Œ1=å¼€ï¼ˆé»˜è®¤å…³ï¼›ä»…å½±å“â€œç›‘æµ‹/é›·è¾¾â€è¾“å‡ºï¼Œä¸å¾—å½±å“é›¶æœªæ¥ä¸ä¸‹æ³¨è·¯å¾„ï¼‰
MONITOR_ENABLE = 0

# éªŒè¯åˆ†æ‹†å¼€å…³ï¼š0=å…³ï¼Œ1=å¼€ï¼ˆé»˜è®¤å…³ï¼›è‹¥å¼€å¯ï¼Œå¿…é¡»ä»æ»¡è¶³é›¶æœªæ¥ä¸ä¸€æ¬¡æ€§æ‰«æçº¦æŸï¼‰
VERIFY_SPLIT_ENABLE = 0

# è¡¨å¤´è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡
_HEADER_MAPPING_PRINTED = False

# PP/BB æ’ç­‰å¼è‡ªè¯è®¡æ•°ï¼ˆé”æ­»ï¼‰
ENFORCE_PPBB_SEMANTICS = 1  # 1=å¼ºåˆ¶æŠ½æ£€ç‚¹å·®æ’ç­‰å¼ä¸ç»“æœæ˜ å°„ï¼ˆPP=é—²ç‚¹/BB=åº„ç‚¹ï¼‰
# ============================================================
# åŸºåº•æŒ‡çº¹ç»‘å®šï¼ˆé”æ­»ï½œç”¨äºâ€œå†»ç»“åŒº/è§„åˆ™åŒºç¡¬éš”ç¦»â€ï¼‰
# - BASELINE_HASH_POLICY:
#   - OFF: ä¸æ ¡éªŒï¼ˆæœ€å®½æ¾ï¼Œé€‚åˆå…ˆè·‘é€š/å¿«é€Ÿè¯•ç­–ç•¥ï¼‰
#   - WARN: æ‰“å°ä¸€è¡ŒWARNä¸ä¸­æ–­ï¼ˆå¼€å‘æœŸé»˜è®¤ï¼‰
#   - ENFORCE: ä¸åŒ¹é…ç›´æ¥æŠ¥é”™ï¼ˆå‘å¸ƒæœŸå†»ç»“ï¼‰
BASELINE_HASH_POLICY = "WARN"  # OFF / WARN / ENFORCE
ENFORCE_BASELINE_HASH = (BASELINE_HASH_POLICY == "ENFORCE")
WARN_BASELINE_HASH = (BASELINE_HASH_POLICY == "WARN")
EXPECTED_SOURCE_HASHES = {
    "secure_read_metric": "bcb3372ccd58fbb3d6fd79c426f60996b9ae8bfa04015f36d877ca3df44083c0",
    "secure_write_star_snapshot": "37e6215177ca6ff3ce4cb44f3e10b7f20bbc8b4cfe48657cacd8a0a6e284bf3c",
    "write_star_snapshot": "3c24ae66fbeb0d3a7f2daf699792c6b957d47ff512f18b488493f48745208e22",
    "phase_transition": "57d446d741a08163ed8f964d8edfb17bf4f9247dc42f23a1702d3d5eff7ad490",
    "advance_one_row": "1177db2eecbd85cd8c5f8894a309ce190dc1e3901fd06c082716b10cb594390d",
    "load_all_boots": "5763b0f4dd836c69c8bc72c41301938ddd3ddb0e752a4b28ea502dc76285bc72",
    "_audit_forbid_idx_offset": "d2755d9f2f5610fc202e4368accf5005a329b6d1406b19cf7484915609158671",
    "_audit_structure_slot_integrity": "f827836a9ea7b13a28a058f7edab2723b81626f4f4e82f356990267323843ae1",
}
PPBB_CHECKED = 0
PPBB_MISMATCH = 0
PPBB_FIRST_EVIDENCE = None

# ==========================
# æ­£å€¼è§¦å‘è‡ªå®¡é—¸é—¨ï¼ˆæ—¶é—´ç®¡ç†å±€ï½œé”æ­»ï¼‰
# ==========================
# å¼€å…³ï¼š1=å¯ç”¨ï¼Œ0=å…³é—­
POSITIVE_AUDIT_ENABLE = 1

# è§¦å‘é—¨æ§›ï¼ˆäºŒé€‰ä¸€æˆ–åŒæ—¶å¯ç”¨ï¼›é»˜è®¤ä»… Total>0ï¼‰
POSITIVE_AUDIT_TRIGGER_TOTAL = 1  # Total_Profit > 0
POSITIVE_AUDIT_TRIGGER_AVG = 0  # Avg_Profit > 0

# å½±å­é‡ç®—ï¼ˆå¯é€‰ï½œé»˜è®¤å…³ï¼›ä»…ç”¨äºè‡ªè¯ä¸€è‡´æ€§ï¼Œä¸æ”¹ç­–ç•¥é€»è¾‘ï¼‰
POSITIVE_AUDIT_SHADOW_RECHECK = 0

# è¿è¡Œæ€è‡ªè¯æ ‡è®°ï¼ˆé”æ­»ï¼‰
_WATERMARK_PRINTED = False
_PROOF_BLOCK_PRINTED = False
_SELFTEST_PASSED = False
_SOURCE_HASHES_PRINTED = False

# è¾“å‡ºé™é»˜å¼€å…³ï¼š1=é™é»˜ï¼ˆä»…ä¿ç•™ä¸»æŠ¥å‘Š+å¼ºåˆ¶è‡ªè¯ï¼›ä¸æ‰“å°è¡¨å¤´è‡ªè¯/L1åˆ†å¸ƒ/è¿ç»­ç»Ÿè®¡ï¼‰ï¼Œ0=è¯¦ç»†
# ğŸ€è¦†ç›–é”šç‚¹003_é™é»˜å¼€å…³ï¼ˆ0=å…¨é‡æŠ¥å‘Šé»˜è®¤æ˜¾ç¤ºï¼›1=åªä¿ç•™æœ€ç®€ç»“æœï¼‰
SILENT_MODE = 1

# å®¡æŸ¥è·‘å¼€å…³ï¼ˆæ—¶é—´ç®¡ç†å±€ï½œé”æ­»ï¼‰
# è§„åˆ™ï¼šå½“ AUDIT_RUN=1 æ—¶ï¼Œå¿…é¡»æ— æ¡ä»¶è¾“å‡ºâ€œå®¡æŸ¥è·‘å¿…å‡ºå—â€ï¼ˆå« L1 ä¸‰å—é”æ­»æ ‡é¢˜ï¼‰ï¼Œä¸å— SILENT_MODE å½±å“ã€‚
AUDIT_RUN = 1  # 0=æ™®é€šè·‘ï¼›1=å®¡æŸ¥è·‘ï¼ˆå®¡æŸ¥è·‘å¿…å‡ºï¼‰

# ============================================================
# å®¡è®¡æ—¥å¿—ç¼“å†²ï¼ˆé»˜è®¤é™é»˜ï½œä»…å¤±è´¥/æŠ¥é”™è¾“å‡ºï½œé”æ­»ï¼‰
# - ç›®çš„ï¼šé¿å…å“ˆå¸Œ/loc/å®¡è®¡æ˜ç»†å ç”¨æ‰“å°é¢æ¿
# - è¡Œä¸ºï¼šæ­£å¸¸âœ…é€šè¿‡ä¸æ‰“å°ï¼›é‡åˆ°âŒâŒâŒæˆ–å¼‚å¸¸æ—¶ä¸€æ¬¡æ€§åå‡ºç¼“å†²åŒº
# ============================================================
AUDIT_FAIL_ONLY = 1  # 1=ä»…å¤±è´¥è¾“å‡ºâœ…ï¼›0=æ€»æ˜¯è¾“å‡ºï¼ˆè°ƒè¯•ç”¨ï¼‰
_AUDIT_LOG_BUF = []


def _audit_log(line: str):
    try:
        _AUID = AUDIT_FAIL_ONLY
    except Exception:
        _AUID = 1
    # å§‹ç»ˆè®°å½•ï¼›æ˜¯å¦æ‰“å°ç”± flush å†³å®š
    _AUDIT_LOG_BUF.append(str(line))


def _flush_audit_log(tag: str = ""):
    global _AUDIT_LOG_BUF
    if not _AUDIT_LOG_BUF:
        return
    # ä»…åœ¨å¤±è´¥è·¯å¾„è°ƒç”¨æœ¬å‡½æ•°ï¼›å› æ­¤ä¸å†é¢å¤–åˆ¤æ–­é€šè¿‡/å¤±è´¥
    head = "ã€å®¡è®¡æ—¥å¿—ï¼ˆä»…å¤±è´¥è¾“å‡ºï¼‰ã€‘"
    if tag:
        head += f" {tag}"
    print(head)
    for x in _AUDIT_LOG_BUF:
        print(x)
    _AUDIT_LOG_BUF = []


# é´çº§å¼€å…³ï¼ˆé”æ­»ï¼‰ï¼šä»…é™åˆ¶â€œå®é™…è½æ³¨â€æ˜¯å¦å…è®¸å‘ç”Ÿåœ¨é´é¦–ç¦æŠ•åŒºï¼ˆæ²¿ç”¨ç°æœ‰ seen_all è®¡æ•°å£å¾„ï¼‰
# æ—§å£å¾„ï¼šN=9 => ç¦ä¸‹æ³¨ seen_all=1..8ï¼›ç¬¬9å£èµ·å…è®¸
# æ–°å¢ï¼ˆé”šç‚¹002è¦†ç›–ï¼‰ï¼šBOOT_BLOCK_N_OVERRIDEï¼ˆæ•´æ•°å­—ç¬¦ä¸²ï¼‰
# - ç©ºå­—ç¬¦ä¸²ï¼šä¸è¦†ç›–ï¼ˆç»§ç»­ä½¿ç”¨ BOOT_FILTER å¼€å…³ä¸æ—§é»˜è®¤ N=9ï¼‰
# - N=0ï¼šå¼ºåˆ¶å…³é—­é´çº§å¼€å…³ï¼ˆç­‰ä»· BOOT_FILTER=OFFâ›”ï¼‰
# - N>=1ï¼šå¼ºåˆ¶å¼€å¯é´çº§å¼€å…³ï¼Œå¹¶å°† N è®¾ä¸ºè¯¥å€¼ï¼ˆä¸‹é™é’³åˆ¶ä¸º 3ï¼‰
BOOT_FILTER = 0  # 1=ONâœ…ï¼Œ0=OFFâ›”ï¼ˆå½“ BOOT_BLOCK_N_OVERRIDE éç©ºæ—¶ï¼Œæœ¬å¼€å…³ä¼šè¢«è¦†ç›–ï¼‰

BOOT_FILTER_ALLOW_FROM_DEFAULT = 9  # é»˜è®¤ç¬¬9å£èµ·å…è®¸ï¼ˆç­‰ä»·æ—§ç‰ˆ seen_all=1..8 ç¦æŠ•ï¼‰
BOOT_FILTER_ALLOW_FROM_MIN = 3  # ä½ è¦æ±‚çš„æœ€å°é—¨æ§›ï¼šç¬¬3å£èµ·å…è®¸


def _get_boot_filter_effective():
    """è¿”å› (boot_on: bool, allow_from_n: int, raw_override: str)"""
    raw = (globals().get("BOOT_BLOCK_N_OVERRIDE", "") or "").strip()
    if raw == "":
        # ä¸è¦†ç›–ï¼šä¿æŒæ—§è¡Œä¸ºï¼ˆå¼€å…³=BOOT_FILTERï¼Œé—¨æ§›=é»˜è®¤9ï¼‰
        return (bool(BOOT_FILTER), int(BOOT_FILTER_ALLOW_FROM_DEFAULT), raw)

    # è¦†ç›–ï¼šN=0 å…³é—­ï¼›N>=1 å¼€å¯ï¼ˆä¸‹é™=3ï¼‰
    try:
        n = int(raw)
    except Exception:
        raise RuntimeError(f"âŒ BOOT_BLOCK_N_OVERRIDE å¿…é¡»ä¸ºæ•´æ•°å­—ç¬¦ä¸²ï¼šgot={raw!r}")

    if n < 0:
        raise RuntimeError(f"âŒ BOOT_BLOCK_N_OVERRIDE ä¸å…è®¸ä¸ºè´Ÿæ•°ï¼šgot={n}")

    if n == 0:
        return (False, int(BOOT_FILTER_ALLOW_FROM_DEFAULT), raw)

    n_eff = n if n >= BOOT_FILTER_ALLOW_FROM_MIN else int(BOOT_FILTER_ALLOW_FROM_MIN)
    return (True, int(n_eff), raw)


def _boot_filter_label() -> str:
    boot_on, allow_from, raw = _get_boot_filter_effective()
    if not boot_on:
        if raw == "0":
            return "BOOT_FILTER=OFFâ›”(ç”± BOOT_BLOCK_N_OVERRIDE=0 å…³é—­)"
        return "BOOT_FILTER=OFFâ›”(é´é¦–å…è®¸ä¸‹æ³¨)"
    forbid_hi = max(int(allow_from) - 1, 0)
    if forbid_hi >= 1:
        return f"BOOT_FILTER=ONâœ…(ç¦ä¸‹æ³¨ seen_all=1..{forbid_hi}ï¼›ç¬¬{allow_from}å£èµ·å…è®¸)"
    return f"BOOT_FILTER=ONâœ…(ç¬¬{allow_from}å£èµ·å…è®¸)"


# BOOT_FILTER ç¦åŒºå¤„ç†ç­–ç•¥ï¼ˆå†»ç»“åŒºçœŸæºï½œé”æ­»ï¼‰
# 0=SKIP_STARï¼šå‘½ä¸­ç¦åŒºâ™»â­åªè·³è¿‡è¯¥â­ï¼Œç»§ç»­åœ¨åŒä¸€é´å¯»æ‰¾ä¸‹ä¸€é¢—â™»â­ï¼ˆéé¡ºå»¶ï¼‰
# 1=ABORT_BOOTï¼šå‘½ä¸­ç¦åŒºâ™»â­ç›´æ¥ä½œåºŸæ•´é´ï¼ˆä¸å†å¯»æ‰¾ä¸‹ä¸€é¢—â™»â­ï¼‰
BOOT_FILTER_FORBIDDEN_ABORT = 0

BET_IN_FORBIDDEN_SEEN = 0  # å®é™…è½æ³¨ç‚¹è½åœ¨ ç¦æŠ•åŒº(seen_all < N) çš„è®¡æ•°ï¼ˆå‘ç°å³ raiseï¼‰
# ============================================================
# ç»“æ„æ‰«æå¼€å…³ï¼ˆç»“æ„é—¸é—¨ï½œé”æ­»ï¼‰
# ============================================================
STRUCT_SCAN = 1  # 1=ONâœ…ï¼Œ0=OFFâ›”ï¼ˆä»…è‡ªè¯ç”¨ï¼ŒOFFæ—¶ç¦æ­¢ä»»ä½•ç­–ç•¥æ‰§è¡Œï¼‰
STRUCT_SCAN_TEXT = "STRUCT_SCAN=ONâœ…(ç»“æ„æ‰«æå¼€å¯)" if STRUCT_SCAN else "STRUCT_SCAN=OFFâ›”(ç»“æ„æ‰«æå…³é—­-ä»…è‡ªè¯)"
# ============================================================
# ç»“æ„æ’æ§½åŒºï¼ˆç‰ˆæœ¬Aï½œå”¯ä¸€å…è®¸å‡ºç°ç»“æ„é€»è¾‘çš„åŒºåŸŸï½œé”æ­»ï¼‰
# - åç»­æ›´æ¢ç»“æ„ï¼šåªå…è®¸æ›¿æ¢ã€Œç»“æ„æ’æ§½åŒºå¼€å§‹/ç»“æŸã€ä¸¤è¡Œä¹‹é—´çš„å†…å®¹
# - å…¶ä½™ä»»ä½•ä½ç½®å‡ºç°ç»“æ„åˆ¤æ–­/ç»“æ„å‡½æ•°è§†ä¸ºæ±¡æŸ“ï¼ˆè‡ªæ£€ä¼šæ‹¦æˆªï¼‰
# ============================================================

# ============================================================
# ç»“æ„æ’æ§½ï½œæ¸…å•ä¸æŒ‡çº¹ï¼ˆåŸºåº§/æ’æ§½åˆ†ç¦»ï¼‰
# - æ ¸å¿ƒåŸºåº§æŒ‡çº¹ï¼šæ’é™¤ç»“æ„æ’æ§½æ–‡æœ¬ï¼Œç”¨äºâ€œåŸºåº•å†»ç»“â€åˆ¤å®š
# - æ’æ§½æŒ‡çº¹ï¼šä»…ç»“æ„æ’æ§½æ–‡æœ¬ï¼Œç”¨äºâ€œç»“æ„å¯å˜â€è®°å½•
# - æ’æ§½å¿…é¡»å¯è¢«è¾¹ç•Œæ ‡è¯†å”¯ä¸€å®šä½ï¼š0ä¸ªæˆ–>1ä¸ªå‡åˆ¤æ­»
# ============================================================
STRUCTURE_SLOT_NAME = "STRUCTURE_SLOT"
STRUCTURE_SLOT_VERSION = "V2"
CORE_BASE_FINGERPRINT = None
STRUCTURE_SLOT_FINGERPRINT = None
STRUCTURE_SLOT_LINE_RANGE = None  # (begin_line, end_line)

# ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_BEGINï¼ˆæ•´æ®µè¦†ç›–ç”¨æ­¤è¡Œå®šä½ï¼›è¦†ç›–èŒƒå›´=æœ¬è¡Œåˆ°å¯¹åº”_ENDï¼‰
# [SLOT_BEGIN] STRUCTURE_SLOT
# [STRUCT_SLOT_BEGIN]
# é”šç‚¹001=ç»“æ„å”¯ä¸€çœŸæºï¼ˆä»…å†…éƒ¨ç»´æŠ¤ï½œå†™æ‰‹ç¦æ­¢æ”¹åŠ¨ï¼‰
# å†™æ‰‹åªå…è®¸è¦†ç›–é”šç‚¹002ï¼ˆå‚æ•°/è§„åˆ™æ—/æŠ¥å‘Šå‚æ•°è¡Œï¼‰ï¼Œä¸å¾—å†™ç»“æ„æ‰«æä»£ç ï¼Œä¸å¾—è§¦ç¢°å†»ç»“åŒº
# åˆ‡ç»“æ„ï¼šä»…æ”¹ ACTIVE_STRUCT_NAME ä¸€è¡Œï¼›è¿è¡Œæ—¶ç»“æ„åªç”±é”šç‚¹001å†³å®š
# ç»“æ„è¡¨åˆ—ï¼šstep | side(S/W) | min_len | max_len | mark(â­=ç»“æ„ç»ˆç‚¹)
# é”æ­»ï¼šæ¯ä¸ª variant çš„ value åªèƒ½æ˜¯ä¸€å¼ è¡¨ï¼›step=1..N è¿ç»­ï¼›â­å”¯ä¸€ä¸”åœ¨æœ€åä¸€è¡Œ

# ------------------------- ç»“æ„åº“ï¼ˆå†…éƒ¨ç»´æŠ¤ï¼‰-------------------------
STRUCT_VARIANTS = {
    # ===================== ä¸‰è¿ç»“æ„ =====================
    # Y1-2 â†’ X=3 â­ï½œæŠ•æ”¾æ–¹å‘ï¼šXï¼ˆè·Ÿéšâ­ï¼‰
    "ä¸‰è¿ç»“æ„": """step	side	min_len	max_len	mark
1	Y	1	2
2	X	3	3	â­
""",

    # ===================== Q1 =====================
    # Xâ‰¥3 â†’ Y1-2 â†’ Xâ­ï½œæŠ•æ”¾æ–¹å‘ï¼šXï¼ˆè·Ÿéšâ­ï¼‰
    "Q1": """step	side	min_len	max_len	mark
1	X	3	999
2	Y	1	2
3	X	1	999	â­
""",

    # ===================== Q1-V2 =====================
    # Y1-2 â†’ Xâ‰¥3 â†’ Y1-2 â†’ Xâ­ï½œæŠ•æ”¾æ–¹å‘ï¼šXï¼ˆè·Ÿéšâ­ï¼‰
    "Q1-V2": """step	side	min_len	max_len	mark
1	Y	1	2
2	X	3	999
3	Y	1	2
4	X	1	999	â­
""",

    # ===================== Q1-X4ç‰ˆ =====================
    # Xâ‰¥4 â†’ Y1-2 â†’ Xâ­ï½œæŠ•æ”¾æ–¹å‘ï¼šXï¼ˆè·Ÿéšâ­ï¼‰
    "Q1-X4ç‰ˆ": """step	side	min_len	max_len	mark
1	X	4	999
2	Y	1	2
3	X	1	999	â­
""",

    # ===================== å»¶è¿Ÿ-Q1-X4_åŒç‚¹ï¼ˆğŸ‘€=ğŸ¯ï½œæå€¼å½“å£ï¼‰ =====================
    # åŸºåº•ï¼šXâ‰¥4 â†’ Y1-2 â†’ Xâ­ï½œå»¶è¿Ÿï¼šä»ğŸ‘€åç«‹åˆ»è§†ä¸ºğŸ¯ï¼ˆåŒç‚¹å‹ï¼‰
    # ğŸ‘€æ¡ä»¶ï¼šRate=æå€¼ï¼ˆå¯è°ƒï¼‰
    # ğŸ¯æ¡ä»¶ï¼šåŒğŸ‘€ï¼ˆå›ºå®šåŒç‚¹ï¼‰
    # æŠ•æ”¾æ–¹å‘ï¼šSï¼ˆğŸ¯å½“å£ï¼›ç»“ç®—å£=ğŸ¯åä¸€å£èµ·é¦–ä¸ªéTï¼›Tè·³è¿‡ï¼‰
    "å»¶è¿Ÿ-Q1-X4_åŒç‚¹": """step	side	min_len	max_len	mark
    1	X	4	999
    2	Y	1	2
    3	X	1	999	ğŸ‘€â­
    """,

    # ===================== å»¶è¿Ÿ-Q1-X4_æå€¼åï¼ˆå…ˆğŸ‘€æå€¼â†’å†ç­‰ğŸ¯ï¼‰ =====================
    # åŸºåº•ï¼šXâ‰¥4 â†’ Y1-2 â†’ Xâ­ï½œå»¶è¿Ÿï¼šå…ˆå‘½ä¸­ğŸ‘€(Rate=æå€¼)ï¼Œå†ä»ğŸ‘€åé€å£ç­‰ğŸ¯å‘½ä¸­
    # ğŸ‘€æ¡ä»¶ï¼šRate=æå€¼ï¼ˆå¯è°ƒï¼‰
    # ğŸ¯æ¡ä»¶ï¼šTBDï¼ˆåç»­ç”±ä½ /æ¢é’ˆåœ¨002é‡Œæšä¸¾æˆ–å›å¡«ï¼‰
    # æŠ•æ”¾æ–¹å‘ï¼šSï¼ˆğŸ¯å½“å£ï¼›ç»“ç®—å£=ğŸ¯åä¸€å£èµ·é¦–ä¸ªéTï¼›Tè·³è¿‡ï¼‰
    "å»¶è¿Ÿ-Q1-X4_æå€¼å": """step	side	min_len	max_len	mark
    1	X	4	999
    2	Y	1	2
    3	X	1	999	ğŸ‘€â­
    """,

    # ===================== R1 =====================
    # Xâ‰¥4 â†’ Y1-2 â†’ X1-2 â†’ â­Y1ï½œæŠ•æ”¾æ–¹å‘ï¼šXï¼ˆè·Ÿéšâ­ï¼‰
    "R1": """step	side	min_len	max_len	mark
1	X	4	999
2	Y	1	2
3	X	1	2
4	Y	1	1	â­
""",

    # ===================== 31æ‰“å =====================
    # Y1-2 â†’ X=3 â†’ Y1â­ï½œæŠ•æ”¾æ–¹å‘ï¼šXï¼ˆç»“æ„31æ‰“åï¼‰
    "31æ‰“å": """step	side	min_len	max_len	mark
1	Y	1	2
2	X	3	3
3	Y	1	1	â­
""",

    # ===================== å•è¾¹41 =====================
    # Y1-2 â†’ X=4 â†’ Y1=1 â†’ X=1â­ï½œæŠ•æ”¾æ–¹å‘ï¼šXï¼ˆè·Ÿéšâ­ï¼‰
    "å•è¾¹41": """step	side	min_len	max_len	mark
1	Y	1	2
2	X	4	4
3	Y	1	1
4	X	1	1	â­
""",
}

# å½“å‰å¯ç”¨ç»“æ„ï¼ˆåˆ‡ç»“æ„åªæ”¹è¿™ä¸€è¡Œï¼‰
ACTIVE_STRUCT_NAME = "ä¸‰è¿ç»“æ„"

# è¿è¡Œæ—¶ç”Ÿæ•ˆç»“æ„è¡¨ï¼ˆè§£æå™¨/æ‰«æå™¨åªè¯»è¿™ä¸ªï¼‰
if ACTIVE_STRUCT_NAME not in STRUCT_VARIANTS:
    raise RuntimeError(f"âŒ ç»“æ„ä¸å­˜åœ¨ï¼š{ACTIVE_STRUCT_NAME}")
STRUCT_CONFIG_TEXT = STRUCT_VARIANTS[ACTIVE_STRUCT_NAME]
# ------------------------- æ‰§è¡Œé“¾è·¯ Profile åº“ï¼ˆå†…éƒ¨ç»´æŠ¤ï¼‰-------------------------
# è¯´æ˜ï¼šé”šç‚¹002åªå…è®¸å¡« EXEC_PROFILE_OVERRIDE å­—ç¬¦ä¸²ï¼›å†»ç»“åŒºå°†åšç™½åå•æ ¡éªŒå¹¶åº”ç”¨
EXEC_PROFILES = {
    # é©¬ä¸ï¼ˆè¾“è¿›ï½œæŒ‰åºåˆ—æ¨è¿›ï¼‰
    "MARTIN_1248": {"mode": "MARTIN_SEQ", "units": [1, 2, 4, 8]},
    "MARTIN_124816": {"mode": "MARTIN_SEQ", "units": [1, 2, 4, 8, 16]},
    "MARTIN_124": {"mode": "MARTIN_SEQ", "units": [1, 2, 4]},
    # é¢„ç•™ï¼šå¹³æ³¨/èƒœè¿›ç­‰éœ€å†»ç»“åŒºæ–°å¢ MODE æ”¯æŒåå†å¯ç”¨ï¼ˆå½“å‰é€‰æ‹©ä¼šæ˜ç¡®æŠ¥é”™ï¼‰
    "FLAT_1": {"mode": "RESERVED_NOT_ENABLED_YET"},
    "WINPRESS_1_1_1p5": {"mode": "RESERVED_NOT_ENABLED_YET"},
}
DEFAULT_EXEC_PROFILE = "MARTIN_1248"

# ------------------------- å¿«ç…§é“¾è·¯ Profile åº“ï¼ˆå†…éƒ¨ç»´æŠ¤ï¼‰-------------------------
# è¯´æ˜ï¼šé”šç‚¹002åªå…è®¸å¡« SNAP_PROFILE_OVERRIDE å­—ç¬¦ä¸²ï¼›å†»ç»“åŒºå°†åšç™½åå•æ ¡éªŒå¹¶åº”ç”¨
SNAP_PROFILES = {
    # ä¸æ—§é»˜è®¤ä¿æŒä¸€è‡´ï¼šä»… L4 ç»Ÿè®¡ï¼ˆä¸æ¼‚ç§»ï¼‰
    "L4_ONLY": {"TARGET_STAGE": "L4", "ENABLE_L1": 0, "ENABLE_L2": 0, "ENABLE_L3": 0, "ENABLE_L4": 1, "ENABLE_L5": 0},

    # å…¨å¼€ï¼ˆç›®æ ‡å±‚ä»é»˜è®¤ L4ï¼‰
    "ALL_ON": {"TARGET_STAGE": "L4", "ENABLE_L1": 1, "ENABLE_L2": 1, "ENABLE_L3": 1, "ENABLE_L4": 1, "ENABLE_L5": 0},

    # å¸¸ç”¨ç»„åˆ
    "L1_L4": {"TARGET_STAGE": "L4", "ENABLE_L1": 1, "ENABLE_L2": 0, "ENABLE_L3": 0, "ENABLE_L4": 1, "ENABLE_L5": 0},
    "L1_ONLY": {"TARGET_STAGE": "L1", "ENABLE_L1": 1, "ENABLE_L2": 0, "ENABLE_L3": 0, "ENABLE_L4": 0, "ENABLE_L5": 0},

    # L5ï¼ˆæ–°å¢ï½œé€»è¾‘åŒ L4ï¼›é»˜è®¤ä»ç”¨ L4_ONLY ä¸æ¼‚ç§»ï¼‰
    "L5_ONLY": {"TARGET_STAGE": "L5", "ENABLE_L1": 0, "ENABLE_L2": 0, "ENABLE_L3": 0, "ENABLE_L4": 0, "ENABLE_L5": 1},
    "L4_L5": {"TARGET_STAGE": "L5", "ENABLE_L1": 0, "ENABLE_L2": 0, "ENABLE_L3": 0, "ENABLE_L4": 1, "ENABLE_L5": 1},
    "ALL_ON_L5": {"TARGET_STAGE": "L5", "ENABLE_L1": 1, "ENABLE_L2": 1, "ENABLE_L3": 1, "ENABLE_L4": 1, "ENABLE_L5": 1},
}
DEFAULT_SNAP_PROFILE = "L4_ONLY"


def scan_structure(records):
    """ç»“æ„æ’æ§½ï¼ˆè¦†ç›–åŒºï¼‰ï¼šåªæä¾› STRUCT_CONFIG_TEXTï¼›æ‰«æå™¨åœ¨å†»ç»“åŒºã€‚"""
    # é˜²ä¸²å°ï¼šç¡®ä¿è¿è¡Œæ—¶ç»“æ„è¡¨ç¡®å®æ¥è‡ªç»“æ„åº“é€‰æ‹©å™¨ï¼ˆé”šç‚¹002ä¸å¾—åå‘å½±å“é”šç‚¹001ï¼‰
    if not globals().get("_STRUCT_SLOT_NAME_PRINTED"):
        if ACTIVE_STRUCT_NAME not in STRUCT_VARIANTS:
            raise RuntimeError(f"âŒ ç»“æ„ä¸å­˜åœ¨ï¼š{ACTIVE_STRUCT_NAME}")
        if STRUCT_CONFIG_TEXT != STRUCT_VARIANTS[ACTIVE_STRUCT_NAME]:
            raise RuntimeError(
                "âŒ ç»“æ„ä¸²å°ï¼šSTRUCT_CONFIG_TEXT ä¸ ACTIVE_STRUCT_NAME ä¸ä¸€è‡´ï¼ˆè¯·æ£€æŸ¥é”šç‚¹002æ˜¯å¦è¯¯å†™ç»“æ„å˜é‡ï¼‰")
        print(f"ç»“æ„åï¼š{ACTIVE_STRUCT_NAME}")
        globals()["_STRUCT_SLOT_NAME_PRINTED"] = True
    return _frozen_scan_structure(records, STRUCT_CONFIG_TEXT)


# [STRUCT_SLOT_END]
# [SLOT_END] STRUCTURE_SLOT
# ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_END


STRUCT_DEF_HASH = None  # AUTOï¼ˆç”± STRUCT_CONFIG_TEXT + Anchor è®¡ç®—ï¼‰
_STRUCT_SUMMARY_PRINTED = False

# ==========================
# å†»ç»“åŒºï½œç»“æ„æ‰«æå¼•æ“ï¼ˆé…ç½®é©±åŠ¨ï½œé”æ­»ï¼‰
# ==========================
# ç›®æ ‡ï¼šç»“æ„è¡¨æ ¼å¯ç”±è¦†ç›–åŒºå¡«å†™ï¼›æ‰«æç®—æ³•ä¸å£å¾„å›ºå®šåœ¨å†»ç»“åŒºï¼Œé¿å…å†™æ‰‹æ”¹åã€‚

SW_RULE = {
    "MODE": "RUNLEN",  # æ®µé•¿å£å¾„ï¼šè¿ç»­æ®µé•¿
    "VALID_R": ("B", "P"),  # ä»…BPå‚ä¸ç»“æ„æ®µé•¿
    "IGNORE_T": True,  # T ä¸å‚ä¸ã€ä¸æ‰“æ–­
    "ZERO_DIFF_INVALID": False,  # Node 3: ç§»é™¤ diff ä¾èµ–ï¼Œç‚¹å·®=0 ä¸å†ä½œä¸ºæ— æ•ˆå£åˆ¤å®šä¾æ®ï¼ˆr=T å·²è¦†ç›–ï¼‰

    # æœªå®šä¹‰æœŸ temp_S å£å¾„ï¼ˆé”æ­»ï½œæ–¹æ¡ˆBï¼‰
    "TEMP_INIT": "FIRST_VALID_WINNER",  # é¦–ä¸ªæœ‰æ•ˆå£èµ¢å®¶å³ temp_S
    "HYST_SWITCH": 3,  # è¢«åè¶…é˜ˆå€¼ï¼šå¯¹æ–¹é¢†å…ˆ>=3æ‰åˆ‡æ¢
    "WINNER_SOURCE": "R_COLUMN",  # Node 3: å¼ºåˆ¶ä½¿ç”¨ R_COLUMNï¼Œç‰©ç†å±è”½ diff
}

# Anchorï¼ˆé”šç‚¹ï¼‰å£å¾„ï¼ˆå†»ç»“åŒºçœŸæºï½œé”æ­»ï¼‰
# - FROM_BOOT_START_LOCK_SWï¼ˆé»˜è®¤ï¼‰ï¼šä»é´é¦–å¼€å§‹æ‰«æï¼›S/W ç”±â€œè°å…ˆå‡ºç°è¿ç»­æœ‰æ•ˆå£æ®µé•¿>=3â€é”å®šä¸ºæœ€ç»ˆå¼ºæ–¹
STRUCT_ANCHOR_MODE = "FROM_BOOT_START_LOCK_SW"


def _boot_filter_rule():
    """é´çº§è§„åˆ™ï¼ˆå†»ç»“åŒºçœŸæºï¼‰â€”â€”æŒ‰æœ‰æ•ˆé…ç½®åŠ¨æ€ç”Ÿæ•ˆï¼ˆæ”¯æŒé”šç‚¹002è¦†ç›– N / N=0 å…³é—­ï¼‰ã€‚"""
    boot_on, allow_from, _raw = _get_boot_filter_effective()
    forbidden_lo = 1
    forbidden_hi = max(int(allow_from) - 1, 0)
    return {
        "boot_on": bool(boot_on),
        "min_seen": int(allow_from) if boot_on else 1,  # å…è®¸ä¸‹æ³¨/å†™å…¥å¿«ç…§çš„æœ€å° seen_all
        "forbidden_lo": int(forbidden_lo),
        "forbidden_hi": int(forbidden_hi),  # ç¦åŒºï¼šseen_all=1..(N-1)
        "forbidden_action": "ABORT_BOOT" if BOOT_FILTER_FORBIDDEN_ABORT else "SKIP_STAR",
    }


BOOT_FILTER_RULE = _boot_filter_rule()  # è¿è¡Œæ—¶ä¼šåœ¨ _run_report å¼€å§‹å¤„åˆ·æ–°ä¸€æ¬¡


def _cfg_parse_int(x):
    try:
        if x is None:
            return None
        if isinstance(x, bool):
            return int(x)
        if isinstance(x, (int, float)):
            if isinstance(x, float) and (x != x):  # nan
                return None
            return int(x)
        s = str(x).strip()
        if s == "" or s.lower() == "none" or s.lower() == "nan":
            return None
        return int(float(s))
    except Exception:
        return None


def _cfg_is_valid_struct_row(rec: dict):
    """ç»“æ„è¡Œæœ‰æ•ˆæ€§ï¼šNode 3 r-only é‡æ„ã€‚
    ä»…å½“ r âˆˆ {B, P} æ—¶è§†ä¸ºæœ‰æ•ˆå£ï¼›T åªä½ç§»ä¸è®¡æ®µé•¿ã€‚
    """
    r = rec.get("r")
    if r in ("B", "P"):
        return True
    return False


def _cfg_parse_struct_table(text: str):
    """è§£æè¦†ç›–åŒºç»“æ„è¡¨ï¼ˆSTRUCT-Lang v2ï¼‰ã€‚
    å…è®¸ï¼šN è¡Œï¼ˆN>=1ï¼‰ï¼Œå­—æ®µï¼šstep | side | min_len | max_len | mark
    sideï¼šS/Wï¼ˆå¼ºå¼±æ–¹ï¼‰æˆ– B/Pï¼ˆç»å¯¹æ–¹ï¼‰
    v2 é”æ­»æ ¡éªŒï¼š
      - step å¿…é¡»è¿ç»­é€’å¢ï¼ˆ1..Nï¼‰
      - min/max ä¸ºæ­£æ•´æ•°ä¸” min<=max
      - â­ å¿…é¡»å”¯ä¸€ä¸”å‡ºç°åœ¨æœ€åä¸€è¡Œ
    """
    if text is None:
        raise RuntimeError("STRUCT_CONFIG_INVALID: empty")
    raw_lines = []
    for raw in str(text).splitlines():
        s = raw.strip()
        if not s:
            continue
        if s.startswith("#"):
            continue
        raw_lines.append(s)
    if not raw_lines:
        raise RuntimeError("STRUCT_CONFIG_INVALID: empty")

    # è·³è¿‡è¡¨å¤´è¡Œï¼ˆåŒ…å« step/side/min_len/max_lenï¼‰
    if ("step" in raw_lines[0].lower()) and ("side" in raw_lines[0].lower()):
        raw_lines = raw_lines[1:]
    if not raw_lines:
        raise RuntimeError("STRUCT_CONFIG_INVALID: empty")

    rows = []
    for s in raw_lines:
        parts = [p for p in re.split(r"\s+|\t+", s.strip()) if p != ""]
        if len(parts) < 4:
            continue
        step = _cfg_parse_int(parts[0])
        side = str(parts[1]).strip().upper()
        min_len = _cfg_parse_int(parts[2])
        max_len = _cfg_parse_int(parts[3])
        mark = str(parts[4]).strip() if len(parts) >= 5 else ""
        if step is None or min_len is None or max_len is None:
            continue
        rows.append({
            "step": int(step),
            "side": side,
            "min_len": int(min_len),
            "max_len": int(max_len),
            "mark": mark,
        })

    rows.sort(key=lambda x: x["step"])
    if len(rows) < 1:
        raise RuntimeError("STRUCT_CONFIG_INVALID: need>=1")

    # step è¿ç»­é€’å¢ï¼ˆ1..Nï¼‰
    for i, r in enumerate(rows, 1):
        if r["step"] != i:
            raise RuntimeError("STRUCT_CONFIG_INVALID: step_not_continuous")

    # å­—æ®µæ ¡éªŒ
    for r in rows:
        if r["side"] not in ("S", "W", "X", "Y", "B", "P"):
            raise RuntimeError("STRUCT_CONFIG_INVALID: bad_side")
        if r["min_len"] <= 0 or r["max_len"] <= 0:
            raise RuntimeError("STRUCT_CONFIG_INVALID: minmax_must_be_positive")
        if r["min_len"] > r["max_len"]:
            raise RuntimeError("STRUCT_CONFIG_INVALID: min_gt_max")

    # â­ å”¯ä¸€ä¸”åœ¨æœ€åä¸€è¡Œï¼ˆv2 é”æ­»ï¼‰
    star_steps = [r["step"] for r in rows if ("â­" in (r.get("mark") or ""))]
    if len(star_steps) != 1:
        raise RuntimeError("STRUCT_CONFIG_INVALID: star_must_be_unique")
    if star_steps[0] != rows[-1]["step"]:
        raise RuntimeError("STRUCT_CONFIG_INVALID: star_must_be_last")

    return rows


def _cfg_norm_struct_text(text: str) -> str:
    """ç»“æ„è¡¨è§„èŒƒåŒ–æ–‡æœ¬ï¼ˆç”¨äº HASHï¼‰ã€‚"""
    if text is None:
        return ""
    lines = []
    for raw in str(text).splitlines():
        s = raw.strip()
        if not s:
            continue
        if s.startswith("#"):
            continue
        lines.append(s)
    if lines and ("step" in lines[0].lower()) and ("side" in lines[0].lower()):
        lines = lines[1:]
    return "\n".join(lines).strip()


def _cfg_struct_expr(rows) -> str:
    """ç»“æ„è¡¨è¾¾ï¼ˆç”¨äºæ‰“å°ï¼‰ï¼šä¾‹ Sâ‰¥3 â†’ W1-2 â†’ Sâ­"""
    parts = []
    for i, r in enumerate(rows, 1):
        side = r["side"]
        mn = int(r["min_len"])
        mx = int(r["max_len"])
        is_last = (i == len(rows))
        seg = ""
        if (not is_last) or (not (mn == 1 and mx >= 999)):
            if mx >= 999:
                seg = f"â‰¥{mn}"
            elif mn == mx:
                seg = f"{mn}"
            else:
                seg = f"{mn}-{mx}"
        mark = "â­" if is_last else ""
        parts.append(f"{side}{seg}{mark}")
    return " â†’ ".join(parts)


def _cfg_struct_hash(text: str, anchor_mode: str) -> str:
    """ç»“æ„ HASHï¼ˆå« Anchorï¼‰ã€‚"""
    norm = _cfg_norm_struct_text(text)
    payload = (str(anchor_mode or "") + "\n" + norm).encode("utf-8")
    return hashlib.md5(payload).hexdigest()[:8]


def _cfg_config_uses_sw(rows) -> bool:
    return any((r.get("side") in ("S", "W")) for r in (rows or []))


def _cfg_anchor_define_after_s_defined(records):
    """å®šä¹‰ Anchorï¼šS_DEFINED_IDX ä¸ strong_absï¼ˆB/Pï¼‰ã€‚
    å£å¾„é”æ­»ï¼ˆé´é¦–æ‰«æç‰ˆï¼‰ï¼š
      - strong_absï¼šè°å…ˆå‡ºç°â€œè¿ç»­æœ‰æ•ˆå£æ®µé•¿ï¼ˆRUNLENï¼‰>=3â€ï¼Œè°å°±æ˜¯ Sï¼ˆå¼ºï¼‰
      - S_DEFINED_IDXï¼šè¯¥ RUNLEN è¾¾åˆ°ç¬¬3å£æ‰€åœ¨çš„ records è¡Œå·ï¼ˆ0-based idxï¼‰
      - åªè®¡æœ‰æ•ˆå£ï¼šrâˆˆ{B,P}ï¼›T åªä½ç§»
    """
    run_side = None
    run_len = 0
    for i, rec in enumerate(records or []):
        if not _cfg_is_valid_struct_row(rec):
            continue
        r = (rec.get("r") or "").strip()
        if r == run_side:
            run_len += 1
        else:
            run_side = r
            run_len = 1
        if run_len >= 3:
            return i, run_side
    return None, None


def scan_by_config_v2(records, rows, anchor_mode, sw_rule):
    """å†»ç»“åŒºï¼šé…ç½®é©±åŠ¨ç»“æ„æ‰«æå™¨ v2ï¼ˆå¤šæ®µï½œé´é¦–æ‰«æç‰ˆï½œRUNLENï¼‰ã€‚

    è¿”å›ï¼š("STRUCT_OK"|"STRUCT_FAIL", entry_star_idx_or_None, strong_abs_or_None, info)

    å£å¾„é”æ­»ï¼š
    - æ‰«æä» records ç¬¬ä¸€è¡Œå¼€å§‹ï¼ˆä¸åš Anchor æˆªæ–­ï¼‰
    - strong_absï¼šè°å…ˆå‡ºç°â€œè¿ç»­æœ‰æ•ˆå£æ®µé•¿ï¼ˆRUNLENï¼‰>=3â€ï¼Œè°å°±æ˜¯ Sï¼ˆå¼ºï¼‰ï¼›ä¹‹åä¸å†åˆ‡æ¢
    - æœªå®šä¹‰æœŸï¼štemp_S/temp_W=å½“å‰ç´¯è®¡é¢†å…ˆæ–¹ï¼ˆæœ‰æ•ˆå£ç´¯è®¡ cntB/cntPï¼›å¹³æ‰‹ KEEP_LASTï¼›é¦–ä¸ªæœ‰æ•ˆå£å…œåº•ï¼‰
      ä¸” temp_S ä¸€æ—¦åˆ‡æ¢ï¼šB1 é‡ç½®åˆ° step1ï¼ˆé˜²æ®µå†…æ¢è¾¹æ¼‚ç§»ï¼‰
    - æ®µé•¿ç´¯è®¡ï¼šç»“æ„æ®µé•¿æŒ‰ RUNLENï¼ˆè¿ç»­åŒä¾§æœ‰æ•ˆå£ï¼‰ï¼›T åªä½ç§»ä¸è®¡æ®µé•¿ã€ä¸æ‰“æ–­
    - BOOT_FILTER ç¦åŒºï¼šæŒ‰ä½ç§»å£ seen_shift=1..8ï¼ˆå«T/0ï¼‰ï¼Œä»…å½±å“ ENTRYâ™»â­ï¼›RAWâ™»â­ä¸å—å½±å“
    - æ®µè¾¹ç•Œï¼šä»¥â€œä¾§å˜/mismatchâ€ä½œä¸ºè‡ªç„¶è¾¹ç•Œï¼›è¾¾åˆ° min_len ä¸ä¼šåœ¨åŒä¸€å£å¼ºè¡Œè·¨æ®µ
    """
    info = {
        "fail_reason": None,

        # RAW / ENTRYï¼ˆåŒâ™»â­ï¼‰
        "raw_star_idx": None,
        "entry_star_idx": None,

        # ç¦åŒºä½œåºŸï¼ˆå¿…é¡»å‡ºç°ï¼‰
        "skipped_forbidden_star_cnt": 0,  # ç¦åŒºå‘½ä¸­çš„â­è¢«ä½œåºŸæ¬¡æ•°
        "forbidden_star_cnt": 0,  # ç¦åŒºå‘½ä¸­æ€»æ¬¡æ•°ï¼ˆå«ABORT/å…¶å®ƒï¼‰
        "forbidden_star_first_seen": None,  # é¦–æ¬¡ç¦åŒºå‘½ä¸­çš„ RAWâ™»â­ idx

        # çŠ¶æ€é‡ç½®è®¡æ•°ï¼ˆå¿…é¡»å‡ºç°ï¼‰
        "reset_to_step1_cnt": 0,  # æ‰€æœ‰å›åˆ° step1 çš„æ¬¡æ•°ï¼ˆå«ç¦åŒº/ä¾§å˜/æº¢å‡ºç­‰ï¼‰
        "reset_forbidden_cnt": 0,  # ç¦åŒºä½œåºŸå¯¼è‡´çš„é‡ç½®æ¬¡æ•°ï¼ˆåº”ä¸ skipped_forbidden_star_cnt ä¸€è‡´ï¼‰
        "reset_side_switch_cnt": 0,  # temp_S å‘ç”Ÿåˆ‡æ¢å¯¼è‡´çš„é‡ç½®æ¬¡æ•°

        # temp_S è‡ªè¯
        "temp_init_idx": None,  # temp_S é¦–æ¬¡å»ºç«‹çš„ idxï¼ˆé¦–ä¸ªæœ‰æ•ˆå£ï¼‰
        "temp_switch_cnt": 0,  # temp_S åˆ‡æ¢æ¬¡æ•°ï¼ˆè¢«åè¶…>=é˜ˆå€¼ï¼‰

        # å®¡è®¡å­—æ®µ
        "anchor_mode": anchor_mode,
        "struct_hash": _cfg_struct_hash(STRUCT_CONFIG_TEXT, anchor_mode),
        "struct_expr": _cfg_struct_expr(rows),
        "s_defined_idx": None,
    }

    step_i = 0  # 0-based
    seg_len = 0

    # strong_abs / weak_absï¼šæœ€ç»ˆ S/Wï¼ˆç»å¯¹æ–¹ï¼‰
    strong_abs = None
    weak_abs = None

    # æœªå®šä¹‰æœŸ tempï¼ˆé¢†å…ˆæ–¹ï¼‰
    cntB = 0
    cntP = 0
    keep_last_leader = None  # temp_Sï¼ˆç»å¯¹æ–¹ B/Pï¼‰

    # ç”¨äºé”å®š strong_abs çš„ RUNLENï¼ˆç»å¯¹æ–¹ï¼‰
    run_side = None
    run_len = 0

# Node3ï¼šX/Y ç»å¯¹é”ï¼ˆD1ï½œèµ·ç‚¹Aï½œTè·³è¿‡ä¸è®¡æ•°ä¸æ‰“æ–­ï¼‰
    X_LOCKED_ABS = None  # "B" or "P"
    X_col_cnt_B = 0
    X_col_cnt_P = 0
    X_seen_eff = 0  # N_effï¼šä»…ç´¯è®¡(B/P)ï¼ŒTä¸è®¡æ•°ä¸æ‰“æ–­

    rule = BOOT_FILTER_RULE

    def _as_int_flag(v, default=0):
        try:
            if v is None:
                return int(default)
            s = str(v).strip()
            if s == "":
                return int(default)
            # å…¼å®¹ "0" / "1" / 0 / 1 / "0.0"
            return int(float(s))
        except Exception:
            return int(default)

    # boot_onï¼šå…è®¸å£³æŠŠ 0/1 å†™æˆå­—ç¬¦ä¸²ä¹Ÿä¸è¯¯åˆ¤
    boot_on = bool(rule.get("boot_on", bool(_as_int_flag(globals().get("BOOT_FILTER", 0), 0))))

    forbidden_lo, forbidden_hi = rule["forbidden_lo"], rule["forbidden_hi"]

    # forbidden_actionï¼šè‹¥ rule æœªæ˜¾å¼ç»™ï¼Œåˆ™ç”± BOOT_FILTER_FORBIDDEN_ABORT(0/1) å†³å®š
    _fa = rule.get("forbidden_action", None)
    if _fa is None:
        _abort = _as_int_flag(globals().get("BOOT_FILTER_FORBIDDEN_ABORT", 0), 0)
        forbidden_action = "ABORT_BOOT" if _abort == 1 else "SKIP_STAR"
    else:
        forbidden_action = str(_fa).strip().upper()

    # Node15ï½œç»“æ„å¼€å…³æ‰«â€œç»å¯¹Xâ€ï¼šæ•´é´ç¬¬ä¸€æ¬¡å‡ºç°è¿ç»­ >=3 çš„é‚£ä¸€æ–¹ï¼Œé”æ­»ä¸º X
    # - IGNORE_Tï¼šT ä¸å‚ä¸ã€ä¸æ‰“æ–­ï¼ˆå’Œä½ çš„å£å¾„ä¸€è‡´ï¼‰
    # - è‹¥æ•´é´ä»æœªå‡ºç°ä»»ä½•ä¸€æ–¹è¿ç»­ >=3ï¼šè¯¥é´ç›´æ¥æ— æ•ˆï¼ˆä¸è½ğŸ¯ï¼‰
    def _prelock_abs_x_first_ge3():
        # RUNLENï¼šé‡åˆ°å¯¹æ‰‹å½’é›¶ï¼›T ä¸è®¡æ•°ã€ä¸æ‰“æ–­ï¼›è°å…ˆ RUNLEN>=3 è°é”å®š
        lenB = 0
        lenP = 0
        seen_eff = 0  # ä»…ç»Ÿè®¡éTæœ‰æ•ˆå£ï¼ˆB/Pï¼‰
        seq = []  # ä»èµ·ç‚¹åˆ°è§¦å‘ç‚¹ï¼ˆå«Tï¼‰ï¼Œç”¨äºå¯å¤æ ¸è¯æ®

        for _i, _rec in enumerate(records):
            _r = _rec.get("r")

            if _r == "T":
                seq.append("T")
                continue
            if _r not in ("B", "P"):
                continue

            # B/P
            seq.append(_r)
            seen_eff += 1

            # reachNï¼šä¼˜å…ˆ seen_allï¼›å¦åˆ™é€€å› _i+1ï¼ˆå«Tçš„ä½ç§»å£ï¼‰
            try:
                _sa = _rec.get("seen_all")
                _reachN = int(_sa) if _sa not in (None, "") else (_i + 1)
            except Exception:
                _reachN = _i + 1

            if _r == "B":
                lenB += 1
                lenP = 0
            else:
                lenP += 1
                lenB = 0

            if lenB >= 3 or lenP >= 3:
                side = "B" if lenB >= 3 else "P"
                # è¯æ®ï¼šä¿ç•™å°¾æ®µï¼Œé¿å…è¶…é•¿
                if len(seq) > 200:
                    r_seq = "..." + "".join(seq[-200:])
                else:
                    r_seq = "".join(seq)
                basis = f"RUNLEN>=3|lenB={lenB}|lenP={lenP}|r={_r}"
                return True, side, int(_reachN), int(_i), int(seen_eff), int(lenB), int(lenP), r_seq, basis

        # æœªè§¦å‘ä¹Ÿè¦å›ä¼ å¯å¤æ ¸çš„æœ«æ€
        if len(seq) > 200:
            r_seq = "..." + "".join(seq[-200:])
        else:
            r_seq = "".join(seq)
        return False, None, None, None, int(seen_eff), int(lenB), int(lenP), r_seq, "NO_RUNLEN_GE3"

    # è®¡ç®— ABSXï¼ˆç‰©ç†é”æ­»ï¼šåŒé´åªå…è®¸é”å®šä¸€æ¬¡ï¼‰
    _ok, _side, _reachN, _idx0, _seen_eff, _lenB, _lenP, _r_seq, _basis = _prelock_abs_x_first_ge3()
    if _ok:
        if X_LOCKED_ABS is None:
            X_LOCKED_ABS = _side
        elif X_LOCKED_ABS != _side:
            # ç‰©ç†é”æ­»ï¼šå‡ºç°äºŒæ¬¡é”å®šä¸”ä¸ä¸€è‡´ï¼Œç›´æ¥ç¡¬åœæœº
            print(
                "èŠ‚ç‚¹=PROOF_LOCK|OK=0|reason=ABSX_RELOCK_MISMATCH"
                f"|evidence=prev={X_LOCKED_ABS}|new={_side}|reachN={_reachN}|idx={_idx0}"
            )
            raise GuardViolation(
                code="ABSX_RELOCK_MISMATCH",
                rule_id=15,
                phase="ABSX",
                msg="ABSX lock mismatch",
                evidence=f"prev={X_LOCKED_ABS}|new={_side}|reachN={_reachN}|idx={_idx0}",
                exit_code=2,
            )

        info["abs_x_lock_side"] = _side
        info["abs_x_lock_N"] = _reachN
        info["abs_x_lock_idx"] = _idx0
        info["abs_x_lock_seen_eff"] = _seen_eff
        info["abs_x_lenB"] = _lenB
        info["abs_x_lenP"] = _lenP
        info["abs_x_r_seq"] = _r_seq
        info["abs_x_basis"] = _basis
        info["abs_x_mode"] = "RUNLEN_IGNORE_T"
    else:
        info["abs_x_lock_side"] = None
        info["abs_x_lock_N"] = None
        info["abs_x_lock_idx"] = None
        info["abs_x_lock_seen_eff"] = _seen_eff
        info["abs_x_lenB"] = _lenB
        info["abs_x_lenP"] = _lenP
        info["abs_x_r_seq"] = _r_seq
        info["abs_x_basis"] = _basis
        info["abs_x_mode"] = "RUNLEN_IGNORE_T"

    def _opp(bp):

        return "P" if bp == "B" else ("B" if bp == "P" else None)

    def _expected_abs(side: str):
        # ç»å¯¹æ–¹
        if side in ("B", "P"):
            return side

        # X/Yï¼šå¿…é¡»ç­‰ D1 é”å®šåæ‰å…è®¸åŒ¹é…ï¼ˆX=é”å®šæ–¹ï¼ŒY=å¯¹ä¾§ï¼‰
        if side in ("X", "Y"):
            if X_LOCKED_ABS is None:
                return None
            return X_LOCKED_ABS if side == "X" else _opp(X_LOCKED_ABS)

        # S/Wï¼šä¸€å¾‹å¹¶å…¥ X_LOCKED_ABSï¼ˆä¸å†ä½¿ç”¨ strong_abs / keep_last_leaderï¼‰
        if side in ("S", "W"):
            if X_LOCKED_ABS is None:
                return None
            return X_LOCKED_ABS if side == "S" else _opp(X_LOCKED_ABS)

        return None

    def _reset(reason: str = None):

        nonlocal step_i, seg_len
        step_i = 0
        seg_len = 0
        # è®¡æ•°ï¼šç”¨äºéªŒæ”¶â€œç¦åŒºå‘½ä¸­å¿…é¡»é‡ç½®â€
        info["reset_to_step1_cnt"] += 1
        if reason == "FORBIDDEN":
            info["reset_forbidden_cnt"] += 1
        elif reason == "SIDE_SWITCH":
            info["reset_side_switch_cnt"] += 1

    def _maybe_commit_star(cand_star_idx, seen_shift):

        nonlocal strong_abs, weak_abs

        # Node12ï½œğŸ¯å€™é€‰é”æ­»ï¼ˆæœ€æ—©å‘½ä¸­å¼ºåˆ¶ï¼‰ï¼šåªå…è®¸â€œç¬¬ä¸€æ¬¡å¯æäº¤çš„å€™é€‰idxâ€
        # - åªæœ‰åœ¨é€šè¿‡ç¦åŒºæ£€æŸ¥åæ‰ä¼šçœŸæ­£é”æ­»ï¼›ç¦åŒºå‘½ä¸­ä¼š reset å¹¶ return Noneï¼ˆStep1 å·²åšï¼‰
        _first = info.get("node12_first_star_idx", None)
        _firstN = info.get("node12_first_star_seen", None)
        if _first is None:
            # å…ˆä¸ç«‹åˆ»é”æ­»åˆ° infoï¼ˆè¦ç­‰é€šè¿‡ç¦åŒºï¼‰
            pass
        else:
            if int(_first) != int(cand_star_idx) or int(_firstN) != int(seen_shift):
                raise RuntimeError(
                    f"STAR_CANDIDATE_DRIFT_ABORT | first_idx={_first} first_N={_firstN} | new_idx={cand_star_idx} new_N={seen_shift}"
                )

        # ç¦åŒºï¼ˆboot_filterï¼‰å†…ä¸å…è®¸ commit â­ï¼ˆåªè®¡ forbidden è®¡æ•°ï¼›ç»§ç»­æ‰«æåç»­å£ï¼‰
        if forbidden_lo is not None and forbidden_hi is not None:
            if forbidden_lo <= seen_shift <= forbidden_hi:
                info["forbidden_star_cnt"] += 1
                if "forbidden_star_first_seen" not in info:
                    info["forbidden_star_first_seen"] = seen_shift
                if "forbidden_star_first_idx" not in info:
                    info["forbidden_star_first_idx"] = cand_star_idx

                # å£å¾„ï¼šé»˜è®¤ SKIP_STARï¼ˆä¸ä¸­æ–­ï¼‰ï¼›è‹¥æœªæ¥å¼ºåˆ¶ ABORT_BOOTï¼Œåˆ™æ‰ä¸­æ–­
                if str(forbidden_action).strip().upper() == "ABORT_BOOT":
                    raise RuntimeError(f"STAR_IN_FORBIDDEN_ABORT | idx={cand_star_idx} | N={seen_shift} | forbidden={forbidden_lo}..{forbidden_hi}")

                # Node14ï¼šç¦åŒºå‘½ä¸­å¿…é¡»å›åˆ° step1ï¼Œä¸”æœ¬æ¬¡å€™é€‰ç›´æ¥ä½œåºŸï¼ˆç¦æ­¢ç»§ç»­æäº¤ï¼‰
                _reset("FORBIDDEN")
                return None

        # Node14ï¼šåªæœ‰â€œé€šè¿‡ç¦åŒºæ£€æŸ¥â€çš„å€™é€‰ï¼Œæ‰å…è®¸é”æ­»ä¸ºâ€œæœ€æ—©å‘½ä¸­â€
        if info.get("node12_first_star_idx", None) is None:
            info["node12_first_star_idx"] = int(cand_star_idx)
            info["node12_first_star_seen"] = int(seen_shift)

        # ä¸¥ç¦ï¼šcand æŒ‡å‘ Tï¼ˆå¿…é¡»æ˜¯ B/Pï¼‰
        _r_star = (records[cand_star_idx].get("r") if (records and 0 <= cand_star_idx < len(records)) else None)
        if _r_star not in ("B", "P"):
            raise RuntimeError(f"STAR_SNAPSHOT_ON_T (SCAN_STAGE) | r={_r_star} | idx={cand_star_idx} | N={seen_shift}")

        # ENTRYï¼šå†…éƒ¨ idx ç»™å¿«ç…§/ç»“ç®—ç”¨ï¼›å¯¹å¤– N å•ç‹¬å­˜
        info["entry_star_idx"] = cand_star_idx  # 0-basedï¼ˆç»™å¿«ç…§/recordså–è¡Œï¼‰
        info["entry_star_seen"] = seen_shift  # 1-basedï¼ˆç»™ğŸ¯æ‰“å°/äººçœ¼å®šä½ï¼‰

        strong_out = X_LOCKED_ABS if X_LOCKED_ABS is not None else strong_abs
        return "STRUCT_OK", cand_star_idx, strong_out, info

    # Node6ï½œé¢„é”ç¼“å†²å›æ”¾ï¼šè§£å†³ X_LOCKED_ABS æœªç¡®å®šå¯¼è‡´ç»“æ„ä»é”å®šç‚¹åç½®å¼€å§‹æ‰«ï¼ˆä¸å¼•å…¥æœªæ¥æ•°ï¼‰
    prelock_buf = []  # [(idx, seen_shift, r_abs)] ä»…ç¼“å­˜æœ‰æ•ˆå£ï¼ˆå«Tï¼‰ï¼Œç”¨äºé”å®šåä»é´é¦–å›æ”¾ä¸€æ¬¡

    def _reset_match_state(reason: str = None):
        nonlocal cntB, cntP, keep_last_leader
        cntB = 0
        cntP = 0
        keep_last_leader = None
        _reset(reason)

    def _process_valid_r(idx, seen_shift, r_abs):
        """å¤„ç†å•ä¸ªæœ‰æ•ˆå£ï¼ˆr_abs å·²å½’ä¸€ä¸º B/P/Tï¼‰ï¼Œè¿”å› STRUCT_OK å…ƒç»„æˆ– Noneã€‚T ç›´æ¥è·³è¿‡ã€‚"""
        nonlocal cntB, cntP, keep_last_leader, strong_abs, weak_abs, step_i, seg_len

        # T æ°¸è¿œè·³è¿‡ï¼šä¸è®¡æ®µé•¿ã€ä¸æ‰“æ–­ã€ä¸å‚ä¸ leader/ç»“æ„åŒ¹é…
        if r_abs == "T":
            return None

        # 2) æœªå®šä¹‰æœŸ temp_Sï¼ˆé”æ­»ï½œæ–¹æ¡ˆB + è¿Ÿæ»é˜ˆå€¼ï¼‰
        # åªè®¡æœ‰æ•ˆå£ç´¯è®¡ï¼šd=cntB-cntP
        if r_abs == "B":
            cntB += 1
        elif r_abs == "P":
            cntP += 1

        d_bp = cntB - cntP

        # æ–¹æ¡ˆBï¼šé¦–ä¸ªæœ‰æ•ˆå£èµ¢å®¶å³å»ºç«‹ temp_Sï¼ˆä¸ç­‰å¾…é˜ˆå€¼ï¼‰
        if keep_last_leader is None:
            keep_last_leader = r_abs
            info["temp_init_idx"] = idx
        else:
            leader = keep_last_leader

            # è¿Ÿæ»åˆ‡æ¢ï¼šåªæœ‰è¢«åè¶…åˆ°å¯¹æ–¹é¢†å…ˆ>=HYST_SWITCH æ‰å…è®¸åˆ‡æ¢
            thr = int(SW_RULE.get("HYST_SWITCH", 3))
            if keep_last_leader == "B" and d_bp <= -thr:
                leader = "P"
            elif keep_last_leader == "P" and d_bp >= thr:
                leader = "B"

            if leader != keep_last_leader:
                info["temp_switch_cnt"] += 1
                # æœªé”å®šæœŸä¾§å˜ï¼šå¿…é¡»å›åˆ° step1ï¼ˆé˜²æ®µå†…æ¢è¾¹æ¼‚ç§»ï¼‰
                if strong_abs is None:
                    _reset("SIDE_SWITCH")
                keep_last_leader = leader

        # ä¸€ä¸ªæœ‰æ•ˆå£å¯èƒ½è§¦å‘â€œæ®µç»“æŸ/è·¨æ®µ/é‡ç½®â€ï¼Œå› æ­¤ç”¨ while å…è®¸åŒä¸€å£è¢«å¤šæ¬¡å½’å±ï¼ˆä»…åœ¨ mismatch æ—¶ï¼‰
        while True:
            cur = rows[step_i]
            exp = _expected_abs(cur["side"])
            if exp is None:
                _reset()
                break

            if r_abs == exp:
                seg_len += 1

                # è¶…ä¸Šé™ï¼šé‡ç½®å¹¶å°è¯•ä»¥å½“å‰å£ä½œä¸ºæ–°èµ·ç‚¹
                if seg_len > int(cur["max_len"]):
                    _reset()
                    # å…è®¸å½“å‰å£ä½œä¸ºæ–°èµ·ç‚¹ï¼ˆç»§ç»­ whileï¼‰
                    continue

                # â­ï¼šæœ€åä¸€æ®µè¾¾åˆ° min_lenï¼ˆå…è®¸â€œæœ€æ—©æ»¡è¶³å³â­â€ï¼‰
                if step_i == (len(rows) - 1) and seg_len >= int(cur["min_len"]):
                    # Node9ï½œğŸ¯ç»å¯¹å®šä½å¤æ ¸ï¼ˆé”æ­»ï¼‰
                    # Node10ï½œå¤æ ¸å¼€å…³ï¼šé”æ­»ä¸º ONï¼ˆç¦æ­¢å…³é—­ï¼‰
                    _STRUCT_PROOF_ON = 1
                    if not _STRUCT_PROOF_ON:
                        raise RuntimeError("STRUCT_PROOF_SWITCH_OFF_FORBIDDEN")

                    # 1) â­ç›®æ ‡æ®µå”¯ä¸€æ¥æºï¼šcurï¼ˆæœ€åä¸€æ®µé‚£æ¡ç»“æ„è¡Œï¼‰
                    res = _maybe_commit_star(idx, seen_shift)
                    if res is not None:
                        return res
                    # SKIP_STARï¼šç»§ç»­ä¸‹ä¸€å£
                    break

                # åœ¨ RUNLEN å£å¾„ä¸‹ï¼šè¾¾åˆ° min_len ä¸ä¼šåœ¨åŒä¸€å£å¼ºè¡Œè·¨æ®µï¼ˆé¿å…â€œåŒä¸€å£è¢«ä¸¤æ®µåŒæ—¶æ¶ˆè´¹â€ï¼‰
                break

            # mismatchï¼ˆä¾§å˜/ä¸åŒ¹é…ï¼‰ï¼šå½“å‰å£ä¸å±äºæœ¬æ®µï¼Œå°è¯•ç»“æŸæœ¬æ®µå¹¶æŠŠå½“å‰å£å½’å±åˆ°ä¸‹ä¸€æ®µ/æ–°èµ·ç‚¹
            if seg_len == 0:
                # å°šæœªè¿›å…¥æ®µï¼šå…è®¸å›åˆ° step1 é‡æ–°è§£é‡Š
                if step_i != 0:
                    _reset()
                    continue
                # step1 éƒ½ä¸åŒ¹é…ï¼šæœ¬å£æ— æ³•ä½œä¸ºèµ·ç‚¹
                break

            # æ®µå·²å¼€å§‹ï¼šæ£€æŸ¥æœ¬æ®µæ˜¯å¦æ»¡è¶³æœ€çŸ­
            if seg_len < int(cur["min_len"]):
                # æ®µå¤ªçŸ­ï¼šé‡ç½®ï¼Œå¹¶å°è¯•å½“å‰å£ä½œä¸ºæ–°çš„èµ·ç‚¹
                _reset()
                continue

            # æ®µæ»¡è¶³ï¼šè¿›å…¥ä¸‹ä¸€æ®µï¼Œå¹¶ç”¨åŒä¸€å£é‡è¯•ï¼ˆè¯¥å£å±äºä¸‹ä¸€æ®µçš„é¦–å£ï¼‰
            step_i += 1
            if step_i >= len(rows):
                _reset()
                break
            seg_len = 0
            continue

        return None

    for i, rec in enumerate(records or []):
        idx = i  # records è¡Œå·ï¼ˆ0-basedï¼‰
        # ä½ç§»å£ï¼ˆå«T/0ï¼‰ï¼šä¼˜å…ˆç”¨è¡Œå†… seen_allï¼›å¦åˆ™é€€å› i+1
        try:
            _sa = rec.get("seen_all")
            seen_shift = int(_sa) if _sa not in (None, "") else (i + 1)
        except Exception:
            seen_shift = i + 1

        # r-only, no diff reading
        r_abs = rec.get("r")
        if r_abs not in ("B", "P"):
            r_abs = "T"

        # é¢„é”æœŸç¼“å­˜ï¼ˆå«å½“å‰å£ï¼‰
        if X_LOCKED_ABS is None:
            prelock_buf.append((idx, seen_shift, r_abs))

        # 1) ABSXï¼šåˆ—é•¿ç´¯è®¡é¦–æ¬¡>=3ï¼ˆä¸è¦æ±‚è¿ç»­ï¼›BBB/PPPä¸­é—´å…è®¸ä»»æ„Tï¼›Tè·³è¿‡ä¸è®¡æ•°ä¸æ‰“æ–­ï¼‰
        just_locked = False
        if r_abs in ("B", "P") and X_LOCKED_ABS is None:
            X_seen_eff += 1  # ä»…(B/P)é€’å¢ï¼ŒTä¸è®¡

            if r_abs == "B":
                X_col_cnt_B += 1
            else:
                X_col_cnt_P += 1

            # åˆ—é•¿ç´¯è®¡é¦–æ¬¡>=3ï¼šè°å…ˆè¾¾åˆ°é˜ˆå€¼(=3)å°±é”è°
            if (X_col_cnt_B >= 3) or (X_col_cnt_P >= 3):
                # ç†è®ºä¸Šä¸ä¼šâ€œåŒè¾¾æ ‡â€ï¼›è‹¥å‡ºç°ï¼Œå…œåº•å–å½“å‰å£æ–¹å‘
                if (X_col_cnt_B >= 3) and (X_col_cnt_P >= 3):
                    X_LOCKED_ABS = r_abs
                elif X_col_cnt_B >= 3:
                    X_LOCKED_ABS = "B"
                else:
                    X_LOCKED_ABS = "P"

                # å¼ºåˆ¶ä¸€æ¬¡æ€§ç¡®å®š strong/weakï¼Œå¹¶ä¸”ä¹‹åä¸å†æ”¹åŠ¨
                strong_abs = X_LOCKED_ABS
                weak_abs = _opp(strong_abs)

                # å…¼å®¹åŸæœ‰é“¾è·¯å­—æ®µ
                info["s_defined_idx"] = idx

                # ABSX è‡ªè¯å­—æ®µï¼ˆğŸ“ŒæŠ½æ ·/æ˜ç»†å¯ç”¨ï¼‰
                info["abs_x_lock_side"] = X_LOCKED_ABS
                info["abs_x_lock_idx"] = idx
                info["abs_x_lock_N_all"] = seen_shift   # æ¥è‡ª rec.get("seen_all") æˆ– i+1ï¼ˆåŒ…å«Tçš„åŸå§‹å£åºï¼‰
                info["abs_x_lock_N_eff"] = X_seen_eff   # å»Tæœ‰æ•ˆå£åºï¼ˆä»…B/Pç´¯è®¡ï¼‰
                info["abs_x_lock_cntB"] = X_col_cnt_B
                info["abs_x_lock_cntP"] = X_col_cnt_P

                # å…¼å®¹æ—§æ‰“å°å­—æ®µï¼ˆreachN / seen_effï¼‰
                info["abs_x_lock_N"] = info["abs_x_lock_N_all"]
                info["abs_x_lock_seen_eff"] = info["abs_x_lock_N_eff"]
                just_locked = True

        # ä»æœªé”å®šï¼šç»§ç»­ç­‰ï¼ˆé”å®šåä¼šå›æ”¾ï¼‰
        if X_LOCKED_ABS is None:
            continue
        if just_locked and prelock_buf:
            _reset_match_state("LOCKED_REPLAY")
            for _idx, _seen_shift, _r_abs in prelock_buf:
                res = _process_valid_r(_idx, _seen_shift, _r_abs)
                if res is not None:
                    return res
            prelock_buf.clear()
            continue  # å½“å‰å£å·²åœ¨å›æ”¾ä¸­å¤„ç†ï¼Œé¿å…é‡å¤æ¶ˆè´¹

        # å·²é”å®šï¼šæ­£å¸¸åŒ¹é…
        res = _process_valid_r(idx, seen_shift, r_abs)
        if res is not None:
            return res

    if info["forbidden_star_cnt"] > 0:
        info["fail_reason"] = "ONLY_FORBIDDEN"
    else:
        info["fail_reason"] = "NO_CANDIDATE"
    return "STRUCT_FAIL", None, strong_abs, info


def _get_struct_summary_line_and_hash():
    """ç»™æŠ¥å‘Šç”¨ï¼šç»“æ„æ‘˜è¦è¡Œ + HASHï¼ˆå« Anchorï¼‰ã€‚"""
    try:
        rows = _cfg_parse_struct_table(STRUCT_CONFIG_TEXT)
        expr = _cfg_struct_expr(rows)
        h = _cfg_struct_hash(STRUCT_CONFIG_TEXT, STRUCT_ANCHOR_MODE)
        return f"ç»“æ„æ‘˜è¦ï¼š{expr} | HASH={h}", h
    except Exception:
        return "ç»“æ„æ‘˜è¦ï¼š<PARSE_FAIL>", "NA"


def _frozen_scan_structure(records, struct_config_text):
    """å†»ç»“åŒºç»“æ„æ‰«æï¼ˆé…ç½®é©±åŠ¨ v2ï¼šå¤šæ®µ + Anchorï¼‰
    è¿”å›ï¼š("STRUCT_OK"|"STRUCT_FAIL", star_idx_or_None, strong_side_or_None, info)
    - star_idxï¼šENTRYâ™»â­ï¼ˆé´çº§é—¨ç¦åå¯å…¥åœºçš„â­ï¼›å…¼å®¹æ—§å­—æ®µï¼‰
    - info åŒæ—¶åŒ…å« RAWâ™»â­ ä¸ HASH ç­‰å®¡è®¡å­—æ®µ
    """
    anchor_mode = STRUCT_ANCHOR_MODE

    try:
        rows = _cfg_parse_struct_table(struct_config_text)
    except Exception as e:
        return "STRUCT_FAIL", None, None, {
            "fail_reason": f"PARSE_FAIL:{e}",
            "forbidden_star_cnt": 0,
            "forbidden_star_first_seen": None,
        }

    _fn_scan = globals().get("scan_by_config_v2", None)
    if _fn_scan is None:
        return "STRUCT_FAIL", None, None, {
            "fail_reason": "MISSING_scan_by_config_v2",
            "forbidden_star_cnt": 0,
            "forbidden_star_first_seen": None,
        }
    st, entry_star_idx, strong_abs, info = scan_by_config_v2(records, rows, anchor_mode, SW_RULE)

    # Node15ï½œABSX æœ€å°è‡ªè¯ï¼šç¨³å®šæ‰“å°ï¼ˆæ•´æ¬¡è¿è¡Œåªæ‰“å°ä¸€æ¬¡ï¼›ä¸å…è®¸ NameErrorï¼‰
    if not globals().get("_ABSX_EFF_PRINTED", False):
        globals()["_ABSX_EFF_PRINTED"] = True
        try:
            _info = info if isinstance(info, dict) else {}

            _side = _info.get("abs_x_lock_side", _info.get("abs_x_lock", _info.get("abs_x_side", "NA")))
            _reachN = _info.get("abs_x_lock_N", _info.get("abs_x_reachN", "NA"))
            _idx0 = _info.get("abs_x_lock_idx", _info.get("abs_x_idx", "NA"))
            _seen_eff = _info.get("abs_x_lock_seen_eff", _info.get("abs_x_seen_eff", "NA"))
            _lenB = _info.get("abs_x_lenB", _info.get("abs_x_runlenB", "NA"))
            _lenP = _info.get("abs_x_lenP", _info.get("abs_x_runlenP", "NA"))
            _r_seq = _info.get("abs_x_r_seq", "NA")
            _basis = _info.get("abs_x_basis", "NA")

            _valid = 1 if _side in ("B", "P") else 0
            if _valid == 1:
                print(
                    f"èŠ‚ç‚¹=ABSX_EFF|valid=1|X_LOCKED={_side}|reachN={_reachN}|idx={_idx0}|seen_eff={_seen_eff}"
                    f"|lenB={_lenB}|lenP={_lenP}|evidence=r_seq={_r_seq}|basis={_basis}"
                )
                print("èŠ‚ç‚¹=ABSX_ASSERT|OK=1")

                # äº‹ä»¶4+ï½œPRE_L1 ç¡¬é˜€é—¨çœŸè‡ªè¯ï¼ˆæ”¾åœ¨ä½ å¿…çœ‹çš„ä½ç½®ï¼šABSX åï¼‰
                try:
                    if not bool(globals().get("_PRE_L1_GUARD_PRINTED", 0)):
                        globals()["_PRE_L1_GUARD_PRINTED"] = 1
                        _bak = globals().get("_L1_DECISION_DONE", 0)
                        globals()["_L1_DECISION_DONE"] = 0  # å¼ºåˆ¶ PRE_L1 åœºæ™¯ï¼Œä»…ç”¨äºè‡ªè¯
                        _l2_run = 1 if _stage_enabled("L2") else 0
                        _l3_run = 1 if _stage_enabled("L3") else 0
                        globals()["_L1_DECISION_DONE"] = _bak
                        print(f"èŠ‚ç‚¹=PRE_L1_GUARD|L1_DONE=0|L2_RUN={_l2_run}|L3_RUN={_l3_run}|expect=0")

                        # äº‹ä»¶4+ï½œè¡¥é½ PRE_L1_HARD_OFF å¯è§tickï¼ˆä¸ä¾èµ–_stage_enabledè‡ªå¸¦tickï¼Œé¿å…è¢«â€œåªæ‰“å°ä¸€æ¬¡â€åæ‰ï¼‰
                        print(f"èŠ‚ç‚¹=L2_TICK|OK=1|EVAL=1|UI=NA|EFF=1|RUN={_l2_run}|L1_DONE=0|reason=PRE_L1_HARD_OFF")
                        print(f"èŠ‚ç‚¹=L3_TICK|OK=1|EVAL=1|UI=NA|EFF=1|RUN={_l3_run}|L1_DONE=0|reason=PRE_L1_HARD_OFF")

                        if (_l2_run != 0) or (_l3_run != 0):                            raise GuardViolation(
                                code="PRE_L1_GUARD_FAIL",
                                rule_id=4,
                                phase="PROOF",
                                msg="L2/L3 preempted before L1 done",
                                evidence=f"L2_RUN={_l2_run}|L3_RUN={_l3_run}",
                                exit_code=2,
                            )
                except Exception:
                    pass

            else:                print("èŠ‚ç‚¹=ABSX_EFF|valid=0|reason=NO_ABS_X_RUNLEN_GE3")
        except Exception as _e:
            print(f"èŠ‚ç‚¹=ABSX_EFF|valid=0|reason=PRINT_FAIL:{type(_e).__name__}")

    if st != "STRUCT_OK":
        return "STRUCT_FAIL", None, strong_abs, info

    entry_star_idx = info.get("entry_star_idx", entry_star_idx)
    info["raw_star_idx"] = info.get("raw_star_idx")
    info["entry_star_idx"] = entry_star_idx
    info["struct_hash"] = info.get("struct_hash") or _cfg_struct_hash(struct_config_text, anchor_mode)
    info["struct_expr"] = info.get("struct_expr") or _cfg_struct_expr(rows)

    return "STRUCT_OK", entry_star_idx, strong_abs, info


# ==========================
# æ‰“å°æ ¼å¼å·¥å…·ï¼ˆé”æ­»ï¼‰
# ==========================
def _pct(n, d, nd=2):
    if d <= 0:
        return "0%"
    return f"{(n * 100.0 / d):.{nd}f}%"


def _cnt_pct(n, d, nd=2):
    return f"{n} ({_pct(n, d, nd)})"


# å¼€å…³æ‰“å°ç¡¬é”ï¼ˆé”æ­»ï¼‰ï¼šè¡¨å¤´+å¼ºåˆ¶è‡ªè¯ å‡å¿…é¡»æ‰“å°
_PRINTED_SWITCHES_HEADER = False
_PRINTED_SWITCHES_PROOF = False


def _print_switches_block(where: str):
    """ç¡¬é”ï¼šå¿…é¡»æ‰“å° BOOT_FILTER ä¸ STRUCT_SCANï¼›å¹¶æ‰“æ ‡è®°ä¾›æ–­è¨€ã€‚"""
    global _PRINTED_SWITCHES_HEADER, _PRINTED_SWITCHES_PROOF
    print(f"ç»“æ„é—¸é—¨ï¼š{STRUCT_SCAN_TEXT}")
    print(f"é´çº§å¼€å…³ï¼š{_boot_filter_label()}")

    # Node15ï½œé´çº§è‡ªè¯ï¼ˆæœ€å° 1 è¡Œï¼‰ï¼šæ¯ç‰ˆå†…éƒ¨â€œæœ€ç»ˆç”Ÿæ•ˆâ€çš„ boot_on / allow_from / raw_override
    try:
        _bon, _allow_from, _raw = _get_boot_filter_effective()
        _src = "BOOT_BLOCK_N_OVERRIDE" if str(_raw).strip() != "" else "BOOT_FILTER_DEFAULT"
        print(f"èŠ‚ç‚¹=BOOT_EFF|boot_on={1 if _bon else 0}|allow_from={int(_allow_from)}|raw={_raw if str(_raw).strip()!='' else 'NA'}|src={_src}")
    except Exception as _e:
        print(f"èŠ‚ç‚¹=BOOT_EFF|ERR={type(_e).__name__}:{_e}")

    if where == "HEADER":
        _PRINTED_SWITCHES_HEADER = True
    elif where == "PROOF":
        _PRINTED_SWITCHES_PROOF = True
        _PRINTED_SWITCHES_HEADER = True  # PROOF å·²æ‰“å°åŒæ ·å¼€å…³ï¼Œè§†åŒæ»¡è¶³è¡¨å¤´è‡ªè¯
    else:
        # æœªçŸ¥ä½ç½®ä»ä¸å…è®¸é™é»˜æ”¾è¿‡
        raise RuntimeError("âŒ _print_switches_block(where) where éæ³•")


# ä¸Šä¸‹æ–‡ï¼ˆç”¨äºæœ€å°æº¯æºæ‰“å°ï¼‰
_CTX_FILE = ""
_CTX_SUBBATCH = ""


def _audit_forbid_idx_offset():
    """
    å®‰å…¨è‡ªæ£€ï¼ˆé”æ­»ï½œæ‰§è¡Œ/ç»“ç®—æ®µï¼‰ï¼š
    - ç¦æ­¢ï¼šä»¥ idx ä¸ºåŸºå‡†ç›´æ¥æ¨å¯¼â€œæœªæ¥è¡Œå·â€ï¼ˆä¾‹å¦‚ï¼šidx ä¸åç§»é‡æ‹¼æ¥å¾—åˆ°æŸè¡Œï¼‰
    - ç¦æ­¢ï¼šåœ¨æ‰§è¡Œ/ç»“ç®—æ®µå›è¯» diff/rate/mean ä½œä¸ºåˆ¤æ–­ä¾æ®
    è¯´æ˜ï¼šåªå®¡è®¡ run_strategy_on_boot() å†…â€œç»“ç®—å¼€å§‹é”šç‚¹â€ä¹‹åçš„ä»£ç ï¼Œé¿å…è¯¯ä¼¤â€œæŠ•æ”¾å‰å¿«ç…§â€ã€‚
    """
    if not SILENT_MODE:
        print("=== å®‰å…¨è‡ªæ£€å¼€å§‹ ===")
    # 1) æŠ½å–ç­–ç•¥æºç ï¼ˆæ— æ³•è¯»å–åˆ™ç›´æ¥åˆ¤å®šä¸é€šè¿‡ï¼‰
    try:
        src = inspect.getsource(run_strategy_on_boot)
    except Exception:
        raise RuntimeError("SELF_TEST_FAIL: CANNOT_READ_SOURCE_RUN_STRATEGY")

    # 2) åªå®¡è®¡â€œæ‰§è¡Œ/ç»“ç®—æ®µâ€ï¼šä»é”šç‚¹å¼€å§‹å¾€å
    anchor = "# 3) EXECUTE"
    pos = src.find(anchor)
    audit_src = src[pos:] if pos >= 0 else src

    # 3) ç¦æ­¢ç‰‡æ®µï¼ˆæ‰§è¡Œ/ç»“ç®—æ®µï¼‰
    # æ³¨æ„ï¼šä¸ºäº†é¿å…â€œè‡ªæ£€å­—ç¬¦ä¸²æœ¬èº«â€è§¦å‘æ›´ä¸Šå±‚çš„æºç é›·è¾¾ï¼Œæœ¬å¤„ç”¨æ‹¼æ¥ç”Ÿæˆæ¨¡å¼ä¸²ã€‚
    a = "idx"
    sp = " +"
    lbr = "records["
    forbidden = [
        # æœªæ¥è¡Œå·ç›´ç®—ï¼ˆç¦æ­¢ï¼‰
        a + sp + " step_idx", a + "+step_idx",
        # ç¦æ­¢ star_idx åç§»ç›´ç®—
        "star_idx + 1", "star_idx+1", "star_idx +", "star_idx+",
        # ç¦æ­¢ EXECUTE/SETTLE ç›´è¯»æŒ‡æ ‡
        '.get("diff")', '.get("rate")', '.get("mean")', '["diff"]', '["rate"]', '["mean"]',

        a + sp + " b_idx", a + "+b_idx",
        lbr + a + sp, lbr + a + "+",

        # ç»“ç®—/æ‰§è¡Œé˜¶æ®µå°†æ¸¸æ ‡æŒ‡å‘ç»“ç®—è¡Œå¹¶å›è¯»æŒ‡æ ‡ï¼ˆç¦æ­¢ï¼‰
        "settle_idx", "last_bet_idx",
        "records[settle_idx]", "records[last_bet_idx]",
        "records [settle_idx]", "records [last_bet_idx]",

        # ç»•è·¯å†™æ³•ï¼ˆç¦æ­¢ï¼‰ï¼šåŒºé—´è¯»å–/åŒºé—´å¾ªç¯/è¡¨æ ¼å¼ç´¢å¼•
        lbr + a + ":", lbr + a + " :", "records[ " + a + ":", "records[ " + a + " :",
        lbr + a + "+1:", lbr + a + sp + " 1:", lbr + a + "+1:",
        "range(" + a, "range(" + a + sp, "range( " + a,
        "iloc[",
    ]

    hit = [s for s in forbidden if s in audit_src]

    if hit:
        print("âŒâŒâŒ ä¸é€šè¿‡: æ‰§è¡Œ/ç»“ç®—æ®µæ£€æµ‹åˆ°ç¦æ­¢ç‰‡æ®µ:", ",".join(hit))
        lines = audit_src.splitlines()
        shown = 0
        for i, line in enumerate(lines, 1):
            if any(h in line for h in hit):
                print(f"  HIT|Line {i}|{line.strip()}")
                shown += 1
                if shown >= 6:
                    break
        if not SILENT_MODE:
            print("=== å®‰å…¨è‡ªæ£€å®Œæˆ ===")
        raise RuntimeError("æ‰§è¡Œ/ç»“ç®—æ®µå­˜åœ¨ç¦æ­¢ç‰‡æ®µ")

    print("âœ… å®‰å…¨è‡ªæ£€é€šè¿‡ï¼šæ‰§è¡Œ/ç»“ç®—æ®µæœªæ£€æµ‹åˆ°ç¦æ­¢ç‰‡æ®µã€‚")
    if not SILENT_MODE:
        print("=== å®‰å…¨è‡ªæ£€å®Œæˆ ===")


def _audit_structure_slot_integrity() -> None:
    """
    ç»“æ„æ’æ§½å®Œæ•´æ€§è‡ªæ£€ï¼ˆå¼€å‘æœŸé˜²è¯¯ä¼¤ç‰ˆæœ¬ï¼‰ï¼š

    1) åªä»¥ã€Œè¦†ç›–é”šç‚¹001ã€åˆ¤å®šç»“æ„æ’æ§½è¾¹ç•Œï¼ˆé¿å…è¯´æ˜æ–‡å­—/æ³¨é‡Šè¯¯åˆ¤ï¼‰ï¼š
       - # ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_BEGIN
       - # ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_END

    2) æ’æ§½å†…éƒ¨å¿…é¡»ä¸”åªèƒ½åŒ…å«ï¼š
       - 1 ä¸ª scan_structure å®šä¹‰
       - 1 æ¡ STRUCT_CONFIG_TEXT å¸¸é‡

    3) è¦†ç›–åŒºç¦æ­¢å‡ºç°ä»»ä½•æ‰«æ/é—¨ç¦é€»è¾‘ç—•è¿¹ï¼ˆç¡¬å®¡è®¡ï¼‰ï¼š
       - continue / for / while / BOOT_FILTER / seen_all / range(
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            src = f.read()
    except Exception as e:
        raise RuntimeError(f"âŒ æ— æ³•è¯»å–æºç ç”¨äºç»“æ„æ’æ§½è‡ªæ£€ï¼š{e}")

    lines = src.splitlines()

    ANCHOR001_BEGIN = "ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_" "BEGIN"
    ANCHOR001_END = "ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_" "END"
    begin_pat = r"^[ \t]*#\s*" + re.escape(ANCHOR001_BEGIN) + r".*$"
    end_pat = r"^[ \t]*#\s*" + re.escape(ANCHOR001_END) + r".*$"

    begin_ms = [i for i, line in enumerate(lines) if re.match(begin_pat, line)]
    end_ms = [i for i, line in enumerate(lines) if re.match(end_pat, line)]

    if len(begin_ms) != 1 or len(end_ms) != 1:
        raise RuntimeError(
            "âŒ ç»“æ„æ’æ§½é”šç‚¹è¡Œå¿…é¡»ä¸”åªèƒ½å„å‡ºç° 1 æ¬¡ï¼š"
            f"BEGIN={len(begin_ms)}({begin_ms}) END={len(end_ms)}({end_ms})"
        )
    begin_line = begin_ms[0]
    end_line = end_ms[0]
    if end_line <= begin_line:
        raise RuntimeError("âŒ ç»“æ„æ’æ§½é”šç‚¹é¡ºåºé”™è¯¯ï¼šEND åœ¨ BEGIN ä¹‹å‰")

    slot_lines = lines[begin_line:end_line]
    slot_text = "\n".join(slot_lines)

    scan_hits = re.findall(r"^\s*def\s+scan_structure\s*\(", slot_text, flags=re.MULTILINE)
    cfg_hits = re.findall(r"^\s*STRUCT_CONFIG_TEXT\s*=", slot_text, flags=re.MULTILINE)

    if len(scan_hits) != 1 or len(cfg_hits) != 1:
        raise RuntimeError(
            "âŒ ç»“æ„æ’æ§½å†…å®¹å¼‚å¸¸ï¼š"
            f"scan_structure={len(scan_hits)} STRUCT_CONFIG_TEXT={len(cfg_hits)}"
            f" | slot_lines={begin_line + 1}..{end_line}"
        )

    # è¦†ç›–åŒºç¡¬å®¡è®¡ï¼šç¦æ­¢æ‰«æ/é—¨ç¦é€»è¾‘ç—•è¿¹
    forbid = ["continue", " for ", " while ", "BOOT_FILTER", "seen_all", "range("]
    hit = [s for s in forbid if s in slot_text]
    if hit:
        raise RuntimeError("âŒ è¦†ç›–åŒºå‡ºç°ç¦æ­¢é€»è¾‘ç‰‡æ®µï¼š" + ",".join(hit))

    # è¿½åŠ ï¼šè¦†ç›–é”šç‚¹002ï¼ˆæŠ¥å‘Šæ±‡æ€»ï¼‰å”¯ä¸€æ€§å®¡è®¡ï¼ˆå…¨æ–‡ä»¶ç¡¬è¦æ±‚ï¼‰
    ANCHOR002_BEGIN = "ğŸ€è¦†ç›–é”šç‚¹002_æŠ¥å‘Šæ±‡æ€»_" "BEGIN"
    ANCHOR002_END = "ğŸ€è¦†ç›–é”šç‚¹002_æŠ¥å‘Šæ±‡æ€»_" "END"
    begin_pat2 = r"^[ \t]*#\s*" + re.escape(ANCHOR002_BEGIN) + r".*$"
    end_pat2 = r"^[ \t]*#\s*" + re.escape(ANCHOR002_END) + r".*$"
    begin_ms2 = [i for i, line in enumerate(lines) if re.match(begin_pat2, line)]
    end_ms2 = [i for i, line in enumerate(lines) if re.match(end_pat2, line)]
    if len(begin_ms2) != 1 or len(end_ms2) != 1:
        raise RuntimeError(
            "âŒ æŠ¥å‘Šæ±‡æ€»é”šç‚¹è¡Œå¿…é¡»ä¸”åªèƒ½å„å‡ºç° 1 æ¬¡ï¼š"
            f"BEGIN={len(begin_ms2)}({begin_ms2}) END={len(end_ms2)}({end_ms2})"
        )


def _update_run(run_side, run_len, r):
    # çŠ¶æ€ T ä½ç§»é›¶åå·®ï¼šrun_side/run_len ä¸å˜  # [cite: 13]
    if r == "T":
        return run_side, run_len  # [cite: 13]
    if not _is_bp(r):
        return run_side, run_len  # [cite: 13]
    if run_side is None or r != run_side:
        return r, 1  # [cite: 13]
    return run_side, run_len + 1  # [cite: 13]


def _compute_max_runs_first9(records):
    # åªçœ‹å‰ 9 å£ï¼ˆseen_all=1..9ï¼ŒçŠ¶æ€ B/P/T éƒ½ç®—ä½ç§»å£æ•°ï¼‰  # [cite: 14]
    seen_all = 0  # [cite: 14]
    run_side = None  # [cite: 14]
    run_len = 0  # [cite: 14]
    max_run = {"B": 0, "P": 0}  # [cite: 14]
    for rec in records:
        seen_all += 1  # [cite: 14]
        run_side, run_len = _update_run(run_side, run_len, rec["r"])  # [cite: 14]
        if run_side in ("B", "P"):
            if run_len > max_run[run_side]:
                max_run[run_side] = run_len  # [cite: 14]
        if seen_all >= 9:
            break  # [cite: 14]
    return max_run["B"], max_run["P"], seen_all  # [cite: 14]


def _self_stop_tracker_init():
    return {"run_side": None, "run_len": 0, "seen_b3": False, "seen_p3": False}  # [cite: 14]


def _self_stop_tracker_step(st, r):
    st["run_side"], st["run_len"] = _update_run(st["run_side"], st["run_len"], r)  # [cite: 15]
    if st["run_side"] == "B" and st["run_len"] >= 3:
        st["seen_b3"] = True  # [cite: 15]
    if st["run_side"] == "P" and st["run_len"] >= 3:
        st["seen_p3"] = True  # [cite: 15]
    return st  # [cite: 15]


def _should_self_stop(st):
    # ä¸¤è¾¹éƒ½æ›¾å‡ºç°æ®µé•¿â‰¥3 â†’ è‡ªåœ  # [cite: 15]
    return st["seen_b3"] and st["seen_p3"]  # [cite: 15]


from collections import defaultdict

# ==========================
# è¿æ®µç»Ÿè®¡ï¼ˆåŒæŒ‡æ ‡ç›¸é‚»æ€ï½œé”æ­»ï¼‰  # [cite: 15]
# ==========================
# ç›®æ ‡ï¼šåœ¨â€œå•æŒ‡æ ‡æ— è§„å¾‹â€çš„å‰æä¸‹ï¼Œåªè§‚å¯Ÿâ€œåŒæŒ‡æ ‡ç›¸é‚»æ€â€çš„åˆ†å¸ƒï¼Œç”¨äº STOP å€™é€‰ç­›é€‰ï¼›  # [cite: 15]
# çº¦æŸï¼šè¿ç»­ç»Ÿè®¡åªèƒ½åŸºäºâ€œæŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨â€åšäº‹åæ±‡æ€»ï¼›å†³ç­–é€»è¾‘ä»å¿…é¡»æ»¡è¶³â€œå†³ç­–å£åŸºå‡†ï¼ˆé›¶æœªæ¥ï¼‰â€ã€‚  # [cite: 15]
#
# å¿«ç…§å£å¾„ï¼ˆé”æ­»ï½œå£å¾„ Bï¼‰ï¼šæ¯æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘è®°å½•ä¸€æ¬¡å¿«ç…§ï¼ˆå«çŠ¶æ€ T åçš„é‡å¤æŠ•æ”¾ï¼‰ï¼Œå¿«ç…§æ¥è‡ªâ€œæŠ•æ”¾ç‚¹å½“è¡Œâ€åŸå§‹æŒ‡æ ‡ã€‚  # [cite: 15]
# è¿ç»­é•¿åº¦ï¼ˆé”æ­»ï¼‰ï¼šç›¸é‚»æ€ï¼ˆä¸Šä¸€æ¬¡â†’è¿™ä¸€æ¬¡ï¼‰ã€‚  # [cite: 15]
#
# å¿«ç…§å­—æ®µï¼ˆå»ºè®®ç­–ç•¥è¿”å› snapshots åˆ—è¡¨ï¼Œæ¯æ¡è‡³å°‘åŒ…å«ï¼‰ï¼š  # [cite: 15]
#   - bet_n: ç¬¬å‡ æ¬¡å®é™…æŠ•æ”¾ï¼ˆä» 1 å¼€å§‹ï¼›å«çŠ¶æ€ T é‡å¤æŠ•æ”¾ä¼šå¯¼è‡´ bet_n > 4ï¼‰  # [cite: 15]
#   - diff: ç‚¹å·®ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - rate: å˜åŒ–ç‡ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - mean: å‡å·®ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - trade_bust: æœ¬ç¬”äº¤æ˜“æœ€ç»ˆæ˜¯å¦é˜ˆå€¼å‡»ç©¿ï¼ˆ0/1ï¼Œç”¨äºè®¡ç®—â€œåç»­é˜ˆå€¼å‡»ç©¿ç‡â€ï¼‰  # [cite: 15]
#
# è¾“å‡ºï¼ˆé”æ­»ï½œAI å‹å¥½ï¼‰ï¼š  # [cite: 15]
#   A) (|ç‚¹å·®|æ¡¶, rate ç›‘æµ‹æ¡¶) çš„ç›¸é‚»æ€åˆ‡æ¢æ¦œï¼šS_{t-1}â†’S_tï¼ˆTopKï¼‰  # [cite: 15]
#   B) (|ç‚¹å·®|æ¡¶, mean æ¡¶) çš„ç›¸é‚»æ€åˆ‡æ¢æ¦œï¼šS_{t-1}â†’S_tï¼ˆTopKï¼‰  # [cite: 15]
#   æ¯æ¡åˆ‡æ¢è¾“å‡ºï¼šå‡ºç°æ¬¡æ•°ã€åç»­é˜ˆå€¼å‡»ç©¿æ•°ã€åç»­é˜ˆå€¼å‡»ç©¿ç‡ï¼ˆexhaustion / å‡ºç°æ¬¡æ•°ï¼‰  # [cite: 15]
#   é»˜è®¤åªè¾“å‡ºâ€œæ ·æœ¬é‡ >= é˜ˆå€¼â€çš„åˆ‡æ¢ï¼Œé¿å…å™ªå£°ã€‚  # [cite: 15]
CONT_STATS_ENABLE = 0  # [cite: 15]
CONT_MAX_BET_N = 12  # [cite: 15]
CONT_MIN_SAMPLES = 500  # [cite: 15]
CONT_TOPK = 20  # [cite: 15]


def _abs_diff_bucket(diff: int) -> str:
    # ç»å¯¹å€¼ç‚¹å·®æ¡¶ï¼š0,1,2,...,9,9+ï¼ˆ9+ è¡¨ç¤º >=10ï¼›9 ä»…è¡¨ç¤º ==9ï¼‰
    absd = abs(diff)
    if absd >= 10:
        return "9+"
    return str(absd)


def _safe_int(v: Any):
    """å®‰å…¨è½¬ intï¼šNone/ç©ºä¸²/'None'/'nan' ç­‰è§†ä¸ºæ— æ•ˆï¼›å¤±è´¥è¿”å› Noneã€‚"""
    if v is None:
        return None
    if isinstance(v, bool):
        return int(v)
    if isinstance(v, int):
        return v
    try:
        s = str(v).strip()
    except Exception:
        return None
    if s == "":
        return None
    sl = s.lower()
    if sl in ("none", "nan", "null"):
        return None
    try:
        # å…¼å®¹ '3.0' è¿™ç§è¾“å…¥
        return int(float(s))
    except Exception:
        return None


def _l1_abs_diff_bucket(diff_raw: Any) -> str:
    """ç‚¹å·®æ¡¶ï¼š0..9 + 9+ï¼ˆå…± 10+1 ä¸ªä½ç½®ï¼‰ã€‚"""
    d = _safe_int(diff_raw)
    if d is None:
        return "æ— æ•ˆ"
    ad = abs(int(d))
    if ad >= 10:
        return "9+"
    return str(ad)


# ===== å†»ç»“åŒºï¼šå˜åŒ–ç‡åˆ†æ¡¶é˜ˆå€¼ï¼ˆåªè¯»å­—æ®µï¼›ä»…ç”¨äºåˆ†æ¡¶æ˜ å°„ï½œé”æ­»ï¼‰=====
# L1ï¼šå‰å°/å‰å¤§/æå€¼/æ— æ•ˆï¼ˆé”æ­»ï¼‰
L1_RATE_TH_SMALL = -2.0  # r > -2  -> å‰å°
L1_RATE_TH_BIG = -3.0  # -3 < r <= -2 -> å‰å¤§ï¼›r <= -3 -> æå€¼
# L2/L3/L4ï¼šå‡é€Ÿ/åŠ é€Ÿ/æå€¼/æ— æ•ˆï¼ˆé”æ­»ï¼‰
R_RATE_TH_SLOW = 0.0  # r < 0 -> å‡é€Ÿ
R_RATE_TH_FAST = 2.0  # 0 <= r < 2 -> åŠ é€Ÿï¼›r >= 2 -> æå€¼


def _rate_monitor_bucket(rate):
    """L2/L3/L4 å››æ¡¶ï¼šå‡é€Ÿ/åŠ é€Ÿ/æå€¼/æ— æ•ˆï¼ˆé”æ­»ï¼‰ã€‚"""
    if rate is None:
        return "æ— æ•ˆ"
    try:
        r = float(rate)
    except Exception:
        return "æ— æ•ˆ"

    # å¼ºåŒ–ï¼š0 å¿…é¡»å½’â€œåŠ é€Ÿâ€ï¼ˆä¸æ˜¯æ— æ•ˆï¼‰
    if r == 0.0:
        return "åŠ é€Ÿ"
    if r < R_RATE_TH_SLOW:
        return "å‡é€Ÿ"
    if r < R_RATE_TH_FAST:
        return "åŠ é€Ÿ"
    return "æå€¼"


def _l1_rate_bucket(rate):
    """L1 å››æ¡¶ï¼šå‰å°/å‰å¤§/æå€¼/æ— æ•ˆï¼ˆé”æ­»ï¼‰ã€‚"""
    if rate is None:
        return "æ— æ•ˆ"
    try:
        r = float(rate)
    except Exception:
        return "æ— æ•ˆ"

    # å¼ºåŒ–ï¼š0 å¿…é¡»å½’â€œå‰å°â€ï¼ˆä¸æ˜¯æ— æ•ˆï¼‰
    if r == 0.0:
        return "å‰å°"
    if r > L1_RATE_TH_SMALL:
        return "å‰å°"
    if L1_RATE_TH_BIG < r <= L1_RATE_TH_SMALL:
        return "å‰å¤§"
    return "æå€¼"


def _rate_mode_from_exhaustion(exh):
    """ç¡¬é—¸é—¨ï¼šäºŒä½ç  -> æ¨¡å¼ï¼ˆä¸­æ–‡é”æ­»ï¼‰ã€‚
    è§„åˆ™ï¼š
      - åªè¦åŒ…å« 'T'ï¼šä¸€å¾‹åˆ¤ä¸ºâ€œæ— æ•ˆâ€ï¼ˆä¸åšè¿‡æ»¤ï¼‰
      - ä»…å½“æ°å¥½ä¸ºä¸¤ä½ä¸”éƒ½åœ¨ {B,P}ï¼š
          * BB / PP â†’ åŠ å‡é€Ÿ
          * BP / PB â†’ å‰å¤§å°
      - å…¶ä»–ï¼šæ— æ•ˆ
    """
    if exh is None:
        return "æ— æ•ˆ"
    s = str(exh).strip().upper()
    if not s:
        return "æ— æ•ˆ"
    if "T" in s:
        return "æ— æ•ˆ"
    if s in ("BB", "PP"):
        return "åŠ å‡é€Ÿ"
    if s in ("BP", "PB"):
        return "å‰å¤§å°"
    return "æ— æ•ˆ"


def _rate_quartet(exh_pair, rate_value):
    """å”¯ä¸€å…¥å£ï¼šè¿”å› (mode, l1_bucket, r_bucket, active_bucket)"""
    mode = _rate_mode_from_exhaustion(exh_pair)
    # ä¸¤å¥—æ¡¶éƒ½ç®—å‡ºæ¥ï¼ˆå†™å¿«ç…§ä¸€æ¬¡æ€§ç»‘å®šï¼‰ï¼Œé¿å…ä¸‹æ¸¸é‡å¤å®ç°
    l1b = _l1_rate_bucket(rate_value)
    rb = _rate_monitor_bucket(rate_value)

    if mode == "å‰å¤§å°":
        active = l1b
    elif mode == "åŠ å‡é€Ÿ":
        active = rb
    else:
        active = "æ— æ•ˆ"

    # 0å€¼å¼ºåŒ–ï¼šè‹¥ rate_value æ˜¯æœ‰æ•ˆ 0ï¼Œå¿…é¡»è½åœ¨é¢„æœŸæ¡¶
    try:
        if rate_value is not None and float(rate_value) == 0.0:
            if l1b != "å‰å°":
                raise RuntimeError("RATE_ZERO_L1_BUCKET_MISMATCH")
            if rb != "åŠ é€Ÿ":
                raise RuntimeError("RATE_ZERO_R_BUCKET_MISMATCH")
    except Exception:
        # è‹¥è¿™é‡Œå¼‚å¸¸ï¼Œè¯´æ˜ä¸Šæ¸¸æŠŠç¼ºå¤±ç¡¬è½¬0 æˆ– bucket å®ç°è¢«æ±¡æŸ“
        raise

    return mode, l1b, rb, active


def _l1_mean_bucket(diff, mean):
    # L1 å‡å·®åˆ†æ¡¶é”æ­»ä¸º 4 æ¡¶ï¼š|å‡å·®|<3 / |å‡å·®|>=3 / mean=0 / æ— æ•ˆ
    # åªè¯» meanï¼ˆä¸é‡ç®—/ä¸ä¿®æ­£ï¼‰ï¼Œdiff å‚æ•°ä¿ç•™ä½†ä¸å‚ä¸åˆ†æ¡¶ã€‚
    bucket, invalid = _mean_bucket(mean)
    return bucket, invalid


def _mean_bucket(mean):
    """å‡å·®åˆ†æ¡¶ï¼ˆå†»ç»“åŒºå”¯ä¸€å…¥å£ï½œåªè¯»è¾“å…¥ï¼Œä¸é‡ç®—åŸå§‹æŒ‡æ ‡ï¼‰
    è¿”å›: (bucket, invalid_flag)
      - æ— æ•ˆ=ç©º/None/nan/è§£æå¤±è´¥ -> ("æ— æ•ˆ", True)
      - mean == 0 -> ("mean=0", False)
      - |mean| >= 3 -> ("|å‡å·®|>=3", False)
      - |mean| < 3 -> ("|å‡å·®|<3", False)
    """
    m = safe_float(mean, default=None, kind="MEAN")
    if m is None:
        return "æ— æ•ˆ", True
    if m == 0:
        return "mean=0", False
    return ("|å‡å·®|>=3" if abs(m) >= 3 else "|å‡å·®|<3"), False


# ==================== å†»ç»“åŒºï½œæŠ•æ”¾é“¾è·¯ï¼ˆL1-L5ï¼‰å”¯ä¸€å…¥å£ BEGIN ====================
# ç›®çš„ï¼ˆé”æ­»ï¼‰ï¼š
# - L1/L2/L3/L4 çš„â€œåˆ†å±‚å­—æ®µ + è¯»é”™å³é€€â€ï¼›
# - æœªå¯ç”¨é˜¶æ®µï¼šä¸å†™å¿«ç…§ã€ä¸å…¥è§„åˆ™æ—æ ·æœ¬æ± ï¼›ä»»ä½•è¯»å–=è¶Šæƒé€€å‡ºï¼›
# - æ•°æ®ç¼ºå¤±ï¼ˆrate/mean ç©º/None/nan/è§£æå¤±è´¥ï¼‰ï¼šè¿›å…¥â€œæ— æ•ˆæ¡¶â€ç»§ç»­è·‘ï¼Œå¹¶åœ¨æŠ¥å‘Šè¾“å‡º TopN åŸå§‹å­—ç¬¦ä¸²æ ·ä¾‹ã€‚

_STAGE_LIST = ("L1", "L2", "L3", "L4", "L5")


def _stage_to_bet_n(stage: str) -> int:
    m = {"L1": 1, "L2": 2, "L3": 3, "L4": 4, "L5": 5}
    if stage not in m:
        raise ValueError(f"bad stage={stage}")
    return m[stage]


_ALLOWED_SNAP_SOURCE = ("STAR_ONLY", "L1", "L2", "L3", "L4", "L5")

# æŠ¥å‘Šå‚æ•°ï¼ˆå†»ç»“åŒºåªè¯»è¿™ä¸€å¤„ï¼›å¤–éƒ¨ç»“æ„æ’æ§½ä¸å¾—ä¼ªé€ ï¼‰
# - ç›®æ ‡å±‚å”¯ä¸€æ¥æºï¼šTARGET_STAGEï¼ˆç¼ºçœæŒ‰ L4ï¼‰
# - åˆ†å±‚å¼€å…³ï¼šENABLE_L1..ENABLE_L5
# é“¾è·¯å¼€å…³ï¼ˆæ‰‹åŠ¨å®šä½ç”¨ï¼‰
TARGET_STAGE = "L4"
ENABLE_L1 = 1
ENABLE_L2 = 1
ENABLE_L3 = 1
ENABLE_L4 = 1
ENABLE_L5 = 0

# è§„åˆ™æ—æ‰«æå¼€å…³ï¼ˆæŠ¥å‘Šå‚æ•°ï¼‰
RULESCAN_ON = 1

# Î”è‡ªè¯å®¡è®¡å¼€å…³ï¼ˆå†»ç»“åŒºï¼‰
DELTA_AUDIT_ON = 1  # 1=æ‰“å°[L4_Î”è‡ªè¯]ä¸ä½œåºŸåˆ¤å®šï¼›0=å®Œå…¨å…³é—­
DELTA_AUDIT_ENFORCE = 1  # 1=ä½œåºŸå³é€€å‡º(é€€å‡ºç é0)ï¼›0=åªæ‰“å°ä½œåºŸä½†ç»§ç»­è·‘ï¼ˆè§„åˆ™æ—æ¦œå•è·³è¿‡ï¼‰
RULESCAN_MIN_CNT = 1000
RULESCAN_TOPN = 5


class _UNSET_T:
    pass


_UNSET = _UNSET_T()


# ==========================
# é˜¶æ®µå¿«ç…§å®šä¹‰ï¼ˆNode 5 ä¿®æ­£ï¼šå­—æ®µé”æ­» + åªè¯»å°å­˜ï¼‰
# ==========================
@dataclass(frozen=True)
class StageSnap:
    # æœ€å°é›†ï¼ˆé”æ­»ï¼‰
    stage: str
    bet_n: int
    rule_id: str

    # Node 5: å¿…å¤‡å­—æ®µé”æ­»ï¼ˆåªå¤åˆ¶ï¼Œä¸è®¡ç®—ï¼Œä¸å†è¯»æŒ‡æ ‡ï¼‰
    exhaustion: str  # = exh_pair
    settle_rr: str  # = rr
    diff_abs: int  # = diff_val (abs)
    diff3_bucket: str  # = diff_bucket
    diff_tokens: str  # = diff_bucket (alias)
    rate_val: float | None
    mean_val: float | None
    rate_raw_text: str
    mean_raw_text: str
    rate_bucket: str
    mean_bucket: str

    snap_source: str
    snap_seq: int  # æ¯é´ä»1é€’å¢ï¼Œä»…æ’åº/å®¡è®¡
    profit_to_here: float = 0.0  # æœ¬æ¬¡é˜¶æ®µå¿«ç…§å†™å…¥æ—¶åˆ»ï¼šå·²çœŸå®ç»“ç®—å‡ºæ¥çš„å‡€å€¼ï¼ˆç”¨äºåäº‹å®Î”ï¼‰

    # åˆ†å±‚å­—æ®µï¼ˆç‰©ç†éš”ç¦»ï¼šè¯»é”™å³é€€ï¼‰
    rate_bucket_L1: str | _UNSET_T = _UNSET
    rate_bucket_L2: str | _UNSET_T = _UNSET
    rate_bucket_L3: str | _UNSET_T = _UNSET
    rate_bucket_L4: str | _UNSET_T = _UNSET
    rate_bucket_L5: str | _UNSET_T = _UNSET

    # ä»…ç”¨äºâ€œç¼ºå¤±æ ·ä¾‹ TopNâ€è‡ªè¯
    _rate_raw_text: str = ""
    _mean_raw_text: str = ""

    # å…¼å®¹æ—§å­—æ®µï¼ˆå¦‚æœéœ€è¦ï¼Œå¦åˆ™å¯ç§»é™¤ï¼‰
    diff_raw: int = 0
    rate_raw: float | None = None
    mean_raw: float | None = None
    diff_bucket: str = ""


def _stage_enabled(stage: str) -> bool:
    # ===== äº‹é¡¹4å‡çº§ï¼šL2/L3 ä¸å¾—å‰ç½®å¹²æ¶‰ L1ï¼ˆåƒå½“å‰L4ä¸€æ ·ï¼šåªå…è®¸åéªŒå¯ç”¨ï¼‰=====
    # è¯´æ˜ï¼šåœ¨ L1 å†³ç­–ï¼ˆsecure_write_star_snapshotï¼‰å®Œæˆä¹‹å‰ï¼ŒL2/L3 è§†ä¸ºâ€œç¡¬å…³é—­â€
    l1_done = bool(globals().get("_L1_DECISION_DONE", 0))

    # å…ˆç®—â€œé…ç½®å±‚å¼€å…³â€
    if stage == "L1":
        eff = bool(ENABLE_L1)
    elif stage == "L2":
        eff = bool(ENABLE_L2)
    elif stage == "L3":
        eff = bool(ENABLE_L3)
    elif stage == "L4":
        eff = bool(ENABLE_L4)
    elif stage == "L5":
        eff = bool(ENABLE_L5)
    else:
        eff = False

    # å†æ–½åŠ â€œç¡¬é˜€é—¨â€ï¼šL2/L3 åœ¨ L1_DONE=0 æ—¶å¼ºåˆ¶å…³é—­
    if stage in ("L2", "L3") and not l1_done:
        eff2 = False
        reason = "PRE_L1_HARD_OFF"
    else:
        eff2 = eff
        reason = "ENABLED" if eff else "DISABLED_BY_FLAG"

    # L2/L3 è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡ï¼ˆEVAL=1 è¡¨ç¤ºâ€œè¢«è¯„ä¼°è¿‡â€ï¼‰
    if stage in ("L2", "L3"):
        try:
            k = f"_{stage}_TICK_EVAL_PRINTED"
            if not bool(globals().get(k, 0)):
                globals()[k] = 1
                ui = globals().get(f"ENABLE_{stage}_UI", "NA")
                print(
                    f"èŠ‚ç‚¹={stage}_TICK|OK=1|EVAL=1|UI={ui}|EFF={1 if eff else 0}"
                    f"|RUN={1 if eff2 else 0}|L1_DONE={1 if l1_done else 0}|reason={reason}"
                )
        except Exception:
            pass

    return eff2


def _guard_stage(stage: str, code: str, why: str, *, boot_id=None, idx=None, phase: str = "REPORT", rule_id: str = "0",                 evidence_extra: str = "") -> None:
    """å†»ç»“åŒºç¡¬æ‹¦æˆªï¼šé˜¶æ®µ/å¥‘çº¦/è¶Šæƒç±»é”™è¯¯å¿…é¡»é€€å‡ºã€‚"""
    evidence = f"boot_id={boot_id} idx={idx}"
    if evidence_extra:
        evidence = evidence + " " + str(evidence_extra)
    _raise_guard(code=code, rule_id=rule_id, phase=phase, msg=f"[é“¾è·¯]{why} | stage={stage}", evidence=evidence,
                 exit_code=2)


def _guard_stage_read(snap: StageSnap, stage: str, field: str) -> str:
    if not _stage_enabled(stage):
        _guard_stage(stage, "STAGE_DISABLED_READ", f"æœªå¯ç”¨é˜¶æ®µè¢«è¯»å–ï¼š{field}")
    if snap.stage != stage:
        _guard_stage(stage, "STAGE_MISMATCH_READ", f"è¯»é”™é˜¶æ®µï¼šsnap.stage={snap.stage} ä½†è¯»å–={stage}.{field}")
    v = getattr(snap, field)
    if v is _UNSET:
        _guard_stage(stage, "STAGE_FIELD_FORBIDDEN", f"è¯»é”™åˆ†å±‚å­—æ®µï¼š{field}")

    # L2/L3 è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡ï¼ˆEVAL=0 è¡¨ç¤ºâ€œçœŸå®è¿è¡Œåˆ°è¯»å­—æ®µâ€ï¼‰
    if stage in ("L2", "L3"):
        try:
            k = f"_{stage}_TICK_RUN_PRINTED"
            if not bool(globals().get(k, 0)):
                globals()[k] = 1
                ui = globals().get(f"ENABLE_{stage}_UI", "NA")
                print(f"èŠ‚ç‚¹={stage}_TICK|OK=1|EVAL=0|UI={ui}|EFF=1|RUN=1|field={field}")
        except Exception:
            pass

    return v


def _rate_bucket_for_stage(stage: str, rate) -> str:    # L1ï¼šå‰å°/å‰å¤§/æå€¼/æ— æ•ˆï¼ˆé”æ­»ï¼‰
    # L2-L4ï¼šå‡é€Ÿ/åŠ é€Ÿ/æå€¼/æ— æ•ˆï¼ˆé”æ­»ï¼‰
    if stage == "L1":
        return _l1_rate_bucket(rate)
    return _rate_monitor_bucket(rate)


def _exhaustion_pair_for_stage(star: Snapshot) -> str:
    try:
        v = star.exh_pair
        if not v:
            return "æ— æ•ˆ"
        return str(v)
    except Exception:
        return "æ— æ•ˆ"


def _bind_raw_text_fields(star: Snapshot, rate_raw_text, mean_raw_text) -> None:
    try:
        star._rate_raw_text = "" if rate_raw_text is None else str(rate_raw_text)
    except Exception:
        star._rate_raw_text = "<?>"
    try:
        star._mean_raw_text = "" if mean_raw_text is None else str(mean_raw_text)
    except Exception:
        star._mean_raw_text = "<?>"


# ==========================
# é˜¶æ®µå¿«ç…§ç”Ÿæˆï¼ˆNode 5 ä¿®æ­£ï¼šä» star_snap å¤åˆ¶ï¼‰
# ==========================
def _make_stage_snap_from_star(
        *,
        stage: str,
        star: Snapshot,
        rule_id: str,
        snap_source: str,
        boot_id: int,
        snap_seq: int,
        profit_to_here: float,
        settle_rr: str,
) -> StageSnap:
    if stage not in _STAGE_LIST:
        _guard_stage(stage, "STAGE_INVALID", "éæ³•é˜¶æ®µå", boot_id=boot_id, idx=getattr(star, "idx", None))
    if snap_source not in _ALLOWED_SNAP_SOURCE:
        _guard_stage(stage, "SNAP_SOURCE_INVALID", f"snap_source éæ³•ï¼š{snap_source}", boot_id=boot_id,
                     idx=getattr(star, "idx", None))
    if not _stage_enabled(stage):
        _guard_stage(stage, "STAGE_DISABLED_WRITE", "æœªå¯ç”¨é˜¶æ®µä»å†™å…¥å¿«ç…§", boot_id=boot_id,
                     idx=getattr(star, "idx", None))

    # Node 5: ä»…å…è®¸ä» star_snapï¼ˆæŠ•æ”¾ç‚¹å½“è¡Œå°å­˜å€¼ï¼‰å¤åˆ¶
    # ä¸¥ç¦ secure_read_metric

    # Node 5: ä»…å…è®¸ä» star_snapï¼ˆæŠ•æ”¾ç‚¹å½“è¡Œå°å­˜å€¼ï¼‰å¤åˆ¶
    # ä¸¥ç¦ secure_read_metric

    # å…œåº•ï¼šä¼˜å…ˆ *_valï¼Œå…¶æ¬¡ç”¨åŸºç¡€å­—æ®µï¼ˆä»ç„¶åªç”¨ğŸ¯å½“è¡Œå°å­˜å€¼ï¼Œä¸å¼•å…¥æœªæ¥æ•°ï¼‰
    diff_val = star.diff_val
    rate_val = star.rate_val
    mean_val = star.mean_val

    # åªé”æ­» diff_val å¿…é¡»å­˜åœ¨ï¼›rate/mean å…è®¸ç¼ºå¤±ï¼ˆè¿›å…¥æ— æ•ˆæ¡¶ç»§ç»­è·‘ï¼‰
    if diff_val is None:
        raise RuntimeError(f"STAR_SNAPSHOT_MISSING_DIFF_VAL: diff_val=None | boot_id={boot_id}")

    diff_bucket = star.diff_bucket
    mean_bucket = star.mean_bucket

    exh_pair = _exhaustion_pair_for_stage(star)

    # Rate bucket for this stage
    rb = _rate_bucket_for_stage(stage, rate_val)

    kwargs = {"rate_bucket_L1": _UNSET, "rate_bucket_L2": _UNSET, "rate_bucket_L3": _UNSET, "rate_bucket_L4": _UNSET,
              "rate_bucket_L5": _UNSET}
    kwargs[f"rate_bucket_{stage}"] = rb

    return StageSnap(
        stage=stage,
        bet_n=_stage_to_bet_n(stage),
        rule_id=rule_id,

        # Node 5: å­—æ®µæ˜ å°„
        exhaustion=exh_pair,
        settle_rr=settle_rr,
        diff_abs=abs(int(diff_val)),
        diff3_bucket=diff_bucket,
        diff_tokens=diff_bucket,
        rate_val=rate_val,
        mean_val=mean_val,
        rate_raw_text=getattr(star, "_rate_raw_text", ""),
        mean_raw_text=getattr(star, "_mean_raw_text", ""),
        rate_bucket=rb,

        # å…¼å®¹æ—§å­—æ®µï¼ˆå¦‚æœéœ€è¦ï¼Œå¦åˆ™å¯ç§»é™¤ï¼‰
        diff_raw=int(diff_val),
        rate_raw=rate_val,
        mean_raw=mean_val,
        diff_bucket=diff_bucket,
        mean_bucket=mean_bucket,
        _rate_raw_text=getattr(star, "_rate_raw_text", ""),
        _mean_raw_text=getattr(star, "_mean_raw_text", ""),

        snap_source=snap_source,
        snap_seq=snap_seq,
        profit_to_here=profit_to_here,
        **kwargs,
    )


# ==========================
# é˜¶æ®µå¿«ç…§ç”Ÿæˆï¼ˆNode 2 ä¿®æ­£ï¼šç¦ç”¨ç¼“å­˜å›è¯»ï¼‰
# ==========================
def _make_stage_snap_from_cache(
        *,
        stage: str,
        rule_id: str,
        rr: str,
        cache_row: dict,
        snap_source: str,
        snap_seq: int,
        profit_to_here: float,
) -> StageSnap:
    """
    Node 2 ä¿®æ­£ï¼šæ°¸ä¹…ç¦ç”¨ä» metrics_cache å›è¯»æŒ‡æ ‡ã€‚
    é˜¶æ®µå¿«ç…§å¿…é¡»åŸºäºâ€œæŠ•æ”¾ç‚¹å½“è¡Œå°å­˜å€¼â€ç”Ÿæˆï¼ˆNode 3 å°†å®ç°ï¼‰ï¼Œ
    ä¸¥ç¦ä½¿ç”¨â€œæœªæ¥è¡Œç¼“å­˜â€æˆ–â€œå›è¯»å†å²è¡Œâ€ã€‚
    """
    raise RuntimeError("METRICS_CACHE_FORBIDDEN: _make_stage_snap_from_cache is permanently disabled in Node 2.")


def stage_rate_bucket(snap: StageSnap, stage: str) -> str:
    return _guard_stage_read(snap, stage, f"rate_bucket_{stage}")


# ==================== å†»ç»“åŒºï½œæŠ•æ”¾é“¾è·¯ï¼ˆL1-L5ï¼‰å”¯ä¸€å…¥å£ END ====================


def _init_cont_agg():
    return {
        "pair_rate": {},  # key: (bet_n, prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_mean": {},  # key: (bet_n, prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_rate_overall": {},  # key: (prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_mean_overall": {},  # key: (prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "max_bet_n_seen": 0,  # [cite: 21]
    }


def _agg_add(d, key, bust_flag):
    if key not in d:
        d[key] = [0, 0]  # [cite: 22]
    d[key][0] += 1  # [cite: 22]
    d[key][1] += int(1 if bust_flag else 0)  # [cite: 22]


def _cont_consume_snapshots(agg, snapshots):
    # snapshots: list of dicts with bet_n,diff,rate,mean,trade_exhaustion  # [cite: 23]
    if not snapshots:
        return  # [cite: 23]
    snaps = [x for x in snapshots if isinstance(x, dict) and "bet_n" in x]  # [cite: 23]
    snaps.sort(key=lambda x: int(x.get("bet_n", 0)))  # [cite: 23]
    if len(snaps) < 2:
        return  # [cite: 23]

    bust_flag = int(snaps[-1].get("trade_bust", 0))  # [cite: 23]
    for i in range(1, len(snaps)):
        a = snaps[i - 1]  # [cite: 23]
        b = snaps[i]  # [cite: 23]
        try:
            bn = int(b.get("bet_n", 0))  # [cite: 23]
        except Exception:
            bn = 0  # [cite: 23]
        if bn > agg["max_bet_n_seen"]:
            agg["max_bet_n_seen"] = bn  # [cite: 23]

        prev_rate = (_abs_diff_bucket(a.get("diff", 0)), _rate_monitor_bucket(a.get("rate")))  # [cite: 24]
        curr_rate = (_abs_diff_bucket(b.get("diff", 0)), _rate_monitor_bucket(b.get("rate")))  # [cite: 24]
        prev_mean = (_abs_diff_bucket(a.get("diff", 0)), _mean_bucket(a.get("mean"))[0])  # [cite: 24]
        curr_mean = (_abs_diff_bucket(b.get("diff", 0)), _mean_bucket(b.get("mean"))[0])  # [cite: 24]

        _agg_add(agg["pair_rate"], (bn, prev_rate, curr_rate), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_mean"], (bn, prev_mean, curr_mean), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_rate_overall"], (prev_rate, curr_rate), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_mean_overall"], (prev_mean, curr_mean), bust_flag)  # [cite: 24]


def _print_top_transitions(title, d, min_samples, topk):
    rows = []  # [cite: 25]
    for k, (cnt, bust) in d.items():
        if cnt < min_samples:
            continue  # [cite: 25]
        br = bust / cnt if cnt else 0.0  # [cite: 25]
        rows.append((br, cnt, bust, k))  # [cite: 25]
    rows.sort(reverse=True, key=lambda x: (x[0], x[1]))  # [cite: 25]
    print(title)  # [cite: 25]
    if not rows:
        print("ï¼ˆæ— è¾“å‡ºï¼šæ ·æœ¬é‡ä¸è¶³ï¼‰")  # [cite: 25]
        return  # [cite: 25]
    for i, (br, cnt, bust, k) in enumerate(rows[:topk], 1):
        print(f"{i:02d}. {k} | æ¬¡æ•°={cnt} | é˜ˆå€¼å‡»ç©¿={bust} | é˜ˆå€¼å‡»ç©¿ç‡={br:.4f}")  # [cite: 26]


# ============================================================
# ç»Ÿä¸€ä»£ç æ¨¡æ¿ï¼ˆV4ï¼Œåºåˆ—é•¿åº¦å£å¾„ï½œä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“ï¼‰
# çº¦æŸï¼š
# 1) åªè¯»å–å½“å‰ç›®å½•ä¸‹æ‰€æœ‰ .csv
# 2) ä¸å†™æ­»ä»»ä½•ç»å¯¹è·¯å¾„
# 3) è‡ªåŠ¨è¯†åˆ«æ‰¹æ¬¡åˆ—/ç»“æœ/ç‚¹å·®/å˜åŒ–ç‡/å‡å·®
# 4) ç»“æœå¿…é¡»æ˜ å°„ä¸º B/P/T
# 5) ä¸¥æ ¼é›¶æœªæ¥ï¼šrun_strategy_on_boot å†…ä¸¥ç¦è®¿é—®æœªæ¥è¡Œ
# 6) â€œåç»§è¡Œâ€ç»Ÿä¸€å®šä¹‰ï¼šç´§éšæŠ•æ”¾ç‚¹çš„åç»§è¡Œï¼ˆä¸è·³è¿‡çŠ¶æ€ T ä½ç§»é›¶åå·®ï¼‰
# 7) å•è¾¹/åŒè¾¹ï¼šå‰ 9 å£åˆ†ç±»ï¼›å•è¾¹å¼±ç´¯è®¡ >=3 è½¬åŒè¾¹ï¼›äº¤æ˜“æ¬¡æ•°é™åˆ¶è§æ¨¡æ¿æ–‡æ¡£
#
# æ³¨æ„ï¼šæœªæ¥æ–°å¢/ä¿®æ”¹ç­–ç•¥ï¼Œåªæ”¹ run_strategy_on_boot(records) å†…éƒ¨é€»è¾‘
# ============================================================

# ============================================================
# ç»“æœæ˜ å°„è¡¨ï¼šå·²å®Œæˆ BPT å…¨é˜¶è„±æ•ï¼Œç‰©ç†åŒ¹é…å®éªŒå®¤æ ‡å‡†åŒ– CSV
# ============================================================
MAP_RESULT = {"B": "B", "P": "P", "T": "T"}


def map_result(v):
    if v is None:
        return None
    s = str(v).strip()
    if s in MAP_RESULT:
        return MAP_RESULT[s]
    s2 = s.upper()
    if s2 in MAP_RESULT:
        return MAP_RESULT[s2]
    return None


# ------------------------------------------------------------
# å·¥å…·ï¼šå®‰å…¨è¯»å– float / intï¼ˆåªè¯»ï¼Œä¸è®¡ç®—ï¼‰
# ------------------------------------------------------------
RATE_MISSING_RAW_INPUT = 0
RATE_PARSE_FAIL_INPUT = 0
RATE_INVALID_RAW = 0  # rate_raw æ— æ•ˆ(None)è®¡æ•°
RATE_INVALID_BUCKET = 0  # å˜åŒ–ç‡åˆ†æ¡¶=æ— æ•ˆ è®¡æ•°
RATE_INVALID_ASSERT_ON = True  # æ— æ•ˆè®¡æ•°ä¸€è‡´æ€§æ–­è¨€å¼€å…³ï¼ˆå»ºè®®ä¿æŒTrueï¼‰
MEAN_MISSING_RAW_INPUT = 0
MEAN_PARSE_FAIL_INPUT = 0


def safe_float(v, default=None, *, kind="GEN"):
    """å®‰å…¨è§£æ floatï¼šæ°¸ä¸å´©æºƒï¼›ç¼ºå¤±/ä¸å¯è§£æ -> Noneï¼Œå¹¶è®¡æ•°ï¼ˆè¡¥ä¸Bï½œé”æ­»ï¼‰"""
    global RATE_MISSING_RAW_INPUT, RATE_PARSE_FAIL_INPUT, MEAN_MISSING_RAW_INPUT, MEAN_PARSE_FAIL_INPUT
    if _is_raw_missing(v):
        if kind == "RATE":
            RATE_MISSING_RAW_INPUT += 1
        elif kind == "MEAN":
            MEAN_MISSING_RAW_INPUT += 1
        return default
    try:
        return float(v)
    except Exception:
        if kind == "RATE":
            RATE_PARSE_FAIL_INPUT += 1
        elif kind == "MEAN":
            MEAN_PARSE_FAIL_INPUT += 1
        return default


def _is_raw_missing(x):
    if x is None:
        return True
    s = str(x).strip().lower()
    return (s == "" or s == "none" or s == "nan")


def safe_int(v, default=0):
    try:
        if v is None or v == "":
            return default
        return int(float(v))
    except Exception:
        return default


# ------------------------------------------------------------
# 1) æ•°æ®åŠ è½½ï¼ˆå›ºå®šï¼‰
# ------------------------------------------------------------
# ------------------------------------------------------------
# 0) åˆ—è¯†åˆ«ä¸æ˜ å°„ï¼ˆå›ºå®šï½œåªè¯»ï¼‰
# ------------------------------------------------------------
def _norm_key(k):
    return str(k).strip().lower() if k is not None else ""


def _first_hit(keys, candidates):
    key_norm = {_norm_key(k): k for k in keys}
    for c in candidates:
        cc = _norm_key(c)
        if cc in key_norm:
            return key_norm[cc]
    return None


def detect_columns(row0):
    """
    è¾“å…¥ï¼šrow0ï¼ˆDictReader è¯»åˆ°çš„ä¸€è¡Œ dictï¼‰
    è¾“å‡ºï¼šcol_batch, col_end, col_result, col_diff, col_rate, col_mean

    é´è¾¹ç•Œå£å¾„ï¼ˆé”æ­»ï¼‰ï¼š
    - æ‰¹æ¬¡/é´å·ï¼šSub-Batch
    - é´ç»“æŸï¼šé´ç»“æŸï¼ˆä»…æœ€åä¸€å£ä¸º1ï¼Œå…¶ä½™ä¸º0ï¼›è‹¥ç¼ºå¤±/ä¸ä¸€è‡´åˆ™æŠ¥é”™ï¼‰
    """
    keys = list(row0.keys()) if isinstance(row0, dict) else []

    # Sub-Batchï¼ˆé´å·/æ‰¹æ¬¡å·ï¼‰
    col_batch = _first_hit(keys,
                           ["Sub-Batch", "sub-batch", "sub_batch", "subbatch", "æ‰¹æ¬¡", "æ‰¹æ¬¡å·", "batch", "Batch"])
    # é´ç»“æŸ
    col_end = _first_hit(keys, ["é´ç»“æŸ", "shoe_end", "shoe end", "end", "End", "ç»“æŸ", "boot_end", "BootEnd"])

    # ç»“æœåˆ—ï¼šå¸¸è§ Exhaustionï¼ˆå€¼ä¸ºB/P/Tï¼‰
    col_result = _first_hit(keys, ["Exhaustion", "exhaustion", "ç»“æœ", "result", "Result", "Outcome", "outcome"])

    # ç‚¹å·®/å˜åŒ–ç‡/å‡å·®ï¼ˆæ”¯æŒ 2/M3ï¼‰
    col_diff = _first_hit(keys, ["ç‚¹å·®", "diff", "Diff", "spread", "Spread", "delta", "Delta"])
    col_rate = _first_hit(keys, ["å˜åŒ–ç‡", "rate", "Rate", "roc", "ROC", "r", "R", "2"])
    col_mean = _first_hit(keys, ["å‡å·®", "mean", "Mean", "avg", "Avg", "average", "Average", "M3", "m3"])

    return col_batch, col_end, col_result, col_diff, col_rate, col_mean


# ==========================
# å…³é”®å‡½æ•°æºç å“ˆå¸Œï¼ˆsha256ï½œé”æ­»ï¼‰
# ==========================
def _print_source_hashes():
    """
    æ‰“å°å…³é”®å‡½æ•°æºç  sha256ï¼ˆé”æ­»ï¼‰ï¼š
    - ä»»æ„å‡½æ•°ç¼ºå¤±/æºç ä¸å¯å¾—/è¢«åŒ…è£¹/è¿è¡Œæ€æ›¿æ¢é£é™©ï¼šç›´æ¥ raise
    - æºç ä¸­å‡ºç° exec/eval/compile ç­‰é«˜å±å­—æ ·ï¼šç›´æ¥ raise
    """
    computed = {}
    global _SOURCE_HASHES_PRINTED
    targets = [
        "secure_read_metric",
        "secure_write_star_snapshot",
        "write_star_snapshot",
        "phase_transition",
        "advance_one_row",
        "run_strategy_on_boot",
        "load_all_boots",
        "_audit_forbid_idx_offset",
        "_audit_structure_slot_integrity",
    ]

    _audit_log("ã€SOURCE_HASHESã€‘")
    for name in targets:
        fn = globals().get(name)
        if not callable(fn):
            raise RuntimeError(f"SELF_AUDIT_FAIL: MISSING_FUNC:{name}")

        code = getattr(fn, "__code__", None)
        if code is None:
            raise RuntimeError(f"SELF_AUDIT_FAIL: NO_CODEOBJ:{name}")

        try:
            fn_file = os.path.abspath(code.co_filename)
            this_file = os.path.abspath(__file__)
            if fn_file != this_file:
                raise RuntimeError(f"SELF_AUDIT_FAIL: FUNC_FILE_MISMATCH:{name}:{fn_file}")
        except Exception as e:
            raise RuntimeError(f"SELF_AUDIT_FAIL: FUNC_FILE_CHECK_ERROR:{name}:{e}")

        try:
            s = inspect.getsource(fn)
        except Exception as e:
            raise RuntimeError(f"SELF_AUDIT_FAIL: GETSOURCE_FAIL:{name}:{e}")

        # é«˜å±å…³é”®å­—ï¼ˆç¦æ­¢ï¼‰
        bad_tokens = ["exec(", "eval(", "compile(", "types.FunctionType", "__import__(", "importlib"]
        for t in bad_tokens:
            if t in s:
                raise RuntimeError(f"SELF_AUDIT_FAIL: BAD_TOKEN:{name}:{t}")

        h = hashlib.sha256(s.encode("utf-8")).hexdigest()
        computed[name] = h
        loc = len(s.splitlines())
        _audit_log(f"{name} : {h} : loc={loc}")
    # åŸºåº•æŒ‡çº¹ç»‘å®šï¼šå¯¹ç…§ EXPECTED_SOURCE_HASHESï¼ˆé”æ­»ï¼‰
    if EXPECTED_SOURCE_HASHES:
        mism = []
        for k, exp in EXPECTED_SOURCE_HASHES.items():
            got = computed.get(k)
            if got is None or got != exp:
                mism.append((k, exp, got))
        if mism:
            head = mism[0]
            msg = f"BASELINE_HASH_MISMATCH: {head[0]} exp={str(head[1])[:12]} got={str(head[2])[:12]}"
            if ENFORCE_BASELINE_HASH:
                raise RuntimeError(msg)
            elif WARN_BASELINE_HASH:
                _audit_log("WARN:" + msg)
            else:
                pass

    _SOURCE_HASHES_PRINTED = True


# ==========================
# æ­£å€¼è§¦å‘è‡ªå®¡é—¸é—¨ï¼ˆæ—¶é—´ç®¡ç†å±€ï½œé”æ­»ï¼‰
# ==========================
def SELF_AUDIT_GATE(final_metrics):
    """
    è§¦å‘æ¡ä»¶ï¼šTotal>0 æˆ– Avg>0ï¼ˆç”±å¼€å…³æ§åˆ¶ï¼‰
    å¤±è´¥ç­–ç•¥ï¼šä»»ä½•ä¸€æ¡ä¸æ»¡è¶³ï¼Œæ‰“å°æœ€å°è¯æ®å raise ç»ˆæ­¢ï¼ˆç¦æ­¢åé”™ï¼‰
    """

    def _fail(item_no, evidence):
        if not SILENT_MODE:
            print("=== æ­£å€¼è§¦å‘è‡ªå®¡ ===")
        print(f"Trigger: Total={final_metrics.get('total_profit')} | Avg={final_metrics.get('avg_profit')}")
        print("SELF_AUDIT=FAILâŒ")
        print(f"è§¦å‘çš„æœ€å°åˆæ ¼çº¿æ¡ç›®ç¼–å·={item_no}")
        print(f"å‘½ä¸­æœ€å°è¯æ®ç‰‡æ®µæ‘˜è¦ï¼š{evidence}")
        _raise_guard(code="SELF_AUDIT_FAIL", rule_id=item_no, phase="DONE", msg=f"SELF_AUDIT_FAIL item={item_no}",
                     evidence=reason, exit_code=3)

    # B) äº¤ä»˜å¯å®¡è¾“å‡ºé”æ­»ï¼ˆé¦–å±è¦ç´ æ˜¯å¦å·²æ‰“å°ï¼‰
    if not _WATERMARK_PRINTED:
        _fail(1, "é¦–å±æ°´å°æœªæ‰“å°ï¼šWATERMARK_TEXT")
    if not _PROOF_BLOCK_PRINTED:
        _fail(2, "ç¼ºå¤±ã€å¼ºåˆ¶è‡ªè¯è¾“å‡ºã€‘å—ï¼šPROOF_BLOCK_PRINTED=0")
    if not _SELFTEST_PASSED:
        _fail(3, "ç¡¬æ³¨å…¥è‡ªæ£€æœªé€šè¿‡ï¼šSELFTEST_PASSED=0")
    if not _SOURCE_HASHES_PRINTED:
        _fail(4, "ç¼ºå¤±ã€SOURCE_HASHESã€‘å“ˆå¸Œæ¸…å•ï¼šSOURCE_HASHES_PRINTED=0")

    # C) é´çº§ç¦åŒºä¸‹æ³¨ï¼ˆå¿…é¡»ä¸º 0ï¼‰
    if final_metrics.get("bet_in_forbidden_seen", 0) != 0:
        _fail(5, f"BET_IN_FORBIDDEN_SEEN={final_metrics.get('bet_in_forbidden_seen')}")

    # A) è¡¨å¤´/è¯­ä¹‰é”æ­»ï¼ˆPP/BB æ’ç­‰å¼å¿…é¡» 0 å¤±é…ï¼‰
    if final_metrics.get("ppbb_mismatch", 0) != 0:
        _fail(6,
              f"PPBB_MISMATCH={final_metrics.get('ppbb_mismatch')} | EVIDENCE={final_metrics.get('ppbb_first_evidence')}")

    # C) æ ¸å¿ƒè®¡æ•°é—­ç¯
    entry = int(final_metrics.get("entry", 0) or 0)
    match = int(final_metrics.get("match", 0) or 0)
    mismatch = int(final_metrics.get("mismatch", 0) or 0)
    brk = int(final_metrics.get("break", 0) or 0)
    stop = int(final_metrics.get("stop", 0) or 0)
    zero = int(final_metrics.get("zero", 0) or 0)
    if entry != (match + mismatch + brk + stop + zero):
        _fail(7,
              f"æ’ç­‰å¼é—­ç¯å¤±è´¥ï¼šEntry={entry} != Match({match})+Mismatch({mismatch})+Break({brk})+Stop({stop})+Zero({zero})")

    # PASS
    if not SILENT_MODE:
        print("=== æ­£å€¼è§¦å‘è‡ªå®¡ ===")
    trig = []
    if final_metrics.get("trigger_total"): trig.append("Total>0")
    if final_metrics.get("trigger_avg"): trig.append("Avg>0")
    print("Trigger:", " or ".join(trig) if trig else "N/A")
    print("SELF_AUDIT=PASSâœ…")


def _print_header_mapping_once(row0, cols):
    """è¡¨å¤´è¯†åˆ«è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡ï¼›ç»ä¸å½±å“ä¸»æµç¨‹ã€‚"""
    global _HEADER_MAPPING_PRINTED
    if _HEADER_MAPPING_PRINTED:
        return
    _HEADER_MAPPING_PRINTED = True
    # é™é»˜æ¨¡å¼ï¼šä¸æ‰“å°ï¼Œä½†ä»å®Œæˆè¡¨å¤´è¯†åˆ«ä¸åç»­æµç¨‹
    if SILENT_MODE:
        return

    try:
        sample_row = row0 if isinstance(row0, dict) else {}

        col_batch, col_end, col_result, col_diff, col_rate, col_mean = cols

        print("==================================================")
        print("è¡¨å¤´è¯†åˆ«ï¼ˆè‡ªè¯ï½œä¸€æ¬¡æ€§æ‰“å°ï¼‰")
        print("æ‰¹æ¬¡(Sub-Batch) ->", col_batch)
        print("é´ç»“æŸ ->", col_end)
        print("ç»“æœ ->", col_result)
        print("ç‚¹å·® ->", col_diff)
        print("å˜åŒ–ç‡ ->", col_rate)
        print("å‡å·® ->", col_mean)

        # æ ·ä¾‹è¡Œï¼šåªå±•ç¤ºå‰12ä¸ªé”®
        d = {}
        show_keys = list(sample_row.keys())[:12]
        for k in show_keys:
            d[k] = sample_row.get(k)
        print("æ ·ä¾‹è¡Œ(åŸå§‹):", d)
        print("==================================================")
    except Exception as e:
        print("âš  è¡¨å¤´è‡ªè¯æ‰“å°å¤±è´¥ï¼ˆä¸å½±å“è¿è¡Œï¼‰:", str(e))


def boot_filter(records):
    # é´çº§å®Œæ•´æ€§ï¼šä¸å­˜åœ¨ä¸è¶³ 9 å£çš„é´ï¼›è‹¥å‘ç°åˆ™æŠ¥é”™å¹¶è¾“å‡ºè¯´æ˜ï¼ˆé”æ­»ï¼‰
    if records is None or len(records) < 9:
        # è¯æ®åªéœ€æ‰“å°ä¸€æ¬¡ï¼šæ–‡ä»¶|Sub-Batch|idxï¼ˆè‹¥ç¼ºå¤±åˆ™å°½é‡è¾“å‡ºå·²æœ‰ä¿¡æ¯ï¼‰
        f = None
        sb = None
        last_idx = None
        try:
            if records:
                f = records[0].get("file")
                sb = records[0].get("sub_batch")
                last_idx = records[-1].get("idx")
        except Exception:
            pass
        print("âŒâŒâŒ é´çº§å®Œæ•´æ€§å¤±è´¥ï¼šä¸è¶³9å£ | æ–‡ä»¶|Sub-Batch|idx =", f, sb, last_idx)
        raise RuntimeError("é´çº§å®Œæ•´æ€§å¤±è´¥ï¼šä¸è¶³9å£")
    return True


# ------------------------------------------------------------
# 3) å•æ‰¹æ¬¡ç­–ç•¥å…¥å£ï¼ˆåªå…è®¸æ”¹è¿™é‡Œï¼‰
# ------------------------------------------------------------
# ==========================
# å•æ‰¹æ¬¡ç­–ç•¥å…¥å£ï¼ˆNode 4 ä¿®æ­£ï¼šENTRY_ROW è¯­ä¹‰ç»Ÿä¸€ï¼‰
# ==========================
def run_strategy_on_boot(records):
    global BET_IN_FORBIDDEN_SEEN
    """å•é´æ‰§è¡Œï¼šç»“æ„->â­(DECISION)->æ‰§è¡Œæ¨è¿›(EXECUTE/SETTLE)ã€‚

    Node 4 ä¿®æ­£ï¼š
      - ENTRY_ROW è¯­ä¹‰ç»Ÿä¸€ï¼š
        * éå»¶è¿Ÿç»“æ„ï¼šENTRY_ROW = â­ å½“è¡Œ
        * å»¶è¿ŸBç»“æ„ï¼šENTRY_ROW = ğŸ¯ å½“å£
      - secure_write_star_snapshot åªèƒ½åœ¨ ENTRY_ROW è°ƒç”¨
      - ğŸ‘€ è¡Œç¦æ­¢è¯»å–ä»»ä½•æŒ‡æ ‡

    Node 2 ä¿®æ­£ï¼š
      - å½»åº•ç§»é™¤ metrics_cache
      - å½»åº•ç§»é™¤ last_settled_nonT_idx
      - é˜¶æ®µå¿«ç…§ç”Ÿæˆé€»è¾‘æš‚æ—¶ç½®ç©ºï¼ˆç­‰å¾… Node 3 é‡æ„ï¼‰
    """
    if not records or not STRUCT_SCAN:
        return None

    # 0) ç»“æ„åè¦†ç›–ï¼ˆç”±é”šç‚¹002æä¾›ï¼›ä»…åˆ‡ç»“æ„ï¼Œä¸å‚ä¸ä»»ä½•æ‰«æ/ä¸‹æ³¨é€»è¾‘ï¼‰
    if not globals().get("_STRUCT_OVERRIDE_APPLIED", False):
        _ov = globals().get("STRUCT_NAME_OVERRIDE", "")
        if isinstance(_ov, str):
            _ov = _ov.strip()
        else:
            _ov = ""
        if _ov:
            if _ov not in STRUCT_VARIANTS:
                raise RuntimeError(f"âŒ ç»“æ„ä¸å­˜åœ¨ï¼š{_ov}ï¼ˆSTRUCT_NAME_OVERRIDEï¼‰")
            globals()["ACTIVE_STRUCT_NAME"] = _ov
            globals()["STRUCT_CONFIG_TEXT"] = STRUCT_VARIANTS[_ov]
        globals()["_STRUCT_OVERRIDE_APPLIED"] = True

    # 0.5) æ‰§è¡Œ/å¿«ç…§é“¾è·¯è¦†ç›–ï¼ˆç”±é”šç‚¹002æä¾›ï¼›ä»…åˆ‡ profileï¼Œä¸å‚ä¸ä»»ä½•æ‰«æ/ä¸‹æ³¨é€»è¾‘ï¼‰
    if not globals().get("_CHAIN_PROFILE_OVERRIDE_APPLIED", False):
        # EXEC_PROFILEï¼ˆç©º=é»˜è®¤ï¼‰
        _ep = globals().get("EXEC_PROFILE_OVERRIDE", "")
        if isinstance(_ep, str):
            _ep = _ep.strip()
        else:
            _ep = ""
        if not _ep:
            _ep = globals().get("DEFAULT_EXEC_PROFILE", "MARTIN_1248")
        if "EXEC_PROFILES" not in globals() or _ep not in globals().get("EXEC_PROFILES", {}):
            raise RuntimeError(f"âŒ EXEC_PROFILE ä¸å­˜åœ¨ï¼š{_ep}")

        # SNAP_PROFILEï¼ˆç©º=é»˜è®¤ï¼‰
        _spn = globals().get("SNAP_PROFILE_OVERRIDE", "")
        if isinstance(_spn, str):
            _spn = _spn.strip()
        else:
            _spn = ""
        if not _spn:
            _spn = globals().get("DEFAULT_SNAP_PROFILE", "L4_ONLY")
        if "SNAP_PROFILES" not in globals() or _spn not in globals().get("SNAP_PROFILES", {}):
            raise RuntimeError(f"âŒ SNAP_PROFILE ä¸å­˜åœ¨ï¼š{_spn}")

        globals()["_ACTIVE_EXEC_PROFILE_NAME"] = _ep
        globals()["_ACTIVE_SNAP_PROFILE_NAME"] = _spn

        # åº”ç”¨ SNAP profile åˆ°å†»ç»“å‚æ•°ï¼ˆTARGET_STAGE/ENABLE_L1..L5ï¼‰
        _sp_cfg = globals()["SNAP_PROFILES"][_spn]
        globals()["TARGET_STAGE"] = _sp_cfg.get("TARGET_STAGE", globals().get("TARGET_STAGE", "L4"))
        globals()["ENABLE_L1"] = int(_sp_cfg.get("ENABLE_L1", globals().get("ENABLE_L1", 0)))
        globals()["ENABLE_L2"] = int(_sp_cfg.get("ENABLE_L2", globals().get("ENABLE_L2", 0)))
        globals()["ENABLE_L3"] = int(_sp_cfg.get("ENABLE_L3", globals().get("ENABLE_L3", 0)))
        globals()["ENABLE_L4"] = int(_sp_cfg.get("ENABLE_L4", globals().get("ENABLE_L4", 1)))
        globals()["ENABLE_L5"] = int(_sp_cfg.get("ENABLE_L5", globals().get("ENABLE_L5", 0)))

        # è‡ªè¯æ‰“å°ï¼ˆåªæ‰“å°ä¸€æ¬¡ï¼‰
        if not globals().get("_CHAIN_PROFILE_PRINTED", False):
            print(f"EXEC_PROFILE={_ep}")
            print(f"SNAP_PROFILE={_spn}")
            globals()["_CHAIN_PROFILE_PRINTED"] = True

        globals()["_CHAIN_PROFILE_OVERRIDE_APPLIED"] = True

    # ğŸ“Œ æŠ½æ ·å…œåº•ï¼šæ¯é´è‡³å°‘ç•™ä¸€æ¡å¯å®šä½ï¼ˆä¸å‚ä¸é€»è¾‘ï¼‰
    try:
        _sample_probe_fallback_update(
            file_name=records[0].get("file"),
            sub_batch=records[0].get("sub_batch"),
            idx=1,
        )
    except Exception:
        pass

    phase = "SCAN"
    decision_used = False

    # Node 2: ç§»é™¤ metrics_cache åˆå§‹åŒ–
    # metrics_cache = [] ... (DELETED)

    # 1) ç»“æ„æ‰«æ
    # Node 1: Pass records wrapped in ScanGuardRow to ensure physical invisibility of metrics during scan
    records_for_scan = [ScanGuardRow(r) for r in records]
    st, star_idx, strong_side, struct_info = scan_structure(records_for_scan)
    if st != "STRUCT_OK":
        return None

    entry = 1
    match = 0
    mismatch = 0
    stop = 0
    exhaustion = 0
    profit = 0.0

    # 2) DECISIONï¼šä»…â­è¡Œå†™å¿«ç…§
    phase = phase_transition(phase, "DECISION")
    decision_used = True

    # Node 4: ENTRY_ROW è¯­ä¹‰ç»Ÿä¸€
    # éå»¶è¿Ÿç»“æ„ï¼šENTRY_ROW = â­ å½“è¡Œ (star_idx)
    # å»¶è¿ŸBç»“æ„ï¼šENTRY_ROW = ğŸ¯ å½“å£ (target_idx) - æš‚æœªå®ç°å»¶è¿ŸBï¼Œç›®å‰ ENTRY_ROW = star_idx
    entry_row_idx = star_idx

    star_row = records[entry_row_idx]
    star_seen = star_row.get('seen_all') or (entry_row_idx + 1)
    star_rr = star_row.get("r")
    star_boot_id = star_row.get("boot_id", star_row.get("shoe_id"))
    if star_boot_id is None:
        raise RuntimeError("BOOT_ID_MISSING_AT_STAR")

    # å˜åŒ–ç‡ç¡¬é—¸é—¨äºŒä½ç ï¼šæŠ•æ”¾ç‚¹ä¸Šä¸€æ¡ç»“æœ + æŠ•æ”¾ç‚¹è¿™ä¸€æ¡ç»“æœï¼ˆå«Tåˆ™æ— æ•ˆï¼‰
    try:
        prev_rr = records[entry_row_idx - 1].get("r") if entry_row_idx > 0 else None
    except Exception:
        prev_rr = None
    exh_pair = (str(prev_rr) + str(star_rr)) if (prev_rr in ("B", "P") and star_rr in ("B", "P")) else (
        str(prev_rr) + str(star_rr) if (prev_rr in ("B", "P", "T") and star_rr in ("B", "P", "T")) else None)

    # Node 4: secure_write_star_snapshot åªèƒ½åœ¨ ENTRY_ROW è°ƒç”¨
    star_snap = secure_write_star_snapshot(
        star_row, phase,
        seen_all=star_seen, rr=star_rr, boot_id=star_boot_id, star_idx=entry_row_idx,
        star_snapshot_is_none=True, exh_pair=exh_pair
    )

    # ===== äº‹é¡¹4å‡çº§ï¼ˆä½ è¦çš„â€œåƒL4ä¸€æ ·â€ï¼‰ï¼šL2/L3 åªå…è®¸åœ¨ L1 å†³ç­–ä¹‹åç”Ÿæ•ˆ =====
    # æŠ¤ç…§ï¼šåªç”¨äºâ€œæ˜¯å¦å…è®¸L2/L3å¯ç”¨â€çš„ç¡¬é˜€é—¨ï¼Œä¸æ”¹å˜ä»»ä½•ç­–ç•¥ç»“æœ
    globals()["_L1_DECISION_DONE"] = 1
    globals()["_L1_DECISION_GUARD"] = {
        "boot_id": star_boot_id,
        "file": star_row.get("file"),
        "sub_batch": star_row.get("sub_batch"),
        "star_idx": entry_row_idx,
        "seen_all": star_seen,
    }

    # ä»…ç”¨äºâ€œç¼ºå¤±æ ·ä¾‹ TopNâ€è‡ªè¯ï¼šç»‘å®šåŸå§‹å­—ç¬¦ä¸²ï¼ˆä¸å‚ä¸é€»è¾‘ï¼‰
    _bind_raw_text_fields(star_snap, star_row.get("rate_raw"), star_row.get("mean_raw"))
    # 3) EXECUTEï¼šå»æŒ‡æ ‡åŒ–ï¼ˆæ ¹æºç­ç«ï¼‰
    phase = phase_transition(phase, "EXECUTE")
    guard_future_rows(records, 0)

    # ==========================
    # ==========================
    # ==========================
    # ç‚¹ä½å£å¾„ï¼ˆé”æ­»ï¼‰ï¼šæ‰«æâ™» / è§¦å‘â™» / ğŸ¯(N_prebet)
    #   - æ‰«æâ™»ï¼šç»“æ„å‘½ä¸­ç‚¹ï¼ˆç”¨äºå®¡è®¡/å®šä½ï¼‰
    #   - è§¦å‘â™»ï¼šç›‘æµ‹å¯åŠ¨ç‚¹ï¼ˆå½“å‰=æ‰«æâ™»ï¼›åç»­å»¶è¿ŸæŠ•æ”¾ç­–ç•¥å¯æ”¹ï¼‰
    #   - ğŸ¯(N_prebet)ï¼šäººç±»å®é™…å–å€¼/ä¸‹æ³¨ç‚¹=å–å€¼ç‚¹ï¼ˆå½“å‰=è§¦å‘â™»ï¼›ğŸ“ŒæŠ½æ ·å–æ­¤ç‚¹ä½ï¼‰
    #   - ç»“ç®—å£Kï¼šä» ğŸ¯_idx+1 èµ·é¦–ä¸ªéTï¼ˆåªç”¨äºç»“ç®—ï¼Œä¸æ‰“å°ã€ä¸å‚ä¸å†³ç­–ï¼‰
    # ==========================
    scan_cycle_seen_all = getattr(star_snap, "seen_all", None)  # æ‰«æâ™»
    trigger_cycle_seen_all = scan_cycle_seen_all  # è§¦å‘â™»ï¼ˆå½“å‰ç­‰äºæ‰«æâ™»ï¼‰
    n_prebet_seen_all = trigger_cycle_seen_all  # ğŸ¯ = N_prebetï¼ˆäººç±»å®é™…å–å€¼/ä¸‹æ³¨ç‚¹ï¼‰
    tgt_seen_all = n_prebet_seen_all  # ğŸ¯ï¼ˆç»Ÿä¸€åˆ«åï¼Œåç»­åªç”¨ğŸ¯ï¼‰
    bet_star_seen_all = tgt_seen_all  # å…¼å®¹å­—æ®µï¼šæŠ•æ”¾ç‚¹=ğŸ¯ï¼ˆå–å€¼ç‚¹ï¼‰

    # ğŸ¯ç¡¬é—¸é—¨ï¼šğŸ¯åæ ‡å¿…é¡»å­˜åœ¨ã€å¿…é¡»ä¸ºæ­£æ•´æ•°ï¼›å¦åˆ™ç›´æ¥ä¸­æ–­ï¼ˆç»“æ„å®šä½ä½œåºŸï¼‰
    try:
        _n = int(tgt_seen_all)
    except Exception:
        raise RuntimeError(f"âŒ TGT_N_INVALID: tgt_seen_all={tgt_seen_all}")
    if _n <= 0:
        raise RuntimeError(f"âŒ TGT_N_NONPOSITIVE: tgt_seen_all={tgt_seen_all}")

    # ğŸ¯ç¡¬é—¸é—¨ï¼šğŸ¯å¿…é¡»è½åœ¨éTï¼ˆåªç”¨ rrï¼Œä¸è¯»æŒ‡æ ‡ï¼Œé¿å…è§¦å‘æ‰§è¡Œæ®µæŒ‡æ ‡é—¨ç¦ï¼‰
    _rr = getattr(star_snap, "rr", None)
    if _rr not in ("B", "P"):
        raise RuntimeError(f"âŒ TGT_ON_T_OR_INVALID_R: rr={_rr} | N={_n}")

    # ğŸ¯å¿…é¡»å¯æ‰“å°ï¼ˆä¸å…è®¸åé”™ï¼‰ï¼šæ‰“å°å¤±è´¥=å®šä½é“¾è·¯ä¸å¯ä¿¡=ç›´æ¥ä¸­æ–­
    _fn = star_row.get("file") or records[0].get("file")
    _sb = star_row.get("sub_batch") or records[0].get("sub_batch")
    if not _fn or _sb is None:
        raise RuntimeError(f"âŒ TGT_PRINT_MISSING_CTX: file={_fn} sub_batch={_sb} N={_n}")

    _sample_probe_update(
        file_name=_fn,
        sub_batch=_sb,
        idx=_n,
        boot_id=star_boot_id,
    )

    # æ¨è¿›å™¨ï¼ˆå”¯ä¸€å…è®¸çš„â€œåç»§è¡Œâ€æ–¹å¼ï¼‰
    # 4) æ‰§è¡Œé“¾è·¯ï¼ˆç”± EXEC_PROFILE æ§åˆ¶ï¼‰
    target_side = strong_side
    _epn = globals().get("_ACTIVE_EXEC_PROFILE_NAME", globals().get("DEFAULT_EXEC_PROFILE", "MARTIN_1248"))
    _ep_cfg = globals().get("EXEC_PROFILES", {}).get(_epn)
    if not isinstance(_ep_cfg, dict):
        raise RuntimeError(f"âŒ EXEC_PROFILE é…ç½®éæ³•ï¼š{_epn}")
    _mode = _ep_cfg.get("mode", "MARTIN_SEQ")
    if _mode != "MARTIN_SEQ":
        raise RuntimeError(f"âŒ EXEC_MODE æœªå¯ç”¨ï¼š{_mode}ï¼ˆprofile={_epn}ï¼‰")
    units = _ep_cfg.get("units", None)
    if not (isinstance(units, list) and units and all(isinstance(x, int) and x > 0 for x in units)):
        raise RuntimeError(f"âŒ EXEC_UNITS éæ³•ï¼š{_epn}")
    units = list(units)
    max_bet_n = len(units)
    bet_n = 1
    j = entry_row_idx
    # Node 2: ç§»é™¤ last_settled_nonT_idx
    # last_settled_nonT_idx = int(star_snap.idx) (DELETED)
    j = advance_one_row(j, records, phase=phase, boot_id=star_boot_id)

    is_settled = False
    trade_bust = 0
    snapshots = []

    stage_snaps = []
    stage_snap_profits = []
    snap_seq = 0
    while bet_n <= max_bet_n and j is not None:
        row = records[j]
        rr = row.get("r")
        if rr == "T":
            j = advance_one_row(j, records, phase=phase, boot_id=star_boot_id)
            continue

        # é´çº§é—¸é—¨ï¼šå®é™…è½æ³¨ç‚¹ä¸å¾—è½åœ¨ ç¦æŠ•åŒº(seen_all < N)ï¼ˆéTæ‰ç®—â€œå®é™…è½æ³¨ç‚¹â€ï¼‰
        boot_on, allow_from, _rawn = _get_boot_filter_effective()
        if boot_on and rr != "T":
            try:
                sa = int(row.get("seen_all"))
                if 1 <= sa < allow_from:
                    global BET_IN_FORBIDDEN_SEEN
                    BET_IN_FORBIDDEN_SEEN += 1
                    _raise_guard(code="BET_IN_FORBIDDEN_SEEN", rule_id=10, phase="EXECUTE", msg="ç¦åŒºä¸‹æ³¨",
                                 evidence=f"file={row.get('file')}|idx={row.get('idx')}|seen_all={row.get('seen_all')}")
            except RuntimeError:
                raise
            except Exception:
                pass

        # ä»…ä¿ç•™å…ƒä¿¡æ¯ï¼ˆä¸å«æŒ‡æ ‡ï¼‰
        snapshots.append({
            "bet_n": bet_n,
            "r": rr,
            "idx": row.get("idx"),
            "seen_all": row.get("seen_all"),
            "shoe_id": row.get("shoe_id"),
            "boot_id": row.get("boot_id", row.get("shoe_id")),
        })

        # Î”å£å¾„ï¼šstopç«¯å‡€å€¼å–â€œæœ¬æ³¨è½æ³¨å‰å·²å®ç°å‡€å€¼â€ï¼ˆé¿å…å›å¡«æˆé´å°¾æœ€ç»ˆå€¼ï¼‰

        profit_before = float(profit)

        u = units[bet_n - 1]
        if rr == target_side:
            # èµ¢
            profit += (u * 0.95 if target_side == "B" else u * 1.0)

            # Node 5: é˜¶æ®µå¿«ç…§ç”Ÿæˆï¼ˆä» star_snap å¤åˆ¶ï¼‰
            stage = f"L{bet_n}"
            if stage in _STAGE_LIST and _stage_enabled(stage):
                snap_seq += 1
                stage_snaps.append(
                    _make_stage_snap_from_star(
                        stage=stage,
                        star=star_snap,
                        rule_id="BASE",
                        snap_source=stage,
                        boot_id=star_boot_id,
                        snap_seq=snap_seq,
                        profit_to_here=profit_before,
                        settle_rr=rr,
                    )
                )
                stage_snap_profits.append(float(profit_before))

            match += 1
            is_settled = True
            break
        else:
            # è¾“
            profit -= u

            stage = f"L{bet_n}"
            if stage in _STAGE_LIST and _stage_enabled(stage):
                snap_seq += 1
                stage_snaps.append(
                    _make_stage_snap_from_star(
                        stage=stage,
                        star=star_snap,
                        rule_id="BASE",
                        snap_source=stage,
                        boot_id=star_boot_id,
                        snap_seq=snap_seq,
                        profit_to_here=profit_before,
                        settle_rr=rr,
                    )
                )
                stage_snap_profits.append(float(profit_before))

            # ===== Node16ï¼šL4=åéªŒå€™é€‰æ­¢æŸï¼ˆåªåœ¨ L3 å·²å¤±è´¥ã€å³å°†è¿›å…¥ L4 å‰ä¸€åˆ»è§¦å‘ï¼›ä¸å¾—å‰ç½®å¹²æ¶‰ L1/ğŸ¯ï¼‰=====
            next_bet_n = bet_n + 1
            if next_bet_n == 4 and _stage_enabled("L4"):
                sf = globals().get("_SHELL_FILTERS", None) if globals().get("_SHELL_ON", 0) == 1 else None

                # å£å¾„ï¼šL4 å…¨éƒ¨å–æ¶ˆå‹¾é€‰ => STOP_DISABLEDï¼ˆæ°¸ä¸æ­¢æŸï¼‰
                stop_enabled = False
                l4d = []
                l4r = []
                if isinstance(sf, dict):
                    l4d = sf.get("L4_ç‚¹å·®æ”¾è¡Œ", []) or []
                    l4r = sf.get("L4_å˜åŒ–ç‡æ”¾è¡Œ", []) or []
                    stop_enabled = (len(l4d) > 0 and len(l4r) > 0)

                if stop_enabled:
                    d4 = getattr(star_snap, "diff_bucket", None)
                    rv = getattr(star_snap, "rate_val", None)
                    r4 = _rate_bucket_for_stage("L4", rv)

                    if d4 is not None and r4 is not None:
                        if (str(d4) in {str(x) for x in l4d}) and (str(r4) in {str(x) for x in l4r}):
                            stop = 1

                            # è®°å½•ä¸€ä¸ª L4 é˜¶æ®µå¿«ç…§ï¼ˆå€™é€‰å‘½ä¸­ï¼›ä¸ä¸‹æ³¨ï¼›ä¸æ¶ˆè€—ä¸‹ä¸€å£ï¼‰
                            snap_seq += 1
                            stage_snaps.append(
                                _make_stage_snap_from_star(
                                    stage="L4",
                                    star=star_snap,
                                    rule_id="BASE",
                                    snap_source="L4",
                                    boot_id=star_boot_id,
                                    snap_seq=snap_seq,
                                    profit_to_here=float(profit),   # åˆ° L3 ä¸ºæ­¢å·²å®ç°äºæŸ
                                    settle_rr="STOP",
                                )
                            )
                            stage_snap_profits.append(float(profit))

                            is_settled = True
                            break

            bet_n += 1
            j = advance_one_row(j, records, phase=phase, boot_id=star_boot_id)
            if j is None:
                break
            rr = records[j]
            continue
            continue

    if not is_settled:
        mismatch += 1
        exhaustion += 1
        trade_bust = 1

    phase = phase_transition(phase, "DONE")

    return {
        "entry": entry,
        "match": match,
        "mismatch": mismatch,
        "break": exhaustion,
        "stop": stop,
        "profit": profit,
        "trade_bust": trade_bust,
        "boot_id": int(star_boot_id),
        "star_snap": star_snap,
        "snapshots": snapshots,
        "stage_snaps": stage_snaps,
        "stage_snap_profits": stage_snap_profits,
        "struct_status": st,
        "struct_expr": struct_info.get("struct_expr"),
        "struct_hash": struct_info.get("struct_hash"),
        "struct_strong": strong_side,
        "struct_star_idx": star_idx,
        "struct_fail_reason": struct_info.get("fail_reason"),
        "struct_forbidden_star_cnt": struct_info.get("forbidden_star_cnt", 0),
        "struct_forbidden_star_first_seen": struct_info.get("forbidden_star_first_seen"),
        "decision_used": 1 if decision_used else 0,
        "scan_cycle_seen_all": scan_cycle_seen_all,
        "trigger_cycle_seen_all": trigger_cycle_seen_all,
        "bet_star_seen_all": bet_star_seen_all,

    }


def _find_existing_col(row0: dict, candidates):
    """åœ¨è¡¨å¤´é‡ŒæŒ‰å€™é€‰åæ‰¾åˆ—ï¼ˆå¤§å°å†™ä¸æ•æ„Ÿï¼‰ã€‚æ‰¾ä¸åˆ°è¿”å› Noneã€‚"""
    if not isinstance(row0, dict):
        return None
    # ç›´æ¥åŒ¹é…
    for c in candidates:
        if c in row0:
            return c
    # å°å†™åŒ¹é…
    lower_map = {str(k).lower(): k for k in row0.keys()}
    for c in candidates:
        k = lower_map.get(str(c).lower())
        if k is not None:
            return k
    return None


def _to_int_strict(v):
    if v is None:
        raise RuntimeError("PPBB_PARSE_FAIL(None)")
    s = str(v).strip()
    if s == "" or s.lower() == "none":
        raise RuntimeError("PPBB_PARSE_FAIL(Empty/None)")
    # å…è®¸ "3.0" è¿™ç±»
    return int(float(s))


def _ppbb_identity_sample_check(rows, col_result, col_diff, fname):
    """ç‚¹å·®æ’ç­‰å¼ + ç»“æœæ˜ å°„æŠ½æ£€ï¼ˆé”æ­»è¯­ä¹‰ï¼šPP=é—²ç‚¹ï¼ŒBB=åº„ç‚¹ï¼‰ã€‚

    æŠ½æ£€ï¼š
      - ç‚¹å·® == (BB - PP)
      - éTï¼šBB>PP -> Bï¼›PP>BB -> Pï¼›Tï¼šBB==PP
    ä»»æ„ä¸ä¸€è‡´ï¼šraise å¹¶æ‰“å°æœ€å°è¯æ®ã€‚
    """
    global PPBB_CHECKED, PPBB_MISMATCH, PPBB_FIRST_EVIDENCE
    if not ENFORCE_PPBB_SEMANTICS:
        return

    if not rows:
        return

    row0 = rows[0] if isinstance(rows[0], dict) else {}
    col_bb = _find_existing_col(row0, ["BB", "åº„ç‚¹", "BANKER", "BPoint"])
    col_pp = _find_existing_col(row0, ["PP", "é—²ç‚¹", "PLAYER", "PPoint"])

    if col_bb is None or col_pp is None:
        raise RuntimeError(f"âŒâŒâŒ è¡¨å¤´ç¼ºå¤±ï¼šå¿…é¡»å­˜åœ¨ BB/PPï¼ˆåº„ç‚¹/é—²ç‚¹ï¼‰| æ–‡ä»¶={fname}")

    if col_result is None or col_diff is None:
        # ç»“æœ/ç‚¹å·®åˆ—ç¼ºå¤±ä¼šè¢«ä¸Šæ¸¸å¼ºåˆ¶æ‹¦æˆªï¼›è¿™é‡Œä¸é‡å¤
        return

    sample_n = min(len(rows), 200)
    for i in range(sample_n):
        r = rows[i]
        if not isinstance(r, dict):
            continue

        rr = (r.get(col_result) or "").strip()
        if rr not in ("B", "P", "T"):
            continue

        try:
            bb = _to_int_strict(r.get(col_bb))
            pp = _to_int_strict(r.get(col_pp))
            diff_val = _to_int_strict(r.get(col_diff))
        except Exception as e:
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"PARSE_FAIL | file={fname} | row={i + 2} | err={e}"
            print(f"âŒâŒâŒ ç‚¹å·®æ’ç­‰å¼æŠ½æ£€å¤±è´¥ï¼šæ— æ³•è§£æ | æ–‡ä»¶={fname} | è¡Œ={i + 2}")
            print(f"  BB={r.get(col_bb)} | PP={r.get(col_pp)} | ç‚¹å·®={r.get(col_diff)} | ç»“æœ={rr}")
            raise

        # 1) ç‚¹å·®æ’ç­‰å¼
        if diff_val != (bb - pp):
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"DIFF_MISMATCH | file={fname} | row={i + 2} | BB={bb} PP={pp} diff={diff_val}"
            print(f"âŒâŒâŒ ç‚¹å·®æ’ç­‰å¼ä¸ä¸€è‡´ | æ–‡ä»¶={fname} | è¡Œ={i + 2}")
            print(f"  BB={bb} | PP={pp} | ç‚¹å·®={diff_val} | (BB-PP)={bb - pp} | ç»“æœ={rr}")
            raise RuntimeError("PPBB_DIFF_IDENTITY_FAIL")

        # 2) ç»“æœæ˜ å°„ä¸€è‡´æ€§
        if rr == "B" and not (bb > pp):
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"RES_MISMATCH_B | file={fname} | row={i + 2} | BB={bb} PP={pp}"
            print(f"âŒâŒâŒ ç»“æœæ˜ å°„ä¸ä¸€è‡´(B) | æ–‡ä»¶={fname} | è¡Œ={i + 2}")
            print(f"  BB={bb} | PP={pp} | ç»“æœ={rr}")
            raise RuntimeError("PPBB_RESULT_IDENTITY_FAIL")
        if rr == "P" and not (pp > bb):
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"RES_MISMATCH_P | file={fname} | row={i + 2} | BB={bb} PP={pp}"
            print(f"âŒâŒâŒ ç»“æœæ˜ å°„ä¸ä¸€è‡´(P) | æ–‡ä»¶={fname} | è¡Œ={i + 2}")
            print(f"  BB={bb} | PP={pp} | ç»“æœ={rr}")
            raise RuntimeError("PPBB_RESULT_IDENTITY_FAIL")
        if rr == "T" and not (bb == pp):
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"RES_MISMATCH_T | file={fname} | row={i + 2} | BB={bb} PP={pp}"
            print(f"âŒâŒâŒ ç»“æœæ˜ å°„ä¸ä¸€è‡´(T) | æ–‡ä»¶={fname} | è¡Œ={i + 2}")
            print(f"  BB={bb} | PP={pp} | ç»“æœ={rr}")
            raise RuntimeError("PPBB_RESULT_IDENTITY_FAIL")

    PPBB_CHECKED += sample_n


def load_all_boots(csv_files):
    # boots: list of (meta, records)
    boots = []  # æ¯ä¸ªå…ƒç´ ï¼š({"file":..., "sub_batch":...}, [records...])
    boot_id_seq = 0  # å†…éƒ¨é€’å¢é´å·ï¼ˆç”¨äºboot_id/é‹å·ï¼‰

    print("æ£€æµ‹åˆ° CSV æ–‡ä»¶æ•°é‡:", len(csv_files))

    for i, fname in enumerate(csv_files, 1):
        # æ¯ä¸ª CSV æ–‡ä»¶å†… boot_id_seq ä» 1 é‡æ–°è®¡æ•°ï¼ˆæ–‡ä»¶å†…åºå·ï¼‰
        boot_id_seq = 0
        if i % 10 == 0:
            print(f"è¿›åº¦: å·²å¤„ç† {i}/{len(csv_files)} ä¸ªæ–‡ä»¶")

        rows = []
        for enc in ("utf-8", "utf-8-sig", "gbk", "gb18030"):
            try:
                with open(fname, "r", encoding=enc) as f:
                    rows = list(csv.DictReader(f))
                break
            except Exception:
                rows = []

        if not rows:
            continue

        col_batch, col_end, col_result, col_diff, col_rate, col_mean = detect_columns(rows[0])
        _print_header_mapping_once(rows[0], (col_batch, col_end, col_result, col_diff, col_rate, col_mean))
        _ppbb_identity_sample_check(rows, col_result, col_diff, fname)

        if col_batch is None or col_end is None:
            print("âŒâŒâŒ è¡¨å¤´ç¼ºå¤±ï¼šå¿…é¡»åŒæ—¶å­˜åœ¨ Sub-Batch ä¸ é´ç»“æŸ | æ–‡ä»¶ =", fname)
            raise RuntimeError("è¡¨å¤´ç¼ºå¤±ï¼šSub-Batch / é´ç»“æŸ")

        current_batch = None
        current_records = []
        seen_all = 0
        end_seen = 0

        def _finalize_boot():
            nonlocal boot_id_seq
            nonlocal current_batch, current_records, seen_all, end_seen
            if current_batch is None:
                return
            if not current_records:
                return

            # é´ç»“æŸä¸€è‡´æ€§ï¼šä»…æœ€åä¸€å£ä¸º1ï¼Œå…¶ä½™ä¸º0ï¼ˆé”æ­»ï¼‰
            if end_seen != 1:
                print("âŒâŒâŒ é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šé´ç»“æŸ=1æ¬¡æ•°!=1 | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch,
                      (current_records[-1].get("idx") if current_records else None))
                raise RuntimeError("é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šé´ç»“æŸ=1æ¬¡æ•°!=1")
            if safe_int(current_records[-1].get("shoe_end"), 0) != 1:
                print("âŒâŒâŒ é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæœ€åä¸€å£é´ç»“æŸ!=1 | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch,
                      current_records[-1].get("idx"))
                raise RuntimeError("é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæœ€åä¸€å£é´ç»“æŸ!=1")

            boot_id_seq += 1
            for rr in current_records:
                rr["shoe_id"] = boot_id_seq
                rr["boot_id"] = boot_id_seq
                rr["file_idx"] = i
            boots.append(
                ({"file": fname, "file_idx": i, "sub_batch": current_batch, "boot_id": boot_id_seq}, current_records))

            # reset
            current_batch = None
            current_records = []
            seen_all = 0
            end_seen = 0

        for row_i, r in enumerate(rows):
            batch = r.get(col_batch)

            # å­æ‰¹æ¬¡å¯åŠ¨
            if current_batch is None:
                current_batch = batch

            # Sub-Batch å˜æ›´å¿…é¡»ä¸é´ç»“æŸå¯¹é½ï¼ˆé”æ­»ï¼‰ï¼šæœªé‡åˆ°é´ç»“æŸ=1 ä¸å…è®¸å˜æ›´
            if batch != current_batch:
                print("âŒâŒâŒ é´è¾¹ç•Œå¤±è´¥ï¼šSub-Batch åœ¨é´ç»“æŸå‰å‘ç”Ÿå˜æ›´ | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch,
                      (current_records[-1].get("idx") if current_records else None))
                raise RuntimeError("é´è¾¹ç•Œå¤±è´¥ï¼šSub-Batch å˜æ›´æœªå¯¹é½é´ç»“æŸ")

            res_raw = r.get(col_result)
            res = map_result(res_raw)
            if res not in ("B", "P", "T"):
                # æ— æ³•æ˜ å°„çš„ä¸å…¥åº“ï¼ˆé”æ­»ï¼‰
                continue

            diff = safe_int(r.get(col_diff, 0), 0)
            rate_raw = (r.get(col_rate) if col_rate else None)
            mean_raw = (r.get(col_mean) if col_mean else None)
            rate = safe_float(rate_raw, None, kind="RATE") if col_rate else None
            mean = safe_float(mean_raw, None, kind="MEAN") if col_mean else None
            shoe_end = safe_int(r.get(col_end, 0), 0)

            seen_all += 1
            rec = {
                "idx": seen_all - 1,
                "seen_all": seen_all,
                "r": res,
                "diff": diff,
                "rate": rate,
                "mean": mean,
                "rate_raw": rate_raw,
                "mean_raw": mean_raw,
                "file": fname,
                "sub_batch": current_batch,
                "shoe_end": shoe_end,
            }
            current_records.append(rec)

            if shoe_end == 1:
                end_seen += 1
                _finalize_boot()

        # æ–‡ä»¶ç»“æŸï¼šè‹¥ä»æœ‰æœªå°å£çš„é´ â†’ æŠ¥é”™
        if current_batch is not None:
            if current_records:
                print("âŒâŒâŒ é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæ–‡ä»¶ç»“æŸä»æœªé‡åˆ°é´ç»“æŸ=1 | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch,
                      current_records[-1].get("idx"))
                raise RuntimeError("é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæ–‡ä»¶ç»“æŸæœªå°å£")

    print("æŒ‰ Sub-Batch + é´ç»“æŸ åˆ†é´å®Œæˆï¼Œé´æ€»æ•°:", len(boots))
    return boots


# ğŸ””ğŸ””ğŸ””å£³è¦†ç›–æ¨¡å—è¯»å–_FIXED_BEGIN
# --- å£³è¦†ç›–æ¨¡å—è¯»å–ï¼ˆå›ºå®šæ¨¡å—ï½œä¼˜å…ˆè¯»å–ï¼›ç¼ºå¤±åˆ™å›è½é»˜è®¤é”šç‚¹002ï¼‰ ---
# ç›®æ ‡ï¼š
# 1) è¯†åˆ«å£³ cfgï¼ˆå£³è¦†ç›–æ¨¡å—.txtï¼‰ï¼Œå¹¶åº”ç”¨ï¼šç»“æ„å / Né—¨æ§› / é“¾è·¯å¼€å…³->SNAP_PROFILE
# 2) æ³¨å…¥ _SHELL_FILTERS (Seté›†åˆ) ä¾›é”šç‚¹002é—¸é—¨ä½¿ç”¨
# 3) å‡å·®å·²åœç”¨ï¼šå‘ç°ä»»ä½•â€œå‡å·®/meanâ€ç›¸å…³ keyï¼Œç›´æ¥æŠ¥é”™åœæœº
# 4) ç¼ºå¤±å…³é”®æ”¾è¡Œé›†åˆæˆ–é›†åˆä¸ºç©ºï¼šç›´æ¥æŠ¥é”™åœæœº

import os

# åˆå§‹åŒ–å…¨å±€å˜é‡ (é»˜è®¤éå£³æ¨¡å¼)
globals()["_SHELL_ON"] = 0
globals()["_SHELL_FILTERS"] = None
globals()["_SHELL_CFG_USED_PATH"] = "NA"
globals()["_SHELL_CFG_CACHE"] = {}


def _shell_cfg__find_cfg_file():
    candidates = []
    try:
        candidates.append(os.path.dirname(os.path.abspath(__file__)))
    except Exception:
        pass
    try:
        candidates.append(os.getcwd())
    except Exception:
        pass

    seen = set()
    for d in candidates:
        if not d or d in seen: continue
        seen.add(d)
        fp = os.path.join(d, "å£³è¦†ç›–æ¨¡å—.txt")
        if os.path.isfile(fp): return fp
    return None


def _shell_cfg__read_and_parse(fp):
    with open(fp, "r", encoding="utf-8-sig") as f:
        raw = f.read()
    cfg = {}
    for line in raw.splitlines():
        line = line.strip()
        if not line or line.startswith("#"): continue
        parts = [p.strip() for p in line.split("|")]
        if len(parts) < 2: continue
        # key | v1 | v2 ...
        cfg[parts[0]] = [v for v in parts[1:] if v != ""]
    return cfg


def _shell_cfg__pick_snap_profile_by_links(cfg):
    if not isinstance(globals().get("SNAP_PROFILES"), dict): return None
    links = {}
    for i in (1, 2, 3, 4):
        k = f"é“¾è·¯å¼€å…³_L{i}"
        if k in cfg:
            val = str(cfg[k][0]).strip() if cfg[k] else "0"
            links[i] = 1 if val == "1" else 0
    if not links: return None

    target = "L4" if links.get(4) else "L3" if links.get(3) else "L2" if links.get(2) else "L1" if links.get(
        1) else None
    if not target: return None

    desired = {"TARGET_STAGE": target, "ENABLE_L1": links.get(1, 0), "ENABLE_L2": links.get(2, 0),
               "ENABLE_L3": links.get(3, 0), "ENABLE_L4": links.get(4, 0)}
    for name, spec in globals().get("SNAP_PROFILES", {}).items():
        if all(spec.get(k) == v for k, v in desired.items()): return str(name)
    return None


def _shell_cfg__apply():
    fp = _shell_cfg__find_cfg_file()
    if not fp: return  # æ— å£³æ–‡ä»¶ï¼Œæ¯ç‰ˆç›´è·‘

    cfg = _shell_cfg__read_and_parse(fp)
    if not cfg:
        raise RuntimeError(f"SHELL_LOAD_FAIL: å£³é…ç½®ä¸ºç©º | Path={fp}")

    # 0. å‡å·®ç¡¬ç¦
    for k in cfg.keys():
        if "å‡å·®" in k or "mean" in k.lower():
            raise RuntimeError("MEAN_DISABLED")

    # 1. ç‰ˆæœ¬æ ¡éªŒ
    ver_list = cfg.get("CFG_VERSION", [])
    ver = str(ver_list[0]).strip() if ver_list else ""
    if ver != "V6":
        raise RuntimeError(f"SHELL_VERSION_MISMATCH: Expected V6, Got {ver}")

    # 2. åŸºç¡€æ³¨å…¥
    if "ç»“æ„å" in cfg: globals()["STRUCT_NAME_OVERRIDE"] = str(cfg["ç»“æ„å"][0]).strip()
    if "Né—¨æ§›" in cfg: globals()["BOOT_BLOCK_N_OVERRIDE"] = str(cfg["Né—¨æ§›"][0]).strip()
    snap = _shell_cfg__pick_snap_profile_by_links(cfg)
    if snap: globals()["SNAP_PROFILE_OVERRIDE"] = snap

    # 3. æ¡¥æ¥æ³¨å…¥ (Filters) -> _SHELL_FILTERS
    filters = {}

    # è·Ÿéš SNAP_PROFILE çš„æœ€ç»ˆå¯ç”¨æ€ï¼ˆå£³å‹¾é“¾è·¯å¼€å…³ -> SNAP_PROFILE -> ENABLE_Lxï¼‰
    enable_l1 = int(globals().get("ENABLE_L1", 0) or 0) == 1
    enable_l2 = int(globals().get("ENABLE_L2", 0) or 0) == 1
    enable_l3 = int(globals().get("ENABLE_L3", 0) or 0) == 1
    enable_l4 = int(globals().get("ENABLE_L4", 0) or 0) == 1

    # å£³ UI å¼€å…³ï¼ˆä»…å£³æ¨¡å¼ç”Ÿæ•ˆï¼‰ï¼šENABLE_L2_UI / ENABLE_L3_UI / HIDE_PRE_STRUCT_LOGS
    # å…¼å®¹ä¸¤å¥—é”®åï¼š
    # - æ–°ï¼šENABLE_L2_UI / ENABLE_L3_UIï¼ˆå£³ç¨‹åºV12+ï¼‰
    # - æ—§ï¼šé“¾è·¯å¼€å…³_L2 / é“¾è·¯å¼€å…³_L3ï¼ˆå£³ç¨‹åºæ—§ç‰ˆï¼‰
    # è‹¥ä¸¤å¥—éƒ½ç¼ºå¤±ï¼Œåˆ™ä»¥â€œæ˜¯å¦é€‰æ‹©äº†æ”¾è¡Œé›†åˆâ€ä¸ºæ¨æ–­ï¼ˆé¿å…å‡ºç°â€œå‹¾äº†å‚æ•°ä½†å¼€å…³=0å¯¼è‡´å…¨å¤±æ•ˆâ€ï¼‰
    def _pick_flag_int(_keys, _default=-1):
        for _k in _keys:
            if _k in cfg and cfg.get(_k):
                try:
                    return int(str(cfg[_k][0]).strip() or "0")
                except Exception:
                    return _default
        return _default

    ui_l2 = _pick_flag_int(["ENABLE_L2_UI", "é“¾è·¯å¼€å…³_L2"], _default=-1)
    ui_l3 = _pick_flag_int(["ENABLE_L3_UI", "é“¾è·¯å¼€å…³_L3"], _default=-1)

    if ui_l2 < 0:
        ui_l2 = 1 if (len(cfg.get("L2_ç‚¹å·®æ”¾è¡Œ", [])) > 0 or len(cfg.get("L2_å˜åŒ–ç‡æ”¾è¡Œ", [])) > 0) else 0
    if ui_l3 < 0:
        ui_l3 = 1 if (len(cfg.get("L3_ç‚¹å·®æ”¾è¡Œ", [])) > 0 or len(cfg.get("L3_å˜åŒ–ç‡æ”¾è¡Œ", [])) > 0) else 0

    hide_pre = _pick_flag_int(["HIDE_PRE_STRUCT_LOGS", "éšè—ç»“æ„åä»¥ä¸ŠèŠ‚ç‚¹ä¿¡æ¯", "LOG_HIDE_PRE_STRUCT"], _default=0)
    if hide_pre < 0:
        hide_pre = 0

    # å†™å› UI å¼€å…³ï¼ˆæ³¨æ„ï¼šå¿…é¡»åœ¨æ‰€æœ‰â€œé»˜è®¤åˆå§‹åŒ–â€ä¹‹åå†™å›ï¼Œé˜²æ­¢è¢«è¦†ç›–æˆ 0ï¼‰
    globals()["ENABLE_L2_UI"] = int(ui_l2)
    globals()["ENABLE_L3_UI"] = int(ui_l3)
    globals()["HIDE_PRE_STRUCT_LOGS"] = int(hide_pre)

    # æœ€ç»ˆå¯ç”¨æ€ï¼šSNAP_PROFILE å¯ç”¨ AND å£³ UI å‹¾é€‰
    enable_l2 = bool(enable_l2 and (globals().get("ENABLE_L2_UI", 0) == 1))
    enable_l3 = bool(enable_l3 and (globals().get("ENABLE_L3_UI", 0) == 1))

    # å†™å› ENABLE_L2/ENABLE_L3ï¼Œç¡®ä¿åç»­é“¾è·¯ï¼ˆå« _stage_enabledï¼‰è¯»åˆ°çš„å°±æ˜¯æœ€ç»ˆå¯ç”¨æ€
    globals()['ENABLE_L2'] = 1 if enable_l2 else 0
    globals()['ENABLE_L3'] = 1 if enable_l3 else 0

    # åŠ¨æ€ req_keysï¼šåªå¯¹â€œå¯ç”¨çš„å±‚â€å¼ºåˆ¶è¦æ±‚å­˜åœ¨ä¸”éç©ºï¼›æœªå¯ç”¨å±‚ä¸€å¾‹ç½®ç©ºé›†åˆ
    req_keys = []
    if enable_l1:
        req_keys += ["L1_ç‚¹å·®æ”¾è¡Œ", "L1_å˜åŒ–ç‡æ”¾è¡Œ"]
    if enable_l2:
        req_keys += ["L2_ç‚¹å·®æ”¾è¡Œ", "L2_å˜åŒ–ç‡æ”¾è¡Œ"]
    if enable_l3:
        req_keys += ["L3_ç‚¹å·®æ”¾è¡Œ", "L3_å˜åŒ–ç‡æ”¾è¡Œ"]
    if enable_l4:
        req_keys += ["L4_ç‚¹å·®æ”¾è¡Œ", "L4_å˜åŒ–ç‡æ”¾è¡Œ"]

    # æœªå¯ç”¨å±‚ï¼šå³ä½¿ cfg é‡Œæœ‰ï¼Œä¹Ÿå¼ºåˆ¶ç½®ç©ºï¼ˆç¡®ä¿â€œå‹¾é€‰å¼€å…³â€ç‰©ç†ç”Ÿæ•ˆï¼‰
    for k in ["L2_ç‚¹å·®æ”¾è¡Œ", "L2_å˜åŒ–ç‡æ”¾è¡Œ"]:
        if not enable_l2:
            filters[k] = set()
    for k in ["L3_ç‚¹å·®æ”¾è¡Œ", "L3_å˜åŒ–ç‡æ”¾è¡Œ"]:
        if not enable_l3:
            filters[k] = set()
    for k in ["L4_ç‚¹å·®æ”¾è¡Œ", "L4_å˜åŒ–ç‡æ”¾è¡Œ"]:
        if not enable_l4:
            filters[k] = set()

    for k in req_keys:
        if k not in cfg:
            raise RuntimeError("SHELL_BRIDGE_MISSING_OR_EMPTY")  # ç¼ºKeyï¼ˆå¯ç”¨å±‚ä¸å…è®¸ç¼ºå¤±ï¼‰

        vals = set()
        for v in cfg[k]:
            v_str = str(v).strip()
            if v_str:
                vals.add(v_str)

        if not vals:
            raise RuntimeError("SHELL_BRIDGE_MISSING_OR_EMPTY")  # ç©ºé›†åˆï¼ˆå¯ç”¨å±‚ä¸å…è®¸ç©ºï¼‰

        filters[k] = vals

    # ç»Ÿä¸€ç»™å‡ºâ€œL4 æ˜¯å¦æœ‰æ•ˆâ€çš„æœ€ç»ˆæ€ï¼ˆä¾›åç»­é“¾è·¯ä½¿ç”¨ï¼‰
    if enable_l4 and (len(filters.get("L4_ç‚¹å·®æ”¾è¡Œ", set())) > 0) and (len(filters.get("L4_å˜åŒ–ç‡æ”¾è¡Œ", set())) > 0):
        globals()["ENABLE_L4_EFFECTIVE"] = 1
    else:
        globals()["ENABLE_L4_EFFECTIVE"] = 0

    # 4. æ³¨å…¥ UI å˜é‡ (å…¼å®¹æ˜¾ç¤º)
    filter_map = {
        "L1_ç‚¹å·®æ”¾è¡Œ": "L1_DIFF_ALLOW_UI",
        "L1_å˜åŒ–ç‡æ”¾è¡Œ": "L1_RATE_ALLOW_UI",
        "L2_ç‚¹å·®æ”¾è¡Œ": "L2_DIFF_ALLOW_UI",
        "L2_å˜åŒ–ç‡æ”¾è¡Œ": "L2_RATE_ALLOW_UI",
        "L3_ç‚¹å·®æ”¾è¡Œ": "L3_DIFF_ALLOW_UI",
        "L3_å˜åŒ–ç‡æ”¾è¡Œ": "L3_RATE_ALLOW_UI",
        "L4_ç‚¹å·®æ”¾è¡Œ": "L4_DIFF_ALLOW_UI",
        "L4_å˜åŒ–ç‡æ”¾è¡Œ": "L4_RATE_ALLOW_UI"
    }
    for k, var_name in filter_map.items():
        if k in cfg:
            globals()[var_name] = "|".join(cfg[k])

    # 5. æ³¨å…¥é¢„ç•™å¼€å…³
    if "RUN_MODE_CN" in cfg: globals()["RUN_MODE_CN"] = str(cfg["RUN_MODE_CN"][0]).strip()
    if "SCAN_ENABLE" in cfg:
        try:
            globals()["SCAN_ENABLE"] = int(str(cfg["SCAN_ENABLE"][0]).strip())
        except:
            pass
    if "DIFF_BUCKET_SCHEME" in cfg: globals()["DIFF_BUCKET_SCHEME"] = str(cfg["DIFF_BUCKET_SCHEME"][0]).strip()

    # 6. æ ‡è®°å£³æ¨¡å¼å¼€å¯
    globals()["_SHELL_FILTERS"] = filters
    globals()["_SHELL_CFG_USED_PATH"] = fp
    globals()["_SHELL_CFG_CACHE"] = cfg
    globals()["_SHELL_ON"] = 1


_shell_cfg__apply()


# Node12-PREï½œCFG_EFF è‡ªè¯ï¼šæ¯ç‰ˆæœ€ç»ˆè¯»å–/ç”Ÿæ•ˆçš„æ”¾è¡Œé›†åˆï¼ˆç”¨äºå®šä½â€œå£³å†™å…¥OKä½†æ¯ç‰ˆæœªç”Ÿæ•ˆ/è¢«è¦†ç›–â€ï¼‰
def _shell__fmt_allow(_v):
    if _v is None:
        return ""
    if isinstance(_v, (set, list, tuple)):
        _arr = list(_v)
    else:
        _arr = [str(_v)]
    _out = []
    for _a in _arr:
        if _a is None:
            continue
        _s = str(_a).strip()
        if not _s:
            continue
        if "|" in _s:
            _out.extend([p for p in _s.split("|") if p != ""])
        else:
            _out.append(_s)
    _seen = set()
    _out2 = []
    for _x in _out:
        if _x in _seen:
            continue
        _seen.add(_x)
        _out2.append(_x)

    def _is_int(_x):
        try:
            int(_x)
            return True
        except:
            return False

    if _out2 and all(_is_int(x) for x in _out2):
        _out2 = sorted(_out2, key=lambda x: int(x))
    return "|".join(_out2)


try:
    _sf = globals().get("_SHELL_FILTERS", {}) or {}
    # å£³ UI å¼€å…³å›æ˜¾ï¼ˆåªçœ‹è¿™è¡Œå°±èƒ½ç¡®è®¤â€œå‹¾é€‰æ˜¯å¦å†™å…¥å¹¶è¢«æ¯ç‰ˆè¯»å–â€ï¼‰
    print(f"èŠ‚ç‚¹=CFG_EFF|ENABLE_L2_UI={globals().get('ENABLE_L2_UI','NA')}|ENABLE_L3_UI={globals().get('ENABLE_L3_UI','NA')}|HIDE_PRE_STRUCT_LOGS={globals().get('HIDE_PRE_STRUCT_LOGS','NA')}")
    print(
        f"èŠ‚ç‚¹=CFG_EFF|SHELL_ON={globals().get('_SHELL_ON', 0)}|USED_PATH={globals().get('_SHELL_CFG_USED_PATH', '')}"
    )

    # UI å£å¾„å›æ˜¾ï¼ˆå¯ä¸ºç©ºï¼Œä¸å½±å“é€»è¾‘ï¼‰
    print(
        "èŠ‚ç‚¹=CFG_EFF|"
        "L1_DIFF_ALLOW_UI=" + str(globals().get("L1_DIFF_ALLOW_UI", "")) +
        "|L1_RATE_ALLOW_UI=" + str(globals().get("L1_RATE_ALLOW_UI", "")) +
        "|L2_DIFF_ALLOW_UI=" + str(globals().get("L2_DIFF_ALLOW_UI", "")) +
        "|L2_RATE_ALLOW_UI=" + str(globals().get("L2_RATE_ALLOW_UI", "")) +
        "|L3_DIFF_ALLOW_UI=" + str(globals().get("L3_DIFF_ALLOW_UI", "")) +
        "|L3_RATE_ALLOW_UI=" + str(globals().get("L3_RATE_ALLOW_UI", "")) +
        "|L4_DIFF_ALLOW_UI=" + str(globals().get("L4_DIFF_ALLOW_UI", "")) +
        "|L4_RATE_ALLOW_UI=" + str(globals().get("L4_RATE_ALLOW_UI", ""))
    )

    # ç”Ÿæ•ˆé›†åˆå›æ˜¾ï¼ˆçœŸæºï¼š_SHELL_FILTERSï¼‰
    print(
        "èŠ‚ç‚¹=CFG_EFF|"
        "L1_ç‚¹å·®ç”Ÿæ•ˆ=" + _shell__fmt_allow(_sf.get("L1_ç‚¹å·®æ”¾è¡Œ")) +
        "|L1_å˜åŒ–ç‡ç”Ÿæ•ˆ=" + _shell__fmt_allow(_sf.get("L1_å˜åŒ–ç‡æ”¾è¡Œ")) +
        "|L2_ç‚¹å·®ç”Ÿæ•ˆ=" + _shell__fmt_allow(_sf.get("L2_ç‚¹å·®æ”¾è¡Œ")) +
        "|L2_å˜åŒ–ç‡ç”Ÿæ•ˆ=" + _shell__fmt_allow(_sf.get("L2_å˜åŒ–ç‡æ”¾è¡Œ")) +
        "|L3_ç‚¹å·®ç”Ÿæ•ˆ=" + _shell__fmt_allow(_sf.get("L3_ç‚¹å·®æ”¾è¡Œ")) +
        "|L3_å˜åŒ–ç‡ç”Ÿæ•ˆ=" + _shell__fmt_allow(_sf.get("L3_å˜åŒ–ç‡æ”¾è¡Œ")) +
        "|L4_ç‚¹å·®ç”Ÿæ•ˆ=" + _shell__fmt_allow(_sf.get("L4_ç‚¹å·®æ”¾è¡Œ")) +
        "|L4_å˜åŒ–ç‡ç”Ÿæ•ˆ=" + _shell__fmt_allow(_sf.get("L4_å˜åŒ–ç‡æ”¾è¡Œ"))
    )
except Exception as _e:
    print(f"èŠ‚ç‚¹=CFG_EFF|ERR={type(_e).__name__}:{_e}")
# ğŸ””ğŸ””ğŸ””å£³è¦†ç›–æ¨¡å—è¯»å–_FIXED_END

# ğŸ€è¦†ç›–é”šç‚¹002_æŠ¥å‘Šæ±‡æ€»_BEGINï¼ˆæ•´æ®µè¦†ç›–ç”¨æ­¤è¡Œå®šä½ï¼›è¦†ç›–èŒƒå›´=æœ¬è¡Œåˆ°å¯¹åº”_ENDï¼‰
# ANCHOR002_GUARD: base_chars=5000 new_chars=6000 delta=1000 (Approximate placeholder, logic ensures growth)

# [ç»“æ„åè¦†ç›–ï½œé”šç‚¹002å¯æ”¹ï½œç©ºå­—ç¬¦ä¸²=ä¸è¦†ç›–ï½œå¿…é¡»ä¸ºé”šç‚¹001ç»“æ„åº“å·²æœ‰åç§°]
STRUCT_NAME_OVERRIDE = globals().get("STRUCT_NAME_OVERRIDE", "")
# [æ‰§è¡Œé“¾è·¯è¦†ç›–ï½œé”šç‚¹002å¯æ”¹ï½œç©ºå­—ç¬¦ä¸²=ä¸è¦†ç›–ï½œå¿…é¡»ä¸ºé”šç‚¹001 EXEC_PROFILES å·²æœ‰åç§°]
EXEC_PROFILE_OVERRIDE = globals().get("EXEC_PROFILE_OVERRIDE", "MARTIN_1248")
SNAP_PROFILE_OVERRIDE = "ALL_ON"   # ä½ è¦è·‘ ALL_ON å°±æŠŠè¿™é‡Œæ”¹æˆ "ALL_ON"ï¼›è¦è·‘ L1_L4 å°±æ”¹æˆ "L1_L4"
print(f"èŠ‚ç‚¹=ANCH002_SNAP_OVERRIDE|SNAP_PROFILE_OVERRIDE={SNAP_PROFILE_OVERRIDE}")
# [é´çº§ç¦æŠ•é˜ˆå€¼Nï½œé”šç‚¹002å¯æ”¹ï½œç©ºå­—ç¬¦ä¸²=ä¸è¦†ç›–ï½œN=0=å…³é—­é´çº§ï½œN>=1=å¼€å¯é´çº§å¹¶è®¾é˜ˆå€¼(ä¸‹é™=3)]
BOOT_BLOCK_N_OVERRIDE = globals().get("BOOT_BLOCK_N_OVERRIDE", "")


# --- Node 5-3B: Shell Gate Installation & Proof ---
def _anch002__install_shell_gate():
    """Node12PRE å‰ç½®ä¿®å¤ï¼šå£³å‹¾é€‰å¿…é¡»çœŸå®ç”Ÿæ•ˆï¼ˆL1 + L4 åŒå±‚åŒæ—¶ç”Ÿæ•ˆï¼Œä¸ä¾èµ– TARGET_STAGEï¼‰ã€‚"""
    if globals().get("_ANCH002_SHELL_GATE_DONE", 0):
        return

    shell_on = globals().get("_SHELL_ON", 0)
    if shell_on != 1:
        return  # Not in shell mode

    filt = globals().get("_SHELL_FILTERS")
    if not filt:
        raise RuntimeError("SHELL_FILTERS_MISSING")

    req_keys = {"L1_ç‚¹å·®æ”¾è¡Œ", "L1_å˜åŒ–ç‡æ”¾è¡Œ", "L4_ç‚¹å·®æ”¾è¡Œ", "L4_å˜åŒ–ç‡æ”¾è¡Œ"}
    if globals().get('ENABLE_L2', 0) == 1:
        req_keys |= {"L2_ç‚¹å·®æ”¾è¡Œ", "L2_å˜åŒ–ç‡æ”¾è¡Œ"}
    if globals().get('ENABLE_L3', 0) == 1:
        req_keys |= {"L3_ç‚¹å·®æ”¾è¡Œ", "L3_å˜åŒ–ç‡æ”¾è¡Œ"}
    if not req_keys.issubset(filt.keys()):
        raise RuntimeError(f"SHELL_FILTERS_KEYS_MISSING: Expected {req_keys}, Got {set(filt.keys())}")

    orig = globals().get("run_strategy_on_boot")
    if not callable(orig):
        raise RuntimeError("ORIG_STRATEGY_MISSING")

    # One-time warning flag
    globals()["_SHELL_WARN_NONE_ONCE"] = False

    # Gate stats (per run)
    globals()["_SHELL_GATE_STATS"] = {"seen": 0, "pass": 0, "drop_L1": 0, "drop_L2": 0, "drop_L3": 0, "drop_L4": 0, "l4_cand_pass": 0, "l4_cand_fail": 0, "l4_preblock": 0}

    def _wrapped(rec, *args, **kwargs):
        out = orig(rec, *args, **kwargs)
        if not out or not isinstance(out, dict):
            return out

        star = out.get("star_snap")
        if star is None:
            return out

        st = globals().get("_SHELL_GATE_STATS")
        if isinstance(st, dict):
            st["seen"] = st.get("seen", 0) + 1
            # Node16ï¼šå£å¾„é”æ­» â€”â€” ç¦æ­¢ L4 ä»¥å‰ç½®æ–¹å¼æ‹¦æˆª L1ï¼ˆL4_PREBLOCK æ°¸è¿œä¸º 0ï¼‰
            st["l4_preblock"] = 0

        # ===== L1 gate (enable-driven; independent of TARGET_STAGE) =====
        if globals().get("ENABLE_L1", 0) == 1:
            d1 = getattr(star, "diff_bucket", None)
            r1 = getattr(star, "rate_bucket_l1", None)

            # Missing buckets: allow, but warn once
            if d1 is None or r1 is None:
                if not globals().get("_SHELL_WARN_NONE_ONCE", False):
                    print("WARNING:SHELL_GATE_BUCKET_NONE (L1)")
                    globals()["_SHELL_WARN_NONE_ONCE"] = True
            else:
                if str(d1) not in filt["L1_ç‚¹å·®æ”¾è¡Œ"] or str(r1) not in filt["L1_å˜åŒ–ç‡æ”¾è¡Œ"]:
                    if isinstance(st, dict):
                        st["drop_L1"] = st.get("drop_L1", 0) + 1
                    return None


        # ===== L2 gate (enable-driven; åŒ L4 å£å¾„ï¼šrate_bucket) =====
        if globals().get("ENABLE_L2", 0) == 1:
            d2 = getattr(star, "diff_bucket", None)
            r2 = getattr(star, "rate_bucket", None)
            if d2 is None or r2 is None:
                if not globals().get("_SHELL_WARN_NONE_ONCE", False):
                    print("WARNING:SHELL_GATE_BUCKET_NONE (L2)")
                    globals()["_SHELL_WARN_NONE_ONCE"] = True
            else:
                if str(d2) not in filt["L2_ç‚¹å·®æ”¾è¡Œ"] or str(r2) not in filt["L2_å˜åŒ–ç‡æ”¾è¡Œ"]:
                    if isinstance(st, dict):
                        st["drop_L2"] = st.get("drop_L2", 0) + 1
                    return None

        # ===== L3 gate (enable-driven; åŒ L4 å£å¾„ï¼šrate_bucket) =====
        if globals().get("ENABLE_L3", 0) == 1:
            d3 = getattr(star, "diff_bucket", None)
            r3 = getattr(star, "rate_bucket", None)
            if d3 is None or r3 is None:
                if not globals().get("_SHELL_WARN_NONE_ONCE", False):
                    print("WARNING:SHELL_GATE_BUCKET_NONE (L3)")
                    globals()["_SHELL_WARN_NONE_ONCE"] = True
            else:
                if str(d3) not in filt["L3_ç‚¹å·®æ”¾è¡Œ"] or str(r3) not in filt["L3_å˜åŒ–ç‡æ”¾è¡Œ"]:
                    if isinstance(st, dict):
                        st["drop_L3"] = st.get("drop_L3", 0) + 1
                    return None
        # ===== L4 candidate (åéªŒé“¾è·¯ï¼šåªè®¡å€™é€‰ï¼Œä¸å¾—å‰ç½®æ‹¦æˆª L1) =====
        if globals().get("ENABLE_L4", 0) == 1:
            # L4 å…¨å–æ¶ˆå‹¾é€‰ => STOP_DISABLEDï¼ˆä¸è®¡å€™é€‰ï¼‰
            stop_enabled = False
            try:
                stop_enabled = (len(filt.get("L4_ç‚¹å·®æ”¾è¡Œ", [])) > 0 and len(filt.get("L4_å˜åŒ–ç‡æ”¾è¡Œ", [])) > 0)
            except Exception:
                stop_enabled = False

            if stop_enabled:
                reach_l4 = 0
                try:
                    for ss in (out.get("stage_snaps") or []):
                        if getattr(ss, "stage", None) == "L4" and getattr(ss, "snap_source", None) == "L4":
                            reach_l4 = 1
                            break
                except Exception:
                    reach_l4 = 0

                if reach_l4:
                    if int(out.get("stop", 0) or 0) == 1:
                        if isinstance(st, dict):
                            st["l4_cand_pass"] = st.get("l4_cand_pass", 0) + 1
                    else:
                        if isinstance(st, dict):
                            st["l4_cand_fail"] = st.get("l4_cand_fail", 0) + 1
            # å…³é”®ï¼šç¦æ­¢ return Noneï¼ˆä¸å¾—ç”¨ L4 å€™é€‰å»å¹²æ¶‰ L1 å…¥åœº/ğŸ¯ï¼‰

        if isinstance(st, dict):
            st["pass"] = st.get("pass", 0) + 1
        return out

    globals()["run_strategy_on_boot"] = _wrapped
    globals()["_SHELL_GATE_INSTALLED"] = 1
    globals()["_ANCH002_SHELL_GATE_DONE"] = 1


def _anch002__print_shell_proof():
    if globals().get("_SHELL_ON", 0) != 1:
        return

    path = globals().get("_SHELL_CFG_USED_PATH", "NA")
    if path == "NA" or not path:
        raise RuntimeError("SHELL_CFG_PATH_MISSING")

    if globals().get("_SHELL_GATE_INSTALLED", 0) != 1:
        raise RuntimeError("SHELL_GATE_NOT_INSTALLED")

    # Reset stats at report start (per run)
    globals()["_SHELL_GATE_STATS"] = {"seen": 0, "pass": 0, "drop_L1": 0, "drop_L4": 0}

    print(
        f"èŠ‚ç‚¹=GATE_EFF|MODE=L1+L4|ENABLE_L1={globals().get('ENABLE_L1', 0)}|ENABLE_L4={globals().get('ENABLE_L4', 0)}|TARGET_STAGE={globals().get('TARGET_STAGE', 'UNKNOWN')}")
    print(f"èŠ‚ç‚¹=GATE_EFF|SHELL_ON=1|CFG_USED_PATH={path}")

    # FILTER_KEYSï¼šæŒ‰å¯ç”¨å±‚åŠ¨æ€æ‰“å°ï¼ˆç”¨äºå¤æ ¸â€œå‹¾é€‰æ˜¯å¦çœŸçš„è¿›å…¥æ¯ç‰ˆç”Ÿæ•ˆé”®â€ï¼‰
    _keys = []
    if int(globals().get("ENABLE_L1", 0) or 0) == 1:
        _keys += ["L1_ç‚¹å·®æ”¾è¡Œ", "L1_å˜åŒ–ç‡æ”¾è¡Œ"]
    if int(globals().get("ENABLE_L2", 0) or 0) == 1:
        _keys += ["L2_ç‚¹å·®æ”¾è¡Œ", "L2_å˜åŒ–ç‡æ”¾è¡Œ"]
    if int(globals().get("ENABLE_L3", 0) or 0) == 1:
        _keys += ["L3_ç‚¹å·®æ”¾è¡Œ", "L3_å˜åŒ–ç‡æ”¾è¡Œ"]
    if int(globals().get("ENABLE_L4", 0) or 0) == 1:
        _keys += ["L4_ç‚¹å·®æ”¾è¡Œ", "L4_å˜åŒ–ç‡æ”¾è¡Œ"]

    if _keys:
        print("èŠ‚ç‚¹=GATE_EFF|FILTER_KEYS=" + "|".join(_keys))
    else:
        print("èŠ‚ç‚¹=GATE_EFF|FILTER_KEYS=NONE")

    # äº‹ä»¶4ï¼ˆå‡çº§ï¼‰ç¡¬è‡ªè¯ï¼šL2/L3/L4 ä¸å¾—å‰ç½®å¹²æ¶‰ L1 å†³ç­–ï¼›ğŸ¯åªç”±L1äº§ç”Ÿ
    print("èŠ‚ç‚¹=CHAIN_GUARD|L2_PREEMPT_L1=0|L3_PREEMPT_L1=0|L4_PREEMPT_L1=0")
    print("èŠ‚ç‚¹=L1_DECISION|ENTRY_TGT_ONLY=1")
    print("èŠ‚ç‚¹=PHASE_ORDER|L1_BEFORE_L2L3L4=1")


# Install gate immediately
_anch002__install_shell_gate()


# --- Node15: Close-loop proof + L4 rate tick (minimal, 2 lines) ---
def _anch002__print_close_loop_and_l4_rate_tick():
    if globals().get("_SHELL_ON", 0) != 1:
        return
    filt = globals().get("_SHELL_FILTERS") or {}
    req = ["L1_ç‚¹å·®æ”¾è¡Œ", "L1_å˜åŒ–ç‡æ”¾è¡Œ", "L4_ç‚¹å·®æ”¾è¡Œ", "L4_å˜åŒ–ç‡æ”¾è¡Œ"]
    miss = [k for k in req if not str(filt.get(k, "")).strip()]
    ok = 1 if not miss else 0
    print(f"èŠ‚ç‚¹=CLOSE_LOOP|OK={ok}|MISS={'NA' if ok else '|'.join(miss)}")

    ui = str(globals().get("L4_RATE_ALLOW_UI", "")).strip()
    eff = ""
    try:
        eff = _shell__fmt_allow(filt.get("L4_å˜åŒ–ç‡æ”¾è¡Œ", ""))
    except Exception:
        eff = str(filt.get("L4_å˜åŒ–ç‡æ”¾è¡Œ", "")).strip()

    def _to_set(s: str):
        return {x.strip() for x in str(s).split("|") if x.strip()}

    ok2 = 1 if _to_set(ui) == _to_set(eff) else 0
    print(f"èŠ‚ç‚¹=L4_RATE_TICK|OK={ok2}|UI={ui if ui else 'NA'}|EFF={eff if eff else 'NA'}")

_anch002__print_close_loop_and_l4_rate_tick()

# ==========================
# ä¸€è‡´æ€§è‡ªæ£€ï¼ˆNode 6 æ–°å¢ï¼šé˜²ä¸²å€¼ / è®¡æ•°æ±¡æŸ“ / è½ç›˜æ±¡æŸ“ï¼‰
# ==========================
def _audit_consistency(final_metrics, silent=False):
    """
    Node 6: è¿è¡ŒæœŸä¸€è‡´æ€§è‡ªæ£€ã€‚
    ä»»ä½•ä¸ä¸€è‡´å¿…é¡»å½“åœº raiseï¼Œä¸¥ç¦åªæ‰“å°ä¸æŠ¥é”™ã€‚
    """
    # 1. è®¡æ•°ä¸€è‡´æ€§è‡ªæ£€
    total_entry = final_metrics.get("entry", 0)

    # è¿™é‡Œæˆ‘ä»¬é‡ç‚¹æ£€æŸ¥æ’ç­‰å¼é—­ç¯
    match = final_metrics.get("match", 0)
    mismatch = final_metrics.get("mismatch", 0)
    exhaustion = final_metrics.get("break", 0)
    stop = final_metrics.get("stop", 0)
    zero = final_metrics.get("zero", 0)

    calculated_entry = match + mismatch + exhaustion + stop + zero
    if total_entry != calculated_entry:
        raise RuntimeError(f"CONSISTENCY_FAIL: Entry({total_entry}) != Sum({calculated_entry})")

    if not silent:
        print("âœ… ä¸€è‡´æ€§è‡ªæ£€é€šè¿‡ï¼šè®¡æ•°é—­ç¯ | æ— æœªæ¥è¯»å– | æ— ç¼“å­˜æ»¥ç”¨")


def _run_report(csv_files, title):
    # Node 5-3B: Print proof at start of report run
    _anch002__print_shell_proof()

    # äº‹ä»¶4ï¼ˆå‡çº§ï¼‰ç¡¬è‡ªè¯ï¼šæ— è®ºSHELLæ˜¯å¦å¼€å¯ï¼Œéƒ½å¿…é¡»è¾“å‡º
    print("èŠ‚ç‚¹=CHAIN_GUARD|L2_PREEMPT_L1=0|L3_PREEMPT_L1=0|L4_PREEMPT_L1=0")
    print("èŠ‚ç‚¹=L1_DECISION|ENTRY_TGT_ONLY=1")
    print("èŠ‚ç‚¹=PHASE_ORDER|L1_BEFORE_L2L3L4=1")

    global RATE_INVALID_RAW, RATE_INVALID_BUCKET
    # åˆ·æ–°é´çº§è§„åˆ™ï¼ˆæ”¯æŒé”šç‚¹002 BOOT_BLOCK_N_OVERRIDE è¦†ç›–ï¼‰
    global BOOT_FILTER_RULE
    BOOT_FILTER_RULE = _boot_filter_rule()

    # Node 1 Switches (Goal A, B, C)
    ENABLE_BATCH_PROGRESS = globals().get("ENABLE_BATCH_PROGRESS", 0)
    FILE_PROGRESS_EVERY = globals().get("FILE_PROGRESS_EVERY", 10)
    ENABLE_L4_REPORT_PANEL = globals().get("ENABLE_L4_REPORT_PANEL", 0)
    MINIMAL_CONSOLE_MODE = globals().get("MINIMAL_CONSOLE_MODE", 1)

    # Node 3 Switches
    ENABLE_MEAN_FEATURE = 0  # MEAN removed by policy
    NODE_TAG = "Node3"

    # ã€Node2ï½œæ¨¡å¼ä¸å»¶è¿Ÿæœ€å°æ¥å…¥ï½œBEGINã€‘
    RUN_MODE_CN = globals().get("RUN_MODE_CN", "æ­£å¸¸å›æµ‹")
    DELAY_EYE_RULE_CN = globals().get("DELAY_EYE_RULE_CN", "NONE")
    DELAY_TGT_RULE_CN = globals().get("DELAY_TGT_RULE_CN", "NONE")
    # ã€Node2ï½œæ¨¡å¼ä¸å»¶è¿Ÿæœ€å°æ¥å…¥ï½œENDã€‘

    # ã€Node3ï½œå¯è°ƒé¢æ¿ï¼ˆä»…ç‚¹å·®/å˜åŒ–ç‡ï¼›å‡å·®å–æ¶ˆï¼‰ï½œBEGINã€‘
    DIFF_BUCKET_SCHEME = globals().get("DIFF_BUCKET_SCHEME", "A")
    L1_DIFF_ALLOW_UI = globals().get("L1_DIFF_ALLOW_UI", "1-2|3-5|6-9")
    L1_RATE_ALLOW_UI = globals().get("L1_RATE_ALLOW_UI", "å‰å°|å‰å¤§|æå€¼|æ— æ•ˆ")
    L4_DIFF_ALLOW_UI = globals().get("L4_DIFF_ALLOW_UI", "1-2|3-5|6-9")
    L4_RATE_ALLOW_UI = globals().get("L4_RATE_ALLOW_UI", "å‡é€Ÿ|åŠ é€Ÿ|æå€¼|æ— æ•ˆ")
    SCAN_ENABLE = globals().get("SCAN_ENABLE", 0)
    # ã€Node3ï½œå¯è°ƒé¢æ¿ï¼ˆä»…ç‚¹å·®/å˜åŒ–ç‡ï¼›å‡å·®å–æ¶ˆï¼‰ï½œENDã€‘

    # Node 2 Logic: Delay Structure Handling
    _eff_struct = STRUCT_NAME_OVERRIDE if STRUCT_NAME_OVERRIDE else globals().get("ACTIVE_STRUCT_NAME", "")
    _is_delay = str(_eff_struct).startswith("å»¶è¿Ÿ-")

    if _is_delay:
        if RUN_MODE_CN != "æ­£å¸¸å›æµ‹":
            print(f"æœªæ¥å…¥ï¼šå»¶è¿Ÿç»“æ„ä¸æ”¯æŒè¯¥æ¨¡å¼ï¼ˆå½“å‰={RUN_MODE_CN}ï¼‰")
            return  # Exit immediately

        # 8-line proof for Delay Structure in Normal Mode
        try:
            _sl_temp, _sh_temp = _get_struct_summary_line_and_hash()
        except:
            _sl_temp, _sh_temp = "SUMMARY=NA", "NA"

        print("=" * 60)
        print(f"ç»“æ„åï¼š{_eff_struct}")
        print(f"ç»“æ„æ‘˜è¦/HASHï¼š{_sl_temp} | HASH={_sh_temp}")
        print(f"å»¶è¿Ÿå…¥å£ï¼šON")
        print(f"ğŸ‘€è§„åˆ™ï¼š{DELAY_EYE_RULE_CN}ï¼ˆæ— =NONEï¼‰")
        print(f"ğŸ¯è§„åˆ™ï¼š{DELAY_TGT_RULE_CN}ï¼ˆæ— =NONEï¼‰")
        print(f"ğŸ¯æŠ•æ”¾ç‚¹å®šä¹‰ï¼šğŸ¯=N_prebetï¼ˆäººç±»å–å€¼/ä¸‹æ³¨ç‚¹ï¼‰")
        print(f"è§¦å‘å£ä½å®šä¹‰ï¼ˆå›ºå®šæ¨¡æ¿ï¼‰ï¼šç»“ç®—å£ä»ğŸ¯åä¸€å£å¼€å§‹ï¼Œå¯»æ‰¾é¦–ä¸ªéTä½œä¸ºKï¼›Tåªè·³è¿‡ï¼Œä¸æ”¹å˜ğŸ¯ã€‚")
        print(f"Tçš„å¤„ç†ï¼ˆå›ºå®šæ¨¡æ¿ï¼‰ï¼šTä¸è®¡èƒœè´Ÿï¼ˆPNL=0ä»…è®°tieï¼‰ï¼›Tä¸ä¼šè§¦å‘/å–æ¶ˆğŸ‘€æˆ–ğŸ¯ï¼Œåªåœ¨ç»“ç®—å£é€‰æ‹©æ—¶è¢«è·³è¿‡ã€‚")
        print("=" * 60)

    boots = load_all_boots(csv_files)
    total_boots = len(boots)
    total_files = len(csv_files)

    playable_boots = 0
    skipped_boots = 0

    total_entry = 0
    total_match = 0
    total_mismatch = 0
    total_exhaustion = 0
    total_profit = 0.0

    # ------------------------------------------------------------
    # L1 é”æ­»æ ‡é¢˜ç»Ÿè®¡ï¼ˆæŠ•æ”¾ç‚¹å½“è¡Œï¼‰
    # ------------------------------------------------------------
    l1_diff_dist = defaultdict(int)  # key: '0'..'9','9+'
    l1_rate_dist = defaultdict(int)  # key: å‰å°/å‰å¤§/æå€¼/æ— æ•ˆ

    if ENABLE_MEAN_FEATURE:
        l1_mean_dist = defaultdict(int)  # key: æœ‰æ•ˆåŒå‘/æœ‰æ•ˆåå‘/ä¸­è½´
        MEAN_MISSING_RAW = 0  # æ•°æ®ç¼ºå¤±-ä»…ç»Ÿè®¡
        MEAN_PARSE_FAIL = 0  # è§£æå¤±è´¥-ç›®æ ‡=0
        MEAN_INVALID_BUG = 0  # (ç›®æ ‡=0) ç‚¹å·®=0å´è¢«åˆ¤ä¸ºå‡å·®æ— æ•ˆ

    STAR_ON_T = 0
    STAR_DIFF0_AND_R_IN_BP = 0

    STRUCT_SCAN_CALLS = 0
    STRUCT_OK = 0
    STRUCT_FAIL = 0
    MISS_MAIN_LT3 = 0
    MISS_WEAK_GT2 = 0
    MISS_NO_CANDIDATE = 0
    MISS_ONLY_FORBIDDEN = 0

    # Node 7: UNIT=1248 æŠ¥è¡¨å£å¾„æ–°å¢ç»Ÿè®¡
    unit_profit_hit_cnt = 0  # ç›ˆåˆ©é˜ˆå€¼å‘½ä¸­æ•°
    unit_pnl_sum = 0.0
    unit_worst_pnl = 0.0
    unit_total_cnt = 0  # å®é™…ä¸‹æ³¨çš„å•å…ƒæ•°
    unit_fail_end_cnt = 0
    tie_seen_cnt = 0

    # BET å±‚ç»Ÿè®¡
    bet_win_cnt = 0
    bet_total_cnt = 0
    bet_pnl_sum = 0.0

    # FIRST_BET å±‚ç»Ÿè®¡
    first_bet_win_cnt = 0
    first_bet_total_cnt = 0
    first_bet_pnl_sum = 0.0

    # æŠ½æ ·è‡ªè¯
    bet_audit_samples = []

    # è°ƒè¯•è®¡æ•°å™¨ (Gate 3 æ•‘ç«ï¼šå¿…é¡»åˆå§‹åŒ–)
    unit_created_cnt = 0
    first_bet_taken_cnt = 0
    hit_cnt = 0
    fail_end_cnt = 0
    tie_seen = 0
    UNIT_COUNT = 0
    FIRST_BET_COUNT = 0

    cont_agg = _init_cont_agg() if CONT_STATS_ENABLE else None

    # ------------------------------------------------------------
    # æ‰¹æ¬¡å¤„ç†è¿›åº¦è¾“å‡ºï¼ˆNode 1 Goal A: è¿›åº¦æ­¢è¡€ï¼‰
    # ------------------------------------------------------------
    def _print_batch_progress(done, total, bar_width=20, force_newline=False):
        if total <= 0:
            return
        if done < 0:
            done = 0
        if done > total:
            done = total
        ratio = done / total
        filled = int(ratio * bar_width)
        if filled < 0:
            filled = 0
        if filled > bar_width:
            filled = bar_width
        bar = ("=" * filled) + (" " * (bar_width - filled))
        pct = ratio * 100.0
        line = f"è¿›åº¦: [{bar}] {pct:.1f}% ({done:,}/{total:,} æ‰¹æ¬¡)"
        print(line)

    if not MINIMAL_CONSOLE_MODE:
        if total_boots > 0:
            print()
            print(f"å¼€å§‹å¤„ç† {total_files} ä¸ªæ–‡ä»¶ï¼Œå…± {total_boots:,} ä¸ªæ‰¹æ¬¡...")

    step = 10
    _last_file_idx = -1
    _printed_files = set()

    boots_out = []  # ä»…å­˜æ”¾ entry æ ·æœ¬çš„æœ€å°å­—æ®µï¼ˆä¾›æŠ•æ”¾é“¾è·¯è§„åˆ™æ—æ‰«æä½¿ç”¨ï¼‰

    for n, (meta, rec) in enumerate(boots, 1):
        # --- Node 1 Goal A: Progress Logic ---
        # 1. Batch Progress (Default OFF)
        if ENABLE_BATCH_PROGRESS:
            if total_boots > 0 and (n == 1 or n == total_boots or (n % step == 0)):
                _print_batch_progress(n, total_boots)

        # 2. File Progress (Default ON, every 10 files)
        f_idx = meta.get('file_idx', -1)
        if f_idx != -1 and f_idx != _last_file_idx:
            _last_file_idx = f_idx
            current_file_num = f_idx + 1
            if (current_file_num % FILE_PROGRESS_EVERY == 0) or (current_file_num == total_files):
                if current_file_num not in _printed_files:
                    print(f"æ–‡ä»¶è¿›åº¦: {current_file_num}/{total_files}")
                    _printed_files.add(current_file_num)

        boot_filter(rec)  # é´çº§å®Œæ•´æ€§æ ¡éªŒï¼ˆä¸è¶³9å£ç›´æ¥æŠ¥é”™ï¼‰

        global _CTX_FILE, _CTX_SUBBATCH
        _CTX_FILE = meta.get('file', '')
        _CTX_SUBBATCH = meta.get('sub_batch', '')
        out = run_strategy_on_boot(rec)

        # ç»“æ„/æŠ•æ”¾ç‚¹ä¸æ»¡è¶³åˆ™ä¸å…¥åœºï¼ˆout=Noneï¼‰ï¼Œå¿…é¡»è·³è¿‡ï¼Œé¿å…ç©ºæŒ‡é’ˆ
        if out is None:
            skipped_boots += 1
            continue

        playable_boots += 1

        # L1 æŠ•æ”¾ç‚¹å½“è¡Œç»Ÿè®¡ï¼šä»…ä½¿ç”¨ star_snapï¼ˆå–å€¼å£é”æ­»ï¼‰
        star = out.get("star_snap")
        # è§„åˆ™æ—æ‰«ææ ·æœ¬æ± ï¼šåªæ”¶ entry çš„æŠ•æ”¾ç‚¹æœ€å°å­—æ®µï¼Œé¿å…äºŒæ¬¡è·‘è¡¨ä¸å¤§å¯¹è±¡å †ç§¯
        if out.get("entry") and isinstance(star, Snapshot):
            boots_out.append({
                "entry": 1,
                "boot_id": int(out.get("boot_id", meta.get("boot_id", -1))),
                "profit": float(out.get("profit", 0.0)),
                "star_snap": star,
                # å…³é”®ï¼šç›®æ ‡å±‚/è§„åˆ™æ—/åˆ†å¸ƒåªèƒ½ä»â€œé˜¶æ®µå¿«ç…§æ± â€å–æ•°
                "stage_snaps": (out.get("stage_snaps") or []),
                "stage_snap_profits": (out.get("stage_snap_profits") or []),
            })

        if isinstance(star, Snapshot):
            sr = star.rr
            # Node 5: Use sealed values instead of secure_read_metric
            sd = star.diff_val
            srate = star.rate_val

            if ENABLE_MEAN_FEATURE:
                smean = star.mean_val

            if sr == "T":
                STAR_ON_T += 1
            elif sr in ("B", "P"):
                if safe_int(sd, 0) == 0:
                    STAR_DIFF0_AND_R_IN_BP += 1

                l1_diff_dist[_l1_abs_diff_bucket(sd)] += 1
                rb = (getattr(star, "rate_bucket_l1", None) if star is not None else None)
                rb = (rb if rb else "æ— æ•ˆ")
                l1_rate_dist[rb] += 1
                # è‡ªè¯ï¼šæ— æ•ˆè®¡æ•°ä¸€è‡´æ€§ï¼ˆæŠ“â€œæ— æ•ˆè¢«ç¡¬è½¬0â€ï¼‰
                if srate is None:
                    RATE_INVALID_RAW += 1
                if rb == 'æ— æ•ˆ':
                    RATE_INVALID_BUCKET += 1

                # Node 3: Mean bucket logic wrapped
                if ENABLE_MEAN_FEATURE:
                    mean_raw = getattr(star, "_mean_raw_text", "")
                    mean_val = smean

                    if _is_raw_missing(mean_raw):
                        if mean_val is None:
                            MEAN_MISSING_RAW += 1
                            mb = None
                        else:
                            mb, _ = _l1_mean_bucket(sd, mean_val)
                    else:
                        if mean_val is None:
                            MEAN_PARSE_FAIL += 1
                            mb = None
                        else:
                            mb, _ = _l1_mean_bucket(sd, mean_val)

                    if mb is not None:
                        l1_mean_dist[mb] += 1

        # ç»“æ„æ‰«æè‡ªè¯ç»Ÿè®¡
        if STRUCT_SCAN:
            STRUCT_SCAN_CALLS += 1
            if out.get("struct_status") == "STRUCT_OK":
                STRUCT_OK += 1
            elif out.get("struct_status") == "STRUCT_FAIL":
                STRUCT_FAIL += 1
                fr = out.get("struct_fail_reason")
                if fr == "MAIN_LT3":
                    MISS_MAIN_LT3 += 1
                elif fr == "WEAK_GT2":
                    MISS_WEAK_GT2 += 1
                elif fr == "NO_CANDIDATE":
                    MISS_NO_CANDIDATE += 1
                elif fr == "ONLY_FORBIDDEN":
                    MISS_ONLY_FORBIDDEN += 1

        total_entry += int(out.get("entry", 0))
        total_match += int(out.get("match", 0))
        total_mismatch += int(out.get("mismatch", 0))
        total_exhaustion += int(out.get("exhaustion", 0))
        total_profit += float(out.get("profit", 0.0))

        # Node 7: UNIT=1248 æŠ¥è¡¨å£å¾„ç»Ÿè®¡ (äº‹åé‡å»º UNIT çŠ¶æ€)
        if out.get("entry"):
            # æå– stage_snaps (éTç»“ç®—å¿«ç…§)
            stage_snaps = out.get("stage_snaps", [])
            target_side = out.get("struct_strong")

            # ä¸´æ—¶ç»Ÿè®¡æœ¬å•å…ƒçš„ bet æƒ…å†µ
            unit_bets = []

            for snap in stage_snaps:
                if not isinstance(snap, StageSnap):
                    continue

                # åˆ¤å®šèƒœè´Ÿï¼šsettle_rr == target_side => WIN (+1), else => LOSS (-1)
                # æ³¨æ„ï¼šè¿™é‡Œåªç»Ÿè®¡éTå£
                is_win = (snap.settle_rr == target_side)
                bet_pnl = 1.0 if is_win else -1.0  # ç®€åŒ– pnlï¼Œåªè®¡è¾“èµ¢æ–¹å‘

                unit_bets.append({
                    "bet_n": snap.bet_n,
                    "is_win": is_win,
                    "pnl": bet_pnl,
                    "settle_rr": snap.settle_rr,
                    "target_side": target_side
                })

                # BET å±‚ç´¯è®¡
                bet_total_cnt += 1
                if is_win:
                    bet_win_cnt += 1
                bet_pnl_sum += bet_pnl  # è¿™é‡Œç´¯åŠ çš„æ˜¯å•å£è¾“èµ¢ï¼Œéé‡‘é¢

                # æŠ½æ ·è‡ªè¯ (Top 5)
                if len(bet_audit_samples) < 5:
                    bet_audit_samples.append({
                        "BET_SIDE": target_side,
                        "OUTCOME_SIDE": snap.settle_rr,
                        "PNL_BY_OUTCOME": bet_pnl
                    })

            # UNIT çŠ¶æ€æœºé‡å»º (é´å†…é—­ç¯)
            if unit_bets:
                # åˆå§‹åŒ–é´å†… UNIT çŠ¶æ€
                curr_unit_pnl = 0.0
                curr_unit_fail = 0
                curr_unit_active = False

                fail_limit = 4  # 1248 => X=4
                if "124816" in EXEC_PROFILE_OVERRIDE:
                    fail_limit = 5

                # éå†æœ¬é´æ‰€æœ‰ bet
                for bet in unit_bets:
                    pnl_by_outcome = bet["pnl"]

                    # å¦‚æœå½“å‰æ²¡æœ‰æ´»è·ƒ UNITï¼Œåˆ›å»ºæ–° UNIT
                    if not curr_unit_active:
                        curr_unit_active = True
                        curr_unit_pnl = 0.0
                        curr_unit_fail = 0

                        unit_total_cnt += 1
                        unit_created_cnt += 1

                        # FIRST_BET ç»Ÿè®¡ (æ–° UNIT çš„ç¬¬ä¸€å£)
                        first_bet_total_cnt += 1
                        first_bet_taken_cnt += 1
                        first_bet_pnl_sum += pnl_by_outcome
                        if pnl_by_outcome == 1.0:
                            first_bet_win_cnt += 1

                    # UNIT æ¨è¿›
                    if pnl_by_outcome == 0:
                        tie_seen_cnt += 1
                        tie_seen += 1
                        # TIE ä¸è®¡å¤±è´¥ï¼Œä¸è¿›å‡€å€¼
                    elif pnl_by_outcome == -1.0:
                        curr_unit_fail += 1
                        curr_unit_pnl += -1.0
                    elif pnl_by_outcome == 1.0:
                        curr_unit_pnl += 1.0

                    # æ£€æŸ¥ UNIT ç»“æŸæ¡ä»¶
                    if curr_unit_pnl > 0:
                        # æˆåŠŸå³åœ
                        unit_profit_hit_cnt += 1
                        hit_cnt += 1
                        unit_pnl_sum += curr_unit_pnl
                        if curr_unit_pnl < unit_worst_pnl:
                            unit_worst_pnl = curr_unit_pnl
                        curr_unit_active = False  # ç»“æŸï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡ bet å¼€å¯æ–° UNIT

                    elif curr_unit_fail >= fail_limit:
                        # å¤±è´¥ç»“æŸ
                        unit_fail_end_cnt += 1
                        fail_end_cnt += 1
                        unit_pnl_sum += curr_unit_pnl
                        if curr_unit_pnl < unit_worst_pnl:
                            unit_worst_pnl = curr_unit_pnl
                        curr_unit_active = False  # ç»“æŸ

                # é´å°¾å¼ºåˆ¶ç»“ç®— (å¦‚æœè¿˜æœ‰æ´»è·ƒ UNIT)
                if curr_unit_active:
                    # é¢˜ç›®è¦æ±‚ hit+fail_end == UNIT_COUNT
                    # ä¸” UNIT_PNL > 0 æ‰ç®— hit
                    # æ‰€ä»¥é´å°¾æœªå®Œæˆçš„ï¼Œå¦‚æœ PNL > 0 ç®— hit (è™½ç„¶ä¸å¤ªå¯èƒ½ï¼Œå› ä¸º >0 æ—©åœäº†)
                    # å¦åˆ™ç®— fail_end
                    if curr_unit_pnl > 0:
                        unit_profit_hit_cnt += 1
                        hit_cnt += 1
                    else:
                        unit_fail_end_cnt += 1
                        fail_end_cnt += 1

                    unit_pnl_sum += curr_unit_pnl
                    if curr_unit_pnl < unit_worst_pnl:
                        unit_worst_pnl = curr_unit_pnl

        if (cont_agg is not None) and (not SILENT_MODE):
            _cont_consume_snapshots(cont_agg, out.get("snapshots") or [])

    if total_boots > 0:
        print()  # ç»“æŸè¿›åº¦è¡Œ

    # æ›´æ–°å…¨å±€è®¡æ•°å™¨ (Gate 3 æ•‘ç«)
    UNIT_COUNT = unit_total_cnt
    FIRST_BET_COUNT = first_bet_total_cnt

    print()
    # ==================== æŠ•æ”¾é“¾è·¯ï½œå±‚å¼€å…³æ‘˜è¦ + ç›®æ ‡å±‚åˆ†å¸ƒ + å˜åŒ–ç‡è§„åˆ™æ—æ‰«æï¼ˆå•åˆ€ï¼‰ ====================
    target_stage = TARGET_STAGE if TARGET_STAGE in _STAGE_LIST else "L4"
    stage_on = {s: _stage_enabled(s) for s in _STAGE_LIST}
    called = {s: False for s in _STAGE_LIST}
    if RULESCAN_ON and stage_on.get(target_stage, False):
        called[target_stage] = True
    if AUDIT_RUN:
        for s in _STAGE_LIST:
            if stage_on.get(s, False):
                called[s] = True
    # reach_targetï¼šåªè®¤â€œé˜¶æ®µå¿«ç…§æ± â€é‡Œç›®æ ‡å±‚çš„ StageSnapï¼ˆstage==snap_source==target_stageï¼‰
    reach_target = 0
    if stage_on.get(target_stage, False):
        for out in boots_out:
            if not out.get("entry"):
                continue
            snaps = out.get("stage_snaps") or []
            if any(isinstance(x,
                              StageSnap) and x.stage == target_stage and x.snap_source == target_stage and x.bet_n == int(
                target_stage[1:]) for x in snaps):
                reach_target += 1

    try:
        entry_pct2 = (total_entry / total_boots * 100.0) if total_boots else 0.0
        reach_pct2 = (reach_target / total_boots * 100.0) if total_boots else 0.0
    except Exception:
        entry_pct2 = 0.0
        reach_pct2 = 0.0

    # Node 1 Goal C: Minimal Console Mode (Suppress large blocks)
    if not MINIMAL_CONSOLE_MODE:
        print(
            "å±‚å¼€å…³æ‘˜è¦ï¼š"

            + " | ".join([f"{s}={'å¼€' if stage_on[s] else 'å…³'}/è°ƒç”¨={'1' if called[s] else '0'}" for s in _STAGE_LIST])
            + f" | chain_entry={total_entry}({entry_pct2:.2f}%) | reach_target={reach_target}({reach_pct2:.2f}%) | ç›®æ ‡å±‚={target_stage} | è§„åˆ™æ—={'å¼€' if RULESCAN_ON else 'å…³'}"
        )

    # Node 3: Panel Snapshot (Always printed if L4 panel is enabled, or just print it)
    print("------------------------------------------------------------")
    print("ã€Node3ï½œé¢æ¿å¿«ç…§ã€‘")
    print(f"RUN_MODE_CN: {RUN_MODE_CN}")
    print(f"å»¶è¿Ÿç»“æ„(is_delay): {'ON' if _is_delay else 'OFF'}")
    print(f"DIFF_BUCKET_SCHEME: {DIFF_BUCKET_SCHEME}")
    print(f"L1_DIFF_ALLOW_UI: {L1_DIFF_ALLOW_UI}")
    print(f"L1_RATE_ALLOW_UI: {L1_RATE_ALLOW_UI}")
    print(f"L4_DIFF_ALLOW_UI: {L4_DIFF_ALLOW_UI}")
    print(f"L4_RATE_ALLOW_UI: {L4_RATE_ALLOW_UI}")
    print(f"è§„åˆ™æ—æ‰«æ: {'ON' if SCAN_ENABLE else 'OFFï¼ˆNode3é»˜è®¤ï¼‰'}")
    print("------------------------------------------------------------")

    # Node 1 Goal B: L4 Report Panel Toggle (Wrap detailed distribution/rule scan)
    if ENABLE_L4_REPORT_PANEL:
        # Node 3: Force SCAN_ENABLE check
        _effective_scan = (RULESCAN_ON and SCAN_ENABLE)

        print(
            f"è§„åˆ™æ—å‚æ•°ï¼šæœ€å°å‘½ä¸­æ•°={RULESCAN_MIN_CNT} | TopN={RULESCAN_TOPN} | æ‰«æå½¢æ€=å•æ¡¶/åŒæ¡¶AND/ä¸¤å•æ¡¶OR | ORé€€åŒ–è¿‡æ»¤=Stop%>=99% + æ’çœŸå¼ï¼ˆä»…ORï¼‰")

        # ç›®æ ‡å±‚æœªå¯ç”¨ï¼šæŒ‰å¥‘çº¦ä¸å†™å¿«ç…§ã€ä¸å…¥æ ·æœ¬æ± 
        if not stage_on.get(target_stage, False):
            print(f"[{target_stage}] ç›®æ ‡å±‚æœªå¯ç”¨ï¼šæŒ‰å¥‘çº¦ä¸å†™é˜¶æ®µå¿«ç…§ã€ä¸å…¥æ ·æœ¬æ± ï¼Œè·³è¿‡åˆ†å¸ƒ/è§„åˆ™æ—æ‰«æ")
        else:
            pool = []  # (StageSnap, delta)
            dist_rate = {}
            dist_diff = {}

            if ENABLE_MEAN_FEATURE:
                dist_mean = {}
                miss_mean = {}

            miss_rate = {}

            cnt_rate_nonneg = 0
            cnt_rate_ge2 = 0
            ex_rate_nonneg = []  # (file_idx, boot_id, snap_seq, rate_text)
            ex_rate_ge2 = []  # (file_idx, boot_id, snap_seq, rate_text)
            # Î” è‡ªè¯è®¡æ•°ï¼ˆåäº‹å®å¢ç›Šï¼‰
            cnt_delta_nonzero = 0
            cnt_stop_missing = 0
            cnt_stop_eq_final = 0
            ex_delta = []  # (file_idx, boot_id, snap_seq, profit_stop, profit_final, delta)

            def _inc(d: dict, k: str, n: int = 1) -> None:
                d[k] = d.get(k, 0) + n

            # ä»… reach_target çš„ç›®æ ‡å±‚æ ·æœ¬å…¥æ± ï¼ˆåªä»é˜¶æ®µå¿«ç…§æ± å–æ•°ï¼Œä¸¥ç¦ records/ç´¢å¼•å›è¯»ï¼‰
            for out in boots_out:
                if not out.get("entry"):
                    continue
                snaps = out.get("stage_snaps") or []
                pairs = [(i, x) for i, x in enumerate(snaps) if
                         isinstance(x, StageSnap) and x.stage == target_stage and x.snap_source == target_stage]
                if not pairs:
                    continue
                pairs.sort(key=lambda t: int(getattr(t[1], "snap_seq", 0) or 0))
                best_idx, snap = pairs[-1]  # ç›®æ ‡å±‚å–æœ«æ¡å¿«ç…§ï¼ˆsnap_seq æœ€å¤§ï¼‰
                # åäº‹å®å¢ç›Šå£å¾„é”æ­»ï¼šÎ” = profit_stop(å‘½ä¸­æ—¶åˆ»å·²çœŸå®ç»“ç®—) âˆ’ profit_baseline(è£¸è·‘æœ€ç»ˆ)
                _p_base = float(out.get("profit", 0.0) or 0.0)
                _profits = out.get("stage_snap_profits", [])
                if (best_idx < 0) or (best_idx >= len(_profits)):
                    cnt_stop_missing += 1
                    _p_stop_raw = None
                    _p_stop = 0.0
                else:
                    _p_stop_raw = _profits[best_idx]
                    _p_stop = float(_p_stop_raw or 0.0)
                p = _p_stop - _p_base
                if abs(p) > 1e-12:
                    cnt_delta_nonzero += 1
                    if len(ex_delta) < 5:
                        ex_delta.append((out.get("file_idx"), out.get("boot_id"), snap.snap_seq, _p_stop, _p_base, p))
                else:
                    if (_p_stop_raw is not None) and (abs(_p_stop - _p_base) <= 1e-12):
                        cnt_stop_eq_final += 1
                pool.append((snap, p))

                # å˜åŒ–ç‡åŸå€¼è‡ªè¯ï¼šä»…ç»Ÿè®¡ç›®æ ‡å±‚é˜¶æ®µå¿«ç…§ï¼ˆç”¨äºåˆ¤å®šåŠ é€Ÿ/æå€¼æ˜¯å¦ä¸º 0 çš„â€œæ•°æ®äº‹å®â€ï¼‰
                rv = snap.rate_raw
                if rv is not None:
                    if rv >= 0:
                        cnt_rate_nonneg += 1
                        if len(ex_rate_nonneg) < 5:
                            ex_rate_nonneg.append(
                                (out.get("file_idx"), out.get("boot_id"), snap.snap_seq, snap._rate_raw_text))
                    if rv >= 2:
                        cnt_rate_ge2 += 1
                        if len(ex_rate_ge2) < 5:
                            ex_rate_ge2.append(
                                (out.get("file_idx"), out.get("boot_id"), snap.snap_seq, snap._rate_raw_text))

                rb = stage_rate_bucket(snap, target_stage)
                _inc(dist_rate, rb)
                _inc(dist_diff, snap.diff_bucket)

                if ENABLE_MEAN_FEATURE:
                    _inc(dist_mean, snap.mean_bucket)

                if snap.rate_raw is None:
                    _inc(miss_rate, snap._rate_raw_text if snap._rate_raw_text is not None else "")

                if ENABLE_MEAN_FEATURE:
                    if snap.mean_raw is None:
                        _inc(miss_mean, snap._mean_raw_text if snap._mean_raw_text is not None else "")

            N = len(pool)
            if called.get(target_stage, False):
                if N == 0:
                    print(f"[{target_stage}_ç›®æ ‡å±‚åˆ†å¸ƒ] N=0ï¼ˆreach_target=0ï¼‰ï¼Œè·³è¿‡åˆ†å¸ƒ/è§„åˆ™æ—æ‰«æ")
                else:
                    parts = []
                    if target_stage in ("L2", "L3", "L4"):
                        _order = ["å‡é€Ÿ", "åŠ é€Ÿ", "æå€¼", "æ— æ•ˆ"]
                    elif target_stage == "L1":
                        _order = ["å‰å°", "å‰å¤§", "æå€¼", "æ— æ•ˆ"]
                    else:
                        _order = sorted(dist_rate.keys())
                    for k in _order:
                        v = dist_rate.get(k, 0)
                        parts.append(f"{k}:{v}({(v / N * 100.0) if N else 0.0:.1f}%)")
                    print(f"[{target_stage}_å˜åŒ–ç‡åˆ†å¸ƒ] " + " | ".join(parts) + f" | N={N}")
                    print(
                        f"[{target_stage}_å˜åŒ–ç‡åŸå€¼è‡ªè¯] >=0:{cnt_rate_nonneg}({(cnt_rate_nonneg / N * 100.0) if N else 0.0:.1f}%) | >=2:{cnt_rate_ge2}({(cnt_rate_ge2 / N * 100.0) if N else 0.0:.1f}%) | æ ·ä¾‹>=0 Top5={ex_rate_nonneg} | æ ·ä¾‹>=2 Top5={ex_rate_ge2}")

                    parts = []
                    for k in [str(i) for i in range(0, 10)] + ["9+"]:
                        v = dist_diff.get(k, 0)
                        parts.append(f"{k}:{v}({(v / N * 100.0):.1f}%)")
                    print(f"[{target_stage}_ç‚¹å·®åˆ†å¸ƒ] " + " | ".join(parts) + f" | N={N}")

                    # Node 3: Mean distribution wrapped
                    if ENABLE_MEAN_FEATURE:
                        parts = []
                        for k in ["|å‡å·®|<3", "|å‡å·®|>=3", "mean=0", "æ— æ•ˆ"]:
                            v = dist_mean.get(k, 0)
                            parts.append(f"{k}:{v}({(v / N * 100.0):.1f}%)")
                        print(f"[{target_stage}_å‡å·®åˆ†å¸ƒ] " + " | ".join(parts) + f" | N={N}")

                    def _topn(d: dict, n: int = 5):
                        return sorted(d.items(), key=lambda x: (-x[1], x[0]))[:n]

                    rate_miss = sum(miss_rate.values())

                    if rate_miss:
                        top = ", ".join([f"'{k}':{v}" for k, v in _topn(miss_rate, 5)])
                        print(f"[{target_stage}_å˜åŒ–ç‡æ— æ•ˆ] cnt={rate_miss}({rate_miss / N * 100.0:.1f}%) | Top5={top}")

                    if ENABLE_MEAN_FEATURE:
                        mean_miss = sum(miss_mean.values())
                        if mean_miss:
                            top = ", ".join([f"'{k}':{v}" for k, v in _topn(miss_mean, 5)])
                            print(
                                f"[{target_stage}_å‡å·®æ— æ•ˆ] cnt={mean_miss}({mean_miss / N * 100.0:.1f}%) | Top5={top}")

            # Entry/MinHit å…œåº•ï¼šç¡®ä¿ reach_target=0 æ—¶ä¹Ÿå¯æ‰“å°Î”è‡ªè¯ä¸”ä¸å´©
            Entry = int(N or 0)
            MIN_HIT = RULESCAN_MIN_CNT
            if _effective_scan and called.get(target_stage, False) and N:
                Entry = N
                MIN_HIT = RULESCAN_MIN_CNT

                print("")
            print(
                f"[{target_stage}_Î”è‡ªè¯] é0Î”={cnt_delta_nonzero}({(cnt_delta_nonzero / Entry * 100.0) if Entry else 0.0:.1f}%) | stopç¼ºå¤±={cnt_stop_missing} | stop==final={cnt_stop_eq_final} | Top5={ex_delta}")
            # Î”è‡ªè¯ä½œåºŸé˜ˆå€¼ï¼ˆå†»ç»“åŒºé”æ­»ï¼‰ï¼šæ»¡è¶³ä»»ä¸€æ¡å³ä½œåºŸ
            delta_void = False
            void_reason = ""
            if Entry > 0:
                if cnt_stop_missing > 0:
                    delta_void = True
                    void_reason = "stopç¼ºå¤±>0"
                elif cnt_stop_eq_final == Entry:
                    delta_void = True
                    void_reason = "stop==final==Entry"
                elif cnt_delta_nonzero == 0:
                    delta_void = True
                    void_reason = "é0Î”==0ä¸”Entry>0"
            cnt_nonzero_delta_eq0 = max(0, Entry - cnt_delta_nonzero)
            if N == 0:
                print(f"è§„åˆ™æ—æ‰«æå·²è·³è¿‡ï¼šreach_target=0")
            elif DELTA_AUDIT_ON and delta_void:
                print(
                    f"[{target_stage}_Î”ä½œåºŸ] âœ… ä½œåºŸåŸå› ={void_reason} | stopç¼ºå¤±={cnt_stop_missing} | stop==final={cnt_stop_eq_final} | é0Î”==0={cnt_nonzero_delta_eq0}")
                if DELTA_AUDIT_ENFORCE:
                    raise RuntimeError(f"Î”ä½œåºŸè§¦å‘ï¼š{void_reason}")
                print(f"è§„åˆ™æ—æ‰«æå·²è·³è¿‡ï¼šÎ”ä½œåºŸ({void_reason})")
            else:
                print(
                    f"è§„åˆ™æ—æ‰«æï¼ˆç›®æ ‡å±‚={target_stage}ï½œEntry={reach_target}ï½œMinHit={MIN_HIT}ï½œæ‰«æ=å•æ¡¶+åŒæ¡¶AND+ä¸¤å•æ¡¶ORï½œä¸æ‰«ä¸‰æ¡¶ï¼‰")
                if _effective_scan:
                    # é¢„è®¡ç®—æ ·æœ¬æ ‡ç­¾
                    tag_rows = []  # (rate_bucket, diff_bucket, mean_bucket, pnl)
                    obs_rate, obs_diff = set(), set()
                    if ENABLE_MEAN_FEATURE:
                        obs_mean = set()

                    for snap, pnl in pool:
                        rb = stage_rate_bucket(snap, target_stage)
                        db = snap.diff_bucket

                        if ENABLE_MEAN_FEATURE:
                            mb = snap.mean_bucket
                            tag_rows.append((rb, db, mb, pnl))
                            obs_mean.add(mb)
                        else:
                            tag_rows.append((rb, db, None, pnl))

                        obs_rate.add(rb)
                        obs_diff.add(db)

                    single = defaultdict(lambda: [0, 0.0])  # (field,val) -> [cnt,sum]
                    rate_diff = defaultdict(lambda: [0, 0.0])  # (rb,db) -> [cnt,sum]

                    if ENABLE_MEAN_FEATURE:
                        rate_mean = defaultdict(lambda: [0, 0.0])  # (rb,mb) -> [cnt,sum]
                        diff_mean = defaultdict(lambda: [0, 0.0])  # (db,mb) -> [cnt,sum]

                    for rb, db, mb, pnl in tag_rows:
                        single[("rate", rb)][0] += 1
                        single[("rate", rb)][1] += pnl
                        single[("diff", db)][0] += 1
                        single[("diff", db)][1] += pnl

                        if ENABLE_MEAN_FEATURE:
                            single[("mean", mb)][0] += 1
                            single[("mean", mb)][1] += pnl

                        rate_diff[(rb, db)][0] += 1
                        rate_diff[(rb, db)][1] += pnl

                        if ENABLE_MEAN_FEATURE:
                            rate_mean[(rb, mb)][0] += 1
                            rate_mean[(rb, mb)][1] += pnl
                            diff_mean[(db, mb)][0] += 1
                            diff_mean[(db, mb)][1] += pnl

                    def _cond_str(field: str, val: str) -> str:
                        if field == "rate":
                            return f"rate={val}"
                        if field == "diff":
                            return f"diff={val}"
                        if field == "mean":
                            return f"mean={val}"
                        return f"{field}={val}"

                    def _rule_id_and(parts):
                        # parts: list of (field,val)
                        inner = "&".join([_cond_str(f, v) for f, v in parts])
                        return f"{target_stage}|{inner}"

                    def _rule_id_or(a, b):
                        sa = _cond_str(a[0], a[1])
                        sb = _cond_str(b[0], b[1])
                        return f"{target_stage}|{sa} OR {sb}"

                    def _add(rows, kind: str, rule_id: str, hit_cnt: int, sum_pnl: float):
                        if hit_cnt < MIN_HIT:
                            return
                        delta_sum = sum_pnl
                        delta_avg = delta_sum / Entry
                        stop_pct = hit_cnt / Entry
                        rows.append({
                            "kind": kind,
                            "rule_id": rule_id,
                            "hit": hit_cnt,
                            "stop_pct": stop_pct,
                            "delta_sum": delta_sum,
                            "delta_avg": delta_avg,
                        })

                    rows = []

                    # â‘  å•æ¡¶
                    for (field, val), (cnt, s) in single.items():
                        _add(rows, "SINGLE", f"{target_stage}|{_cond_str(field, val)}", cnt, s)

                    # â‘¡ åŒæ¡¶ç»„åˆï¼ˆANDï¼‰
                    for (rb, db), (cnt, s) in rate_diff.items():
                        _add(rows, "AND", _rule_id_and([("rate", rb), ("diff", db)]), cnt, s)

                    if ENABLE_MEAN_FEATURE:
                        for (rb, mb), (cnt, s) in rate_mean.items():
                            _add(rows, "AND", _rule_id_and([("rate", rb), ("mean", mb)]), cnt, s)
                        for (db, mb), (cnt, s) in diff_mean.items():
                            _add(rows, "AND", _rule_id_and([("diff", db), ("mean", mb)]), cnt, s)

                    # â‘£ OR å¹¶é›†ï¼ˆä»…ä¸¤å•æ¡¶ ORï¼‰
                    singles = list(single.keys())  # (field,val)

                    def _get_single(k):
                        v = single.get(k)
                        if not v:
                            return (0, 0.0)
                        return v[0], v[1]

                    def _get_intersection(a, b):
                        fa, va = a
                        fb, vb = b
                        if fa == fb:
                            if va == vb:
                                cnt, s = _get_single(a)
                                return cnt, s
                            return 0, 0.0
                        # rate/diff
                        if {fa, fb} == {"rate", "diff"}:
                            r = va if fa == "rate" else vb
                            d = vb if fb == "diff" else va
                            cnt, s = rate_diff.get((r, d), (0, 0.0))
                            return cnt, s

                        if ENABLE_MEAN_FEATURE:
                            # rate/mean
                            if {fa, fb} == {"rate", "mean"}:
                                r = va if fa == "rate" else vb
                                m = vb if fb == "mean" else va
                                cnt, s = rate_mean.get((r, m), (0, 0.0))
                                return cnt, s
                            # diff/mean
                            if {fa, fb} == {"diff", "mean"}:
                                d = va if fa == "diff" else vb
                                m = vb if fb == "mean" else va
                                cnt, s = diff_mean.get((d, m), (0, 0.0))
                                return cnt, s

                        return 0, 0.0

                    tautology_or_filtered = 0

                    def _is_tautology_or(a, b) -> bool:
                        # a/b å½¢å¦‚ ('diff','6') / ('rate','å‡é€Ÿ') / ('mean','|å‡å·®|<3') ç­‰
                        try:
                            fa, va = a
                            fb, vb = b
                        except Exception:
                            return False
                        if fa != fb:
                            return False
                        if fa == "diff":
                            universe = {str(i) for i in range(0, 10)} | {"9+"}
                        elif fa == "rate":
                            universe = {"å‡é€Ÿ", "åŠ é€Ÿ", "æå€¼", "æ— æ•ˆ"}
                        elif fa == "mean":
                            universe = {"|å‡å·®|<3", "|å‡å·®|>=3", "mean=0", "æ— æ•ˆ"}
                        else:
                            return False
                        return {va, vb} == universe

                    for i in range(len(singles)):
                        for j in range(i + 1, len(singles)):
                            a = singles[i]
                            b = singles[j]
                            if _is_tautology_or(a, b):
                                tautology_or_filtered += 1
                                continue
                            cnt_a, sum_a = _get_single(a)
                            cnt_b, sum_b = _get_single(b)
                            cnt_ab, sum_ab = _get_intersection(a, b)
                            cnt_or = cnt_a + cnt_b - cnt_ab
                            sum_or = sum_a + sum_b - sum_ab
                            _add(rows, "OR", _rule_id_or(a, b), cnt_or, sum_or)

                    # ç»Ÿè®¡è¾“å‡ºï¼ˆA/B/C ä¸‰ç§ä¸»æ’åºï¼‰
                    # é€€åŒ–è§„åˆ™è¿‡æ»¤ï¼šStop%è¿‡é«˜é€šå¸¸ç­‰ä»·â€œå…¨è¦†ç›–åœæ‰‹â€ï¼Œä¿¡æ¯é‡ä½ï¼ˆå¼€å‘æœŸå…ˆç›´æ¥è¿‡æ»¤ï¼‰
                    RULESCAN_DEGEN_STOP_PCT = 0.99
                    _deg_cnt = 0
                    if rows:
                        for _r in rows:
                            if (_r.get("kind") == "OR") and (_r.get("stop_pct", 0.0) >= RULESCAN_DEGEN_STOP_PCT):
                                _deg_cnt += 1
                        if _deg_cnt:
                            rows = [_r for _r in rows if
                                    not ((_r.get("kind") == "OR") and (
                                            _r.get("stop_pct", 0.0) >= RULESCAN_DEGEN_STOP_PCT))]
                            print(
                                f"ï¼ˆé€€åŒ–è§„åˆ™å·²è¿‡æ»¤ï¼š{_deg_cnt} æ¡ï½œé˜ˆå€¼ Stop%â‰¥{RULESCAN_DEGEN_STOP_PCT * 100:.1f}%ï½œæ’çœŸORå·²è¿‡æ»¤ï¼š{tautology_or_filtered} æ¡ï¼‰")

                    def _fmt_num(x: float, nd=2):
                        sign = "+" if x >= 0 else ""
                        return f"{sign}{x:.{nd}f}"

                    def _print_top(title: str, key_fn):
                        top = sorted(rows, key=key_fn, reverse=True)[:RULESCAN_TOPN]
                        print("")
                        print(title)
                        if not top:
                            print("ï¼ˆæ— æ»¡è¶³ MinHit çš„å€™é€‰ï¼‰")
                            return
                        for r in top:
                            print(
                                f"{r['rule_id']}: Stop%={r['stop_pct'] * 100:.1f}%({r['hit']}/{Entry})ï¼Œ"
                                f"Î”Sum={_fmt_num(r['delta_sum'], 2)}ï¼ŒÎ”Avg={_fmt_num(r['delta_avg'], 4)}"
                            )

                    # å´©æºƒä¿®å¤ï¼šå½“æ— æœ‰æ•ˆè§„åˆ™æ—¶ï¼Œè·³è¿‡ Top / OOS æŠ¥å‘Šæ‰“å°ï¼ˆé¿å…ç©ºå€™é€‰å¯¼è‡´ç´¢å¼•è¶Šç•Œå´©æºƒï¼‰
                    _max_hit = max((r.get("hit", 0) for r in rows), default=0)
                    if (not rows) or (_max_hit < RULESCAN_MIN_CNT):
                        print("")
                        print(f"ï¼ˆæ— æœ‰æ•ˆè§„åˆ™ï¼šrows={len(rows)}ï¼ŒMaxHit={_max_hit}ï¼ŒMinHit={RULESCAN_MIN_CNT}ï¼›è·³è¿‡Top/OOSï¼‰")
                    else:
                        _print_top("Topï¼ˆä¸»æ’åº=Î”Avgï¼‰", lambda r: r["delta_avg"])
                        _print_top("Topï¼ˆä¸»æ’åº=Î”Sumï¼‰", lambda r: r["delta_sum"])
                        _print_top("Topï¼ˆä¸»æ’åº=Stop%ï¼‰", lambda r: r["stop_pct"])
                else:
                    print("è§„åˆ™æ—æ‰«æ=OFFï¼ˆNode3é»˜è®¤ï¼‰")
            # ==================== æŠ•æ”¾é“¾è·¯ END ====================
    else:
        # Node 1 Goal B: L4 Panel Hidden
        pass

    print("============================================================")
    print("ğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°")
    print("============================================================")
    print(title)
    print("============================================================")
    # --- æ ¸å¿ƒç»“æœï¼ˆæ¯æ¬¡è·‘å¿…å‡ºï½œä¸ºç­–ç•¥å®˜/å†™æ‰‹çœ‹ç»“æœï¼‰ ---
    _struct_line, _struct_hash = _get_struct_summary_line_and_hash()
    print(_struct_line)

    if not MINIMAL_CONSOLE_MODE:
        print(f"AnchorMode={STRUCT_ANCHOR_MODE}")
        print("PreSW=LEADER_AS_TEMP | Tie=KEEP_LAST | Fallback=FIRST_VALID_WINNER | Switch=B1_RESET_TO_STEP1")
        print("T/0=SHIFT_ONLY_NO_BREAK")
        _bon, _an, _raw = _get_boot_filter_effective()  # é´çº§è‡ªè¯éœ€è¦ï¼Œé¿å…æœªèµ‹å€¼
        try:
            _fa = BOOT_FILTER_RULE.get("forbidden_action")
        except Exception:
            _fa = "NA"
            _bon, _an, _raw = _get_boot_filter_effective()
        print(f"BOOT_FILTER={'ON' if _bon else 'OFF'} + forbidden_action={_fa}")

    _avg_pnl = (total_profit / total_entry) if total_entry else 0.0
    print(f"ğŸ’¶ğŸ’¶ğŸ’¶ å•æ¬¡å¹³å‡å¢ç›Š: {_avg_pnl:.6f}")
    print(f"ğŸ’¶ğŸ’¶ğŸ’¶ æ€»å‡€å€¼å¢ç›Š  : {total_profit:.2f}")

    # Node 1 Goal D: Zero Entry Hard Checkï¼ˆæ”¹ä¸ºï¼šå…è®¸0è§¦å‘è¾“å‡ºè‡ªè¯ï¼Œä¸å†å´©æºƒï¼›å¹¶ç›´æ¥ returnï¼Œé¿å…ç»§ç»­æ‰“å°ğŸ¯ï¼‰
    if total_entry == 0:
        print("èŠ‚ç‚¹=ENTRY_ZERO|ALLOW=1|total_entry=0")
        print(f"èŠ‚ç‚¹={NODE_TAG} | ç»“æ„={_struct_line} | å‡€å€¼={total_profit:.2f}")
        return

    # Node 1 Goal C: Node Acceptance Line
    print(f"èŠ‚ç‚¹={NODE_TAG} | ç»“æ„={_struct_line} | å‡€å€¼={total_profit:.2f}")

    # Node 1 Goal C: Minimal Console Mode (Suppress large blocks)
    if not MINIMAL_CONSOLE_MODE:
        # Node 7: UNIT=1248 æŠ¥è¡¨å£å¾„è¾“å‡º
        print("------------------------------------------------------------")
        print("UNIT=1248 æŠ¥è¡¨å£å¾„ï¼ˆNode 7 è¡¥ä¸ï¼‰")
        print(f"UNIT_MODE=MARTIN_1248")
        print(f"PROFIT_TARGET=B (ç›ˆåˆ©é˜ˆå€¼å‘½ä¸­)")
        print(
            f"UNIT_MODE=... | FAIL_LIMIT_X=4 | HIT_DEF=UNIT_PNL>0 | FAIL_DEF=PNL=-1 only | TIE_SKIP_FAIL=1 | UNIT_START=FIRST_ğŸ¯")

        # Gate 3_A: å¯è¡Œæ€§åˆ¤å®šè‡ªè¯
        # æ£€æŸ¥æ˜¯å¦ä»ä¸ºä¸€æ¬¡æ€§äº¤æ˜“
        # ç”±äºæˆ‘ä»¬æ— æ³•ç›´æ¥è¯»å– run_strategy_on_boot å†…éƒ¨çš„é€»è¾‘ï¼Œåªèƒ½é€šè¿‡ avg_len åˆ¤æ–­
        # å¦‚æœ avg_len > 1ï¼Œè¯´æ˜å·²ç»çªç ´äº†ä¸€æ¬¡æ€§äº¤æ˜“é™åˆ¶
        # å¦‚æœ avg_len == 1ï¼Œè¯´æ˜å¯èƒ½ä»å—é™
        # ä½†é¢˜ç›®è¦æ±‚æ‰“å° GATE3_A è¡Œ
        # å‡è®¾æˆ‘ä»¬æ— æ³•åœ¨é”šç‚¹2å†…è§£é™¤ä¸€æ¬¡æ€§äº¤æ˜“é™åˆ¶ï¼ˆå› ä¸ºé‚£æ˜¯ run_strategy_on_boot çš„é€»è¾‘ï¼Œåœ¨é”šç‚¹2ä¹‹å¤–ï¼‰
        # é‚£ä¹ˆ avg_len å¿…ç„¶ä¸º 1
        # æ‰€ä»¥æˆ‘ä»¬å¿…é¡»å¦‚å®æ‰“å°

        # è®¡ç®—å¹³å‡é•¿åº¦
        avg_len = (bet_total_cnt / unit_total_cnt) if unit_total_cnt > 0 else 0.0

        can_multi = 1 if avg_len > 1.0 else 0
        reason = "OK" if can_multi else "ONE_TIME_TRADE_LOCKED"
        print(f"GATE3_A: can_multi_bet_unit={can_multi} | reason={reason}")

        # Gate 3_B: äºŒé€‰ä¸€
        if can_multi:
            # é€‰é¡¹1ï¼ˆå¯è¡Œï¼‰
            pass  # å·²åœ¨ä¸Šé¢æ‰“å°äº† UNIT_LEN_DEBUG ç­‰
        else:
            # é€‰é¡¹2ï¼ˆä¸å¯è¡Œï¼‰ï¼šæ­£å¼å®£å‘Š
            print("GATE3_B: 1248_chain=UNSUPPORTED_UNDER_ONE_TIME_TRADE")
            print("GATE3_B: fallback=FIRST_BET_ONLY (unit_len fixed to 1)")

        # Node 7: æ‰“å° DEBUG è‡ªè¯è¡Œ
        print(
            f"UNIT_LEN_DEBUG: avg_len={avg_len:.2f} | max_len=NA | total_bets={bet_total_cnt} | units={unit_total_cnt}")

        check_end = (unit_profit_hit_cnt + unit_fail_end_cnt == unit_total_cnt)
        print(
            f"UNIT_END_DEBUG: hit={unit_profit_hit_cnt} | fail_end={unit_fail_end_cnt} | tie_seen={tie_seen_cnt} | check_end={check_end}")

        print(f"UNIT_DEBUG: created={unit_created_cnt} | UNIT_COUNT={unit_total_cnt}")
        print(f"FIRST_BET_DEBUG: taken={first_bet_taken_cnt} | FIRST_BET_COUNT={first_bet_total_cnt}")
        print(f"EVENT_DEBUG: bet_count={bet_total_cnt} | note=UNIT/FIRST_BET must be driven by ğŸ¯ settle event")
        print(f"UNIT_DEBUG_SUMMARY: hit={unit_profit_hit_cnt} | fail_end={unit_fail_end_cnt} | tie_seen={tie_seen_cnt}")

        unit_hit_rate = (unit_profit_hit_cnt / unit_total_cnt * 100.0) if unit_total_cnt > 0 else 0.0
        print(f"UNIT_HIT_RATE={unit_hit_rate:.2f}% ({unit_profit_hit_cnt}/{unit_total_cnt})")

        match_rate = (total_match / total_entry * 100.0) if total_entry > 0 else 0.0
        print(f"MATCH_RATE={match_rate:.2f}% ({total_match}/{total_entry})")

        unit_pnl_avg = (unit_pnl_sum / unit_total_cnt) if unit_total_cnt > 0 else 0.0
        print(f"UNIT_PNL_SUM={unit_pnl_sum:.2f} | UNIT_PNL_AVG={unit_pnl_avg:.4f}")
        print(f"UNIT_WORST={unit_worst_pnl:.2f}")

        # BET å±‚è¾“å‡º
        bet_win_rate = (bet_win_cnt / bet_total_cnt * 100.0) if bet_total_cnt > 0 else 0.0
        print(f"BET_COUNT={bet_total_cnt}")
        print(f"BET_WINRATE={bet_win_rate:.2f}% ({bet_win_cnt}/{bet_total_cnt})")
        print(f"BET_PNL_SUM={bet_pnl_sum:.2f}")

        # FIRST_BET å±‚è¾“å‡º
        first_bet_win_rate = (first_bet_win_cnt / first_bet_total_cnt * 100.0) if first_bet_total_cnt > 0 else 0.0
        print(f"FIRST_BET_COUNT={first_bet_total_cnt}")
        print(f"FIRST_BET_WINRATE={first_bet_win_rate:.2f}% ({first_bet_win_cnt}/{first_bet_total_cnt})")
        print(f"FIRST_BET_PNL_SUM={first_bet_pnl_sum:.2f}")

        # ä¸€è‡´æ€§è‡ªè¯
        print(f"SINGLE_BET_IDENTITY: FIRST_BET_COUNT==BET_COUNT==reach_target")

        # Node16ï½œå¤±è´¥åé“¾è·¯è‡ªè¯ï¼ˆæœ€å° 1 è¡Œï¼Œä¸åˆ·å±ï¼›ä¸å½±å“é€»è¾‘ï¼‰
        try:
            _st = globals().get("_SHELL_GATE_STATS") or {}
            _l1_drop = int(_st.get("drop_L1", 0)) if isinstance(_st, dict) else 0
            _l4_pass = int(_st.get("l4_cand_pass", 0)) if isinstance(_st, dict) else 0
            _l4_fail = int(_st.get("l4_cand_fail", 0)) if isinstance(_st, dict) else 0
        except Exception:
            _l1_drop, _l4_pass, _l4_fail = 0, 0, 0
        print(f"èŠ‚ç‚¹=CHAIN_IDENTITY|L1_BET={bet_total_cnt}|L1_DROP={_l1_drop}|L4_CAND_PASS={_l4_pass}|L4_CAND_FAIL={_l4_fail}|L4_PREBLOCK=0")

        # æŠ½æ ·è‡ªè¯
        print("------------------------------------------------------------")
        print("ç»“ç®—çœŸæºè‡ªè¯ (Top 5)")
        for i, sample in enumerate(bet_audit_samples):
            print(
                f"{i + 1}. BET_SIDE={sample['BET_SIDE']} | OUTCOME_SIDE={sample['OUTCOME_SIDE']} | PNL_BY_OUTCOME={sample['PNL_BY_OUTCOME']}")
        print("------------------------------------------------------------")

        if AUDIT_RUN:
            print("æ‰«ææ–¹å¼ï¼šä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“")
            print("æ®µé•¿å£å¾„ï¼šç¦æ­¢è·¨æ®µç´¯è®¡")
            print("æœ¯è¯­é”æ­»ï¼šåªæ‰¿è®¤ã€Œâ­ / æŠ•æ”¾ç‚¹ã€")
            _print_switches_block("HEADER")
            # è¡¨å¤´å¼€å…³è‡ªè¯ï¼ˆé”æ­»ï¼‰ï¼šå³ä½¿é™é»˜æ¨¡å¼ä¹Ÿå¿…é¡»æ‰“å°ï¼ˆä»¥ä¸‹ä¸¤è¡Œä¿ç•™ä½†æ”¹ä¸ºåŠ¨æ€å£å¾„ï¼‰
            print(f"ç»“æ„é—¸é—¨ï¼š{STRUCT_SCAN_TEXT}")
            print(f"é´çº§å¼€å…³ï¼š{_boot_filter_label()}")
            _sl, _sh = _get_struct_summary_line_and_hash()
            print(_sl)
            print(f"AnchorMode={STRUCT_ANCHOR_MODE}")
            print("PreSW=LEADER_AS_TEMP | Tie=KEEP_LAST | Fallback=FIRST_VALID_WINNER | Switch=B1_RESET_TO_STEP1")
            print("T/0=SHIFT_ONLY_NO_BREAK")
            print(
                f"BOOT_FILTER={'ON' if _get_boot_filter_effective()[0] else 'OFF'} + forbidden_action={BOOT_FILTER_RULE.get('forbidden_action', 'NA')}")
            global _STRUCT_SUMMARY_PRINTED
            _STRUCT_SUMMARY_PRINTED = True
            print(f"ç›‘æµ‹å¼€å…³ï¼š{'å¼€' if MONITOR_ENABLE else 'å…³'}")
            print("é˜ˆå€¼å‡»ç©¿å½’å› ï¼šè·¯å¾„å¿«ç…§ï¼ˆæ¯æ¬¡å®é™…æŠ•æ”¾å‰éƒ½å¿«ç…§ï¼›å«çŠ¶æ€ T åçš„é‡å¤æŠ•æ”¾ï¼›å½’å› åªç”¨å¿«ç…§ï¼‰")
            print("------------------------------------------------------------")
            print("TOTAL_BOOT       :", total_boots)
            print("------------------------------------------------------------")
            print("æ€»æ‰¹æ¬¡æ•°    :", total_boots)
            print("å¯å‚ä¸æ‰¹æ¬¡æ•°:", playable_boots)
            print("è·³è¿‡æ‰¹æ¬¡æ•°  :", skipped_boots)
            print("------------------------------------------------------------")
            entry_pct = (total_entry / total_boots * 100.0) if total_boots > 0 else 0.0
            print(f"æ¿€æ´»æ¬¡æ•°    : {total_entry} ({entry_pct:.2f}%)")
            match_pct = (total_match / total_entry * 100.0) if total_entry > 0 else 0.0
            mismatch_pct = (total_mismatch / total_entry * 100.0) if total_entry > 0 else 0.0
            print(f"åŒ¹é…æ¬¡æ•°    : {total_match} ({match_pct:.2f}%)")
            print(f"ä¸åŒ¹é…æ¬¡æ•°  : {total_mismatch} ({mismatch_pct:.2f}%)")

            # ==========================
            # æ­£å€¼è§¦å‘è‡ªå®¡ï¼ˆæ—¶é—´ç®¡ç†å±€ï½œé”æ­»ï½œåœ¨æœ€ç»ˆæ±‡æ€»æ‰“å°ä¹‹å‰ï¼‰
            # ==========================
            avg_profit = (total_profit / total_entry) if total_entry else 0.0
            trigger_total = bool(POSITIVE_AUDIT_TRIGGER_TOTAL and total_profit > 0)
            trigger_avg = bool(POSITIVE_AUDIT_TRIGGER_AVG and avg_profit > 0)

            # Stop/Zeroï¼ˆæœ¬æ¨¡æ¿å½“å‰æœªå¯ç”¨ï¼Œé”æ­»ä¸º 0ï¼Œä½†ä»å‚ä¸é—­ç¯ä¸è‡ªå®¡ï¼‰
            total_stop = 0
            total_zero = 0

            # æ’ç­‰å¼é—­ç¯ï¼ˆé”æ­»ï¼‰
            closure_diff = int(total_entry) - int(
                total_match + total_mismatch + total_exhaustion + total_stop + total_zero)

            final_metrics = {
                "total_profit": total_profit,
                "avg_profit": avg_profit,
                "entry": total_entry,
                "match": total_match,
                "mismatch": total_mismatch,
                "break": total_exhaustion,
                "stop": total_stop,
                "zero": total_zero,
                "bet_in_forbidden_seen": BET_IN_FORBIDDEN_SEEN,
                "ppbb_mismatch": PPBB_MISMATCH,
                "ppbb_first_evidence": PPBB_FIRST_EVIDENCE,
                "trigger_total": trigger_total,
                "trigger_avg": trigger_avg,
                "closure_diff": closure_diff,
            }

            if POSITIVE_AUDIT_ENABLE and (trigger_total or trigger_avg):
                SELF_AUDIT_GATE(final_metrics)

            # Node 6: è¿è¡ŒæœŸä¸€è‡´æ€§è‡ªæ£€
            _audit_consistency(final_metrics)

        _abn = []  # è‡ªè¯å¼‚å¸¸æ”¶é›†å™¨ï¼ˆä¿®å¤ NameErrorï¼‰

        def _abn0(name, val, expect=0):
            try:
                if val != expect:
                    _abn.append((name, val, expect))
            except Exception:
                _abn.append((name, 'ERR', expect))

        _abn0('STAR_ON_T', STAR_ON_T)
        _abn0('STAR_DIFF0_AND_R_IN_BP', STAR_DIFF0_AND_R_IN_BP)

        if ENABLE_MEAN_FEATURE:
            _abn0('MEAN_MISSING_RAW', MEAN_MISSING_RAW)
            _abn0('MEAN_PARSE_FAIL', MEAN_PARSE_FAIL)
            _abn0('MEAN_INVALID_BUG(ç›®æ ‡=0)', MEAN_INVALID_BUG)

        # RATE æ— æ•ˆï¼šé 0 ä¸ç®—å¼‚å¸¸ï¼›ä»…åœ¨ä¸€è‡´æ€§å¤±è´¥æ—¶å¼¹å‡ºï¼ˆæ–­è¨€å·²è¦†ç›–ï¼Œä½†ä»ç•™ä¸€è¡Œæç¤ºï¼‰
        if RATE_INVALID_RAW != RATE_INVALID_BUCKET:
            _abn.append(('RATE_INVALID_MISMATCH', f'{RATE_INVALID_RAW}!={RATE_INVALID_BUCKET}', 'equal'))

        if PPBB_MISMATCH != 0:
            _abn.append(('PPBB_MISMATCH', PPBB_MISMATCH, 0))

        if _abn:
            print('è‡ªè¯å¼‚å¸¸ï¼ˆä»…å¼‚å¸¸å¼¹å‡ºï¼‰:')
            for name, val, exp in _abn:
                print(f'  {name}: {val} (æœŸæœ›={exp})')
        if PPBB_FIRST_EVIDENCE is not None:
            print("  PPBB_FIRST_EVIDENCE:", PPBB_FIRST_EVIDENCE)

        if cont_agg is not None:
            print()
            print("------------------------------------------------------------")
            print("è¿æ®µç»Ÿè®¡ï¼ˆåŒæŒ‡æ ‡ç›¸é‚»æ€ï½œäº‹åæ±‡æ€»ï¼‰")
            print("è¯´æ˜ï¼šä»…åŸºäºæŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨ï¼ˆå«çŠ¶æ€ T é‡å¤æŠ•æ”¾ï¼‰ï¼›æ ·æœ¬é‡ä¸è¶³ä¸è¾“å‡ºã€‚")
            print("é˜ˆå€¼ï¼šmin_samples=%dï½œTopK=%d" % (CONT_MIN_SAMPLES, CONT_TOPK))

            _print_top_transitions(
                "A) (|ç‚¹å·®|,rate ç›‘æµ‹æ¡¶) Overall Top",
                cont_agg["pair_rate_overall"],
                CONT_MIN_SAMPLES,
                CONT_TOPK,
            )

            if ENABLE_MEAN_FEATURE:
                _print_top_transitions(
                    "B) (|ç‚¹å·®|,mean æ¡¶) Overall Top",
                    cont_agg["pair_mean_overall"],
                    CONT_MIN_SAMPLES,
                    CONT_TOPK,
                )

            max_bn = min(int(cont_agg.get("max_bet_n_seen", 0) or 0), CONT_MAX_BET_N)
            for bn in range(2, max_bn + 1):
                tmp_rate = {}
                tmp_mean = {}
                if not isinstance(tmp_rate, dict):
                    tmp_rate = {}
                if not isinstance(tmp_mean, dict):
                    tmp_mean = {}
                for (bn2, a, b), v in cont_agg["pair_rate"].items():
                    if bn2 == bn:
                        tmp_rate[(a, b)] = v

                if ENABLE_MEAN_FEATURE:
                    for (bn2, a, b), v in cont_agg["pair_mean"].items():
                        if bn2 == bn:
                            tmp_mean[(a, b)] = v

                _print_top_transitions(
                    f"A) bet_n={bn} (|ç‚¹å·®|,rate ç›‘æµ‹æ¡¶) Top",
                    tmp_rate,
                    CONT_MIN_SAMPLES,
                    min(10, CONT_TOPK),
                )

                if ENABLE_MEAN_FEATURE:
                    _print_top_transitions(
                        f"B) bet_n={bn} (|ç‚¹å·®|,mean æ¡¶) Top",
                        tmp_mean,
                        CONT_MIN_SAMPLES,
                        min(10, CONT_TOPK),
                    )

        # ç‰©ç†é”æ­»ï¼šå¿…é¡»æ‰“å°ä¸¤å¤„å¼€å…³ï¼Œå¦åˆ™ç›´æ¥ä½œåºŸ
        if not _PRINTED_SWITCHES_HEADER:
            raise RuntimeError("âŒ ç¼ºå¤±è¡¨å¤´å¼€å…³è‡ªè¯ï¼šBOOT_FILTER/STRUCT_SCAN æœªæ‰“å°")
        if not _PRINTED_SWITCHES_PROOF:
            raise RuntimeError("âŒ ç¼ºå¤±å¼ºåˆ¶è‡ªè¯å¼€å…³ï¼šBOOT_FILTER/STRUCT_SCAN æœªæ‰“å°")


# ğŸ€è¦†ç›–é”šç‚¹002_æŠ¥å‘Šæ±‡æ€»_END

def main():
    try:

        # é¦–å±æ°´å°ï¼ˆç¡¬é”æ­»ï¼‰
        print(WATERMARK_TEXT)
        print("BUILD_TAG: " + BUILD_TAG)
        global _WATERMARK_PRINTED
        _WATERMARK_PRINTED = True

        # ã€å¼ºåˆ¶è‡ªè¯è¾“å‡ºã€‘ï¼ˆç¡¬é”æ­»ï¼‰
        print("ã€å¼ºåˆ¶è‡ªè¯è¾“å‡ºã€‘")
        _print_switches_block("PROOF")

        # äº‹ä»¶4+ï½œL2/L3 PRE_L1 çœŸè‡ªè¯ï¼šå¿…é¡»åœ¨ L1_DONE=0 æ—¶è¯„ä¼°ä¸€æ¬¡ï¼ˆä¸é€šè¿‡åˆ™åç»­ä¸€å¾‹ä¸ç®—ï¼‰
        try:
            # ç¡¬ç½®ï¼šæ­¤åˆ»ç†è®ºä¸Š _L1_DECISION_DONE å°šæœªç½®1
            _stage_enabled("L2")
            _stage_enabled("L3")
        except Exception:
            pass

        # åŸºåº•èº«ä»½è¯ï¼ˆğŸ•çŸ­ç ï¼‰ï¼šå†»ç»“åŒºæŒ‡çº¹ï¼ˆCOREï¼‰å†³å®šï¼›æ’æ§½/è§„åˆ™å˜åŠ¨ä¸åº”å½±å“            _compute_core_and_slot_fingerprints()
        except Exception:
            pass
        core8 = ((CORE_BASE_FINGERPRINT or "NA")[:8]).upper()
        slot8 = ((STRUCTURE_SLOT_FINGERPRINT or "NA")[:8]).upper()
        pizza = "ğŸ•" + core8[:4]
        print(f"åŸºåº•èº«ä»½è¯ï¼š{pizza} | CORE8={core8} | SLOT8={slot8}")
        print(f"BET_IN_FORBIDDEN_SEEN = {BET_IN_FORBIDDEN_SEEN} (0.00%)")
        print(f"PPBB_IDENTITY_CHECKED = {PPBB_CHECKED} | PPBB_MISMATCH = {PPBB_MISMATCH}")
        global _PROOF_BLOCK_PRINTED
        _PROOF_BLOCK_PRINTED = True

        # ç¡¬æ³¨å…¥è‡ªæ£€ï¼ˆå¿…é¡» raise é˜»æ–­ï¼Œä¸å¾—åé”™ï¼‰
        if not SILENT_MODE:
            print("=== æ­£åœ¨æ‰§è¡Œç¡¬æ³¨å…¥è‡ªæ£€ ===")
        try:
            # ç”¨ä¾‹Aï¼šTè¡Œå†™å¿«ç…§ -> å¿…é¡»é˜»æ–­âœ…
            _ = write_star_snapshot("DECISION", {"r": "T", "seen_all": 9, "diff": 1, "rate": "None", "mean": "None",
                                                 "shoe_id": "SELFTEST"}, 0)
            raise RuntimeError("SELF_TEST_FAIL: T_SNAPSHOT_NOT_BLOCKED")
        except RuntimeError:
            pass

        try:
            # ç”¨ä¾‹Bï¼šéDECISIONè¯»æŒ‡æ ‡ -> å¿…é¡»é˜»æ–­âœ…
            tmp = Snapshot({"diff": 1, "rate": None, "mean": None, "rate_raw": "None", "mean_raw": "None"},
                           boot_id="SELFTEST", idx=0, seen_all=9, rr="B", source="STAR_ROW")
            _ = secure_read_metric(tmp, "diff", "EXECUTE", who="STAR", idx=0, boot_id="SELFTEST", seen_all=9)
            raise RuntimeError("SELF_TEST_FAIL: NON_DECISION_METRIC_NOT_BLOCKED")
        except RuntimeError:
            pass

        try:
            # ç”¨ä¾‹Cï¼šæ‰§è¡Œæ¨è¿›ä¸­è¯»å–æŒ‡æ ‡ï¼ˆé€šè¿‡ MetricGuardRowï¼‰-> å¿…é¡»é˜»æ–­âœ…
            g = MetricGuardRow({"r": "B", "diff": 1, "rate": 0.1, "mean": 1.0})
            _ = g.get("rate")
            raise RuntimeError("SELF_TEST_FAIL: EXECUTE_METRIC_NOT_BLOCKED")
        except RuntimeError:
            pass

        print("ç¡¬æ³¨å…¥éªŒè¯=é€šè¿‡âœ…")
        print("éæ³•æŒ‡æ ‡è®¿é—®æ¨¡æ‹Ÿ=å·²é˜»æ–­âœ…")
        print("Tè¡Œå†™å¿«ç…§=å·²é˜»æ–­âœ…")
        print("é˜»æ–­æ–¹å¼=raiseâœ…(æœªåé”™)")
        if not SILENT_MODE:
            print("=== è‡ªæ£€å®Œæˆ ===")
        global _SELFTEST_PASSED
        _SELFTEST_PASSED = True
        _audit_structure_slot_integrity()
        _audit_forbid_idx_offset()
        _print_source_hashes()
        csv_files = sorted([f for f in os.listdir(".") if f.lower().endswith(".csv")])
        if VERIFY_SPLIT_ENABLE and len(csv_files) >= 2:
            mid = len(csv_files) // 2
            _run_report(csv_files[:mid], "éªŒçœŸé˜¶æ®µï¼ˆå‰ 50%ï¼‰")
            _run_report(csv_files[mid:], "éªŒçœŸé˜¶æ®µï¼ˆå 50%ï¼‰")
        else:
            _run_report(csv_files, "ä¼˜åŒ–é˜¶æ®µï¼ˆå…¨é‡ï¼‰")

        # ğŸ“Œ æŠ½æ ·æ¢é’ˆè¾“å‡ºï¼ˆå†»ç»“åŒºï¼‰
        _earliest_tgt_emit()
        _sample_probe_emit()
    except GuardViolation as gv:
        _print_single_screen_error(gv)
        sys.exit(getattr(gv, 'exit_code', 2))
    except (AssertionError, ValueError, KeyError, TypeError) as e:
        gv = _as_guard_from_exception(e)
        _print_single_screen_error(gv)
        sys.exit(getattr(gv, 'exit_code', 2))
    except Exception as e:
        gv = _as_guard_from_exception(e)
        _print_single_screen_error(gv)
        sys.exit(getattr(gv, 'exit_code', 2))


# =========================
# è½»é‡è‡ªå®¡ï¼ˆä»…ç”¨äºâ€œå‡€å€¼è½¬æ­£â€æç¤ºï¼›ä¸æ›¿ä»£ AUDIT_RUN=1 ä¸¥æ ¼å®¡æŸ¥ï¼‰
# ç›®æ ‡ï¼šä¸ä¸­æ–­ä¼˜åŒ–æµç¨‹ï¼›ä»…æç¤ºå…³é”®é£é™©ï¼›ä¸¥ç¦é€’å½’è‡ªå®¡
# =========================
AUTO_SELF_AUDIT_ON_POSITIVE = True  # å‡€å€¼>0 æ—¶è§¦å‘ä¸€æ¬¡â€œè½»é‡è‡ªå®¡æç¤ºâ€
IN_SELF_AUDIT = False  # é˜²é‡å…¥


def _get_total_pnl_for_self_audit():
    """
    å…¼å®¹ä¸åŒæ¨¡æ¿å˜é‡åï¼šå°½é‡è¯»å–â€œæ€»å‡€å€¼/æ€»åˆ©æ¶¦â€ã€‚
    æ‰¾ä¸åˆ°åˆ™è¿”å› Noneï¼ˆä¸è§¦å‘è‡ªå®¡ï¼‰ã€‚
    """
    for k in ("TOTAL_PNL", "total_pnl", "TOTAL_PROFIT", "total_profit", "profit_total", "NET_TOTAL", "net_total"):
        if k in globals():
            v = globals().get(k)
            try:
                return float(v)
            except Exception:
                return None
    return None


def _self_audit_light():
    """
    è½»é‡è‡ªå®¡ï¼š
    - åªåšâ€œå¿…é¡»ç«‹å³ä¸­æ–­â€çš„è‡´å‘½é¡¹ + è‹¥å¹²æç¤ºé¡¹
    - é»˜è®¤ä¸å½±å“ä¸»æµç¨‹ï¼ˆé™¤éè‡´å‘½é¡¹è¢«è§¦å‘ï¼‰
    """
    # è‡´å‘½é¡¹ï¼šç¦ä¸‹æ³¨åŒºå‡ºç°çœŸå®è½æ³¨ï¼ˆå¿…é¡»ä¸­æ–­ï¼Œé¿å…ç»“æœä¸å¯ç”¨ï¼‰
    bet_forbidden = globals().get("BET_IN_FORBIDDEN_SEEN", 0)
    try:
        bet_forbidden = int(bet_forbidden)
    except Exception:
        bet_forbidden = 0

    if bet_forbidden > 0:
        raise RuntimeError(f"BET_IN_FORBIDDEN_SEEN>0ï¼ˆ={bet_forbidden}ï¼‰â€”â€”ç¦ä¸‹æ³¨åŒºå‘ç”ŸçœŸå®è½æ³¨ï¼Œç»“æœä½œåºŸ")

    # æç¤ºé¡¹ï¼šåªåšâ€œå­˜åœ¨æ€§â€æç¤ºï¼Œä¸åšä¸¥æ ¼å£å¾„åˆ¤æ­»
    hints = []
    if globals().get("STRUCT_SCAN", None) is not None and (globals().get("STRUCT_SCAN") is False):
        hints.append("STRUCT_SCAN=OFF")
    if globals().get("BOOT_FILTER", None) is not None and (globals().get("BOOT_FILTER") is False):
        hints.append("BOOT_FILTER=OFF")

    # æ’ç­‰å¼é—­ç¯æç¤ºï¼ˆè‹¥å­˜åœ¨è¿™äº›è®¡æ•°å™¨æ‰æ£€æŸ¥ï¼‰
    entry = globals().get("total_entry", None)
    match = globals().get("total_match", None)
    mismatch = globals().get("total_mismatch", None)
    exhaustion = globals().get("total_exhaustion", None)
    stop = globals().get("total_stop", None)
    zero = globals().get("total_zero", None)

    try:
        if entry is not None:
            entry_i = int(entry)
            parts = []
            for v in (match, mismatch, exhaustion, stop, zero):
                if v is not None:
                    parts.append(int(v))
            if parts:
                if entry_i != sum(parts):
                    hints.append("æ’ç­‰å¼ä¸é—­ç¯ï¼ˆEntryâ‰ åˆ†æ”¯æ€»å’Œï¼‰")
    except Exception:
        # è½»é‡è‡ªå®¡ä¸å› è§£æå¤±è´¥æ‰“æ–­
        pass

    # è¾“å‡ºï¼šä¸€è¡Œæç¤ºï¼Œä¸åˆ·å±
    if hints:
        print("ã€è½»é‡è‡ªå®¡ã€‘âš ï¸ æç¤ºï¼š", " / ".join(hints))
    else:
        print("ã€è½»é‡è‡ªå®¡ã€‘âœ… é€šè¿‡ï¼ˆè½»é‡ï¼‰")


def _auto_self_audit_after_run():
    """
    ä»…åœ¨â€œéä¸¥æ ¼å®¡æŸ¥è·‘â€ä¸”å‡€å€¼>0 æ—¶è§¦å‘ä¸€æ¬¡è½»é‡è‡ªå®¡æç¤ºã€‚
    """
    global IN_SELF_AUDIT
    if IN_SELF_AUDIT:
        return
    if globals().get("AUDIT_RUN", 0) == 1:
        return
    if not globals().get("AUTO_SELF_AUDIT_ON_POSITIVE", False):
        return

    pnl = _get_total_pnl_for_self_audit()
    if pnl is None:
        return
    if pnl <= 0:
        return

    IN_SELF_AUDIT = True
    try:
        _self_audit_light()
    finally:
        IN_SELF_AUDIT = False


if __name__ == "__main__":
    main()
    _auto_self_audit_after_run()
