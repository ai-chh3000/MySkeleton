# ã€ç‰ˆæœ¬æ°´å°ï¼ˆäº¤ä»˜éªŒæ”¶ç”¨ï½œé”æ­»ï¼‰ã€‘
# æ°´å°ï¼šğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°
# -*- coding: utf-8 -*-
# ============================================================
# å”¯ä¸€æ¯ç‰ˆï¼ˆç»Ÿä¸€ç‰ˆï¼‰
# è¯´æ˜ï¼šæœ¬æ–‡ä»¶ä¸ºé€šç”¨å”¯ä¸€æ¯ç‰ˆï¼ˆå››ä»¶å¥—å·²å†…ç½®ï¼‰ï¼›ä»…ç»´æŠ¤è¿™ä¸€ä»½ã€‚
# è§„åˆ™ï¼šåŸºåº§åŒºå†»ç»“ï¼›è§„åˆ™åŒºå¯æ”¹å†™ï¼›å®¡æŸ¥è·‘ç”¨ AUDIT_RUN=1ï¼›å‡€å€¼è½¬æ­£ä»…è§¦å‘è½»é‡è‡ªå®¡æç¤ºã€‚
# ============================================================

import csv
import os
import inspect
import hashlib
import re
import sys
import traceback
from dataclasses import dataclass, replace
from typing import Any, Optional


# ==========================
# å®‰å…¨ç¡¬é—¸é—¨ï¼ˆæ¨¡æ¿åŠ å›ºï½œé”æ­»ï¼‰
# ==========================
WATERMARK_TEXT = "ğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°"

# ------------------------------------------------------------
# ğŸ“Œ æŠ½æ ·æ¢é’ˆï¼ˆå†»ç»“åŒºï½œåªç”¨äºæ‰“å°å®šä½ï½œå®Œå…¨ä¸å½±å“ç­–ç•¥é€»è¾‘ï¼‰
# è¾“å‡ºæ ¼å¼ï¼ˆæ¯æ¡ä¸€è¡Œï¼‰ï¼šğŸ“Œ|f=<æ–‡ä»¶å>|SB=<Sub-Batch>|N=<ğŸ¯=N_prebet=äººç±»å®é™…å–å€¼/ä¸‹æ³¨ç‚¹=å–å€¼ç‚¹=seen_all>
# ------------------------------------------------------------
SAMPLE_PROBE_ENABLE = 1   # 1=ON, 0=OFF
SAMPLE_PROBE_K = 3        # æŠ½æ ·æ¡æ•°
SAMPLE_PROBE_PREFIX = "ğŸ“Œ"
SAMPLE_PROBE_RUN_NONCE = int.from_bytes(os.urandom(8), "big")  # æ¯æ¬¡è¿è¡Œä¸åŒï¼›ä»…ç”¨äºæŠ½æ ·æ’åº
_SAMPLE_PROBE_BEST_BY_FILE = {}  # file -> (score, file, sub_batch, idx)
_SAMPLE_PROBE_FALLBACK = None  # (base, sub_batch, idx)

def _sample_probe_u64(s: str) -> int:
    # ç¨³å®šå“ˆå¸Œï¼šè·¨è¿›ç¨‹/è·¨å¹³å°å¯å¤ç°ï¼›ä»…ç”¨äºæŠ½æ ·æ’åºï¼ˆä¸å‚ä¸ä»»ä½•é€»è¾‘ï¼‰
    h = hashlib.md5(s.encode('utf-8'), usedforsecurity=False).hexdigest()
    return int(h[:16], 16)

def _sample_probe_fallback_update(file_name, sub_batch, idx) -> None:
    """æŠ½æ ·å…œåº•ï¼šå³ä½¿æ— â­/æ— ENTRYï¼Œä¹Ÿä¿è¯è‡³å°‘æœ‰ä¸€æ¡ğŸ“Œå¯å®šä½ã€‚"""
    global _SAMPLE_PROBE_FALLBACK
    if not SAMPLE_PROBE_ENABLE:
        return
    if not file_name:
        return
    try:
        base = os.path.basename(str(file_name))
        _SAMPLE_PROBE_FALLBACK = (base, sub_batch, idx)
    except Exception:
        return


def _sample_probe_update(file_name, sub_batch, idx, boot_id=None) -> None:
    """å†»ç»“åŒºæŠ½æ ·å€™é€‰æ›´æ–°ï¼šæ¯æ–‡ä»¶åªä¿ç•™ 1 æ¡ï¼ˆæœ€å°å“ˆå¸Œè€…ï¼‰ã€‚"""
    if not SAMPLE_PROBE_ENABLE:
        return
    if not file_name:
        return
    try:
        base = os.path.basename(str(file_name))
    except Exception:
        base = str(file_name)
    if not base:
        return
    # å…è®¸ sub_batch/idx ä¸ºå­—ç¬¦ä¸²ï¼›æ‰“å°æ—¶åŸæ ·è¾“å‡ºï¼›æ’åºæ—¶ä»çº³å…¥å“ˆå¸Œ
    key = base
    score = _sample_probe_u64(f"{SAMPLE_PROBE_RUN_NONCE}|{BUILD_TAG}|{base}|{sub_batch}|{idx}|{boot_id}")
    cur = _SAMPLE_PROBE_BEST_BY_FILE.get(key)
    if (cur is None) or (score < cur[0]):
        _SAMPLE_PROBE_BEST_BY_FILE[key] = (score, base, sub_batch, idx)

def _sample_probe_emit() -> None:
    """æ‰¹å¤„ç†ç»“æŸåæ‰“å°æŠ½æ ·ç»“æœï¼ˆæœ€å¤š K æ¡ï¼Œå°½é‡åˆ†å¸ƒåœ¨ä¸åŒæ–‡ä»¶ï¼‰ã€‚"""
    if not SAMPLE_PROBE_ENABLE:
        return
    if not _SAMPLE_PROBE_BEST_BY_FILE:
        # æ— å¯æŠ½æ ·å€™é€‰ï¼šä»ç»™ 1 è¡Œæç¤ºï¼ˆæç®€ï¼‰
        print(f"{SAMPLE_PROBE_PREFIX}|NONE")
        return
    items = sorted(_SAMPLE_PROBE_BEST_BY_FILE.values(), key=lambda x: x[0])[:int(SAMPLE_PROBE_K or 0)]
    for _, base, sb, n in items:
        print(f"{SAMPLE_PROBE_PREFIX}|f={base}|SB={sb}|N={n}ğŸ†—" if _SELFTEST_PASSED else f"{SAMPLE_PROBE_PREFIX}|f={base}|SB={sb}|N={n}")

BUILD_TAG = "V30_UPGRADED_fix_bootid_v32_buildtag_fix|TAG20260105-01|BOOT_START_LOCK_SW|DUAL_SEEN|B1_RESET_STEP1|RUNLEN_LOCK_S|R_TRUTH|TEMP_INIT_FIRST|HYST3|DIFF_SIGN_ONLY"
# æŒ‡æ ‡é”®ï¼ˆé”æ­»ï¼‰
METRIC_KEYS = {"diff", "rate", "mean", "rate_raw", "mean_raw"}

# ==========================
# ç»Ÿä¸€è¿è§„å‡ºå£ï¼ˆè¡¥ä¸Aï½œé”æ­»ï¼‰
# ==========================
class GuardViolation(RuntimeError):
    """é—¨ç¦/å®¡è®¡è¿è§„ï¼šç»Ÿä¸€å‡ºå£ï¼Œç¦æ­¢ tracebackã€‚"""
    def __init__(self, *, code, rule_id, phase, msg, evidence, exit_code=2):
        super().__init__(msg)
        self.code = str(code)
        self.rule_id = int(rule_id) if rule_id is not None else 0
        self.phase = str(phase)
        self.msg = str(msg)
        self.evidence = str(evidence)
        self.exit_code = int(exit_code)

def _raise_guard(*, code, rule_id, phase, msg, evidence, exit_code=2):
    raise GuardViolation(code=code, rule_id=rule_id, phase=phase, msg=msg, evidence=evidence, exit_code=exit_code)

def _as_guard_from_exception(e):
    """æŠŠæœªçŸ¥å¼‚å¸¸æ˜ å°„ä¸ºå¯å®¡è®¡å•å±é”™è¯¯ï¼ˆä¸æ”¾æ¾å®¡è®¡å¼ºåº¦ï¼‰ã€‚"""
    etxt = f"{type(e).__name__}: {e}"
    loc = "UNKNOWN"
    try:
        tb = traceback.extract_tb(e.__traceback__)
        if tb:
            last = tb[-1]
            loc = f"{last.name}@L{last.lineno}"
    except Exception:
        loc = "UNKNOWN"
    return GuardViolation(
        code="UNHANDLED",
        rule_id=0,
        phase="UNKNOWN",
        msg="UNHANDLED",
        evidence=f"{etxt} | loc={loc}",
        exit_code=2,
    )


def _print_watermark_once():
    global _WATERMARK_PRINTED
    if globals().get("_WATERMARK_PRINTED", False):
        return
    print(WATERMARK_TEXT)
    _WATERMARK_PRINTED = True


def _compute_core_and_slot_fingerprints() -> None:
    """
    è®¡ç®—ä¸¤ç±»æŒ‡çº¹ï¼š
    - CORE8ï¼šé™¤ã€Œç»“æ„æ’æ§½å—ã€ä»¥å¤–çš„åŸºåº§æ ¸å¿ƒæŒ‡çº¹ï¼ˆç”¨äºé˜²å·æ¢ï¼‰
    - SLOT8ï¼šä»…ã€Œç»“æ„æ’æ§½å—ã€çš„æŒ‡çº¹ï¼ˆç”¨äºè¯†åˆ«ç»“æ„å˜åŒ–ï¼‰

    ç»“æ„æ’æ§½è¾¹ç•Œä»¥ã€Œè¦†ç›–é”šç‚¹001ã€ä¸ºå‡†ï¼ˆé¿å…è¯´æ˜æ–‡å­—/æ³¨é‡Šè¯¯ä¼¤ï¼‰ï¼š
      - # ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_BEG
      - # ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_EN
    """
    global CORE_BASE_FINGERPRINT, STRUCTURE_SLOT_FINGERPRINT, STRUCTURE_SLOT_LINE_RANGE

    try:
        with open(__file__, "r", encoding="utf-8") as f:
            src = f.read()
        lines = src.splitlines()
    except Exception:
        CORE_BASE_FINGERPRINT = None
        STRUCTURE_SLOT_FINGERPRINT = None
        STRUCTURE_SLOT_LINE_RANGE = None
        return

    ANCHOR001_BEGIN = "ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_" "BEGIN"
    ANCHOR001_END   = "ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_" "END"
    begin_pat = r"^[ \t]*#\s*" + re.escape(ANCHOR001_BEGIN) + r".*$"
    end_pat   = r"^[ \t]*#\s*" + re.escape(ANCHOR001_END)   + r".*$"

    begin_ms = list(re.finditer(begin_pat, src, flags=re.MULTILINE))
    end_ms = list(re.finditer(end_pat, src, flags=re.MULTILINE))

    if len(begin_ms) != 1 or len(end_ms) != 1:
        raise RuntimeError(f"ç»“æ„æ’æ§½é”šç‚¹æ•°é‡å¼‚å¸¸ï¼šBEGIN={len(begin_ms)} END={len(end_ms)}")

    b = begin_ms[0]
    e = end_ms[0]

    b_start = b.start()
    b_end = b.end()
    e_start = e.start()
    e_end = e.end()

    if e_start <= b_start:
        raise RuntimeError("ç»“æ„æ’æ§½é”šç‚¹é¡ºåºå¼‚å¸¸ï¼šEND åœ¨ BEGIN ä¹‹å‰")

    # è®¡ç®—è¡Œå·èŒƒå›´ï¼ˆå«è¾¹ç•Œè¡Œï¼‰
    begin_line = src[:b_start].count("\n") + 1
    end_line = src[:e_start].count("\n") + 1
    STRUCTURE_SLOT_LINE_RANGE = (begin_line, end_line)

    # æ’æ§½æ–‡æœ¬ï¼ˆä¸å«è¾¹ç•Œè¡Œæœ¬èº«ï¼‰
    src_lines = src.splitlines()
    slot_body_lines = src_lines[begin_line: end_line-1]
    slot_text = "\n".join(slot_body_lines).strip("\n")

    STRUCTURE_SLOT_FINGERPRINT = hashlib.sha256(slot_text.encode("utf-8")).hexdigest()

    # CORE æŒ‡çº¹ï¼šå»æ‰æ•´æ®µã€ŒBEGINè¡Œ .. ENDè¡Œã€(å«è¾¹ç•Œè¡Œ)
    # - è¿™æ ·ç­–ç•¥/ç»“æ„çš„å¯å˜èŒƒå›´åªå½±å“ SLOT8ï¼Œä¸å½±å“ CORE8
    # - ä¹Ÿé¿å…è¯´æ˜æ–‡å­—ä¸­å‡ºç°ç±»ä¼¼å­—ç¬¦å¯¼è‡´è¯¯ä¼¤
    # æ‰¾åˆ° END è¡Œå°¾ï¼ˆå«æ¢è¡Œï¼‰
    e_end2 = e_end
    if e_end2 < len(src) and src[e_end2:e_end2+1] == "\n":
        e_end2 += 1

    core_text = src[:b_start] + src[e_end2:]
    CORE_BASE_FINGERPRINT = hashlib.sha256(core_text.encode("utf-8")).hexdigest()

def _print_force_proof_block():
    global _PROOF_BLOCK_PRINTED
    if globals().get("_PROOF_BLOCK_PRINTED", False):
        return
    print("ã€å¼ºåˆ¶è‡ªè¯è¾“å‡ºã€‘")
    _print_switches_block("PROOF")
    # åŸºåº•èº«ä»½è¯ï¼ˆğŸ•çŸ­ç ï¼‰ï¼šç”±å†»ç»“åŒºæŒ‡çº¹è‡ªåŠ¨ç”Ÿæˆï¼›åªæ”¹æ’æ§½/è§„åˆ™ä¸åº”å˜åŒ–
    try:
        _compute_core_and_slot_fingerprints()
    except Exception:
        pass
    core8 = ((CORE_BASE_FINGERPRINT or 'NA')[:8]).upper()
    slot8 = ((STRUCTURE_SLOT_FINGERPRINT or 'NA')[:8]).upper()
    pizza = 'ğŸ•' + core8[:4]
    print(f"åŸºåº•èº«ä»½è¯ï¼š{pizza} | CORE8={core8} | SLOT8={slot8}")
    if STRUCTURE_SLOT_LINE_RANGE and STRUCTURE_SLOT_LINE_RANGE[0] is not None:
        print(f"ç»“æ„æ’æ§½ï¼šç‰ˆæœ¬={STRUCTURE_SLOT_VERSION} | è¡Œå·èŒƒå›´={STRUCTURE_SLOT_LINE_RANGE[0]}..{STRUCTURE_SLOT_LINE_RANGE[1]}")
    try:
        denom = int(globals().get("_LAST_ENTRY_FOR_PROOF", 0) or 0)
        pct = (BET_IN_FORBIDDEN_SEEN / denom * 100.0) if denom > 0 else 0.0
    except Exception:
        pct = 0.0
    print(f"BET_IN_FORBIDDEN_SEEN = {BET_IN_FORBIDDEN_SEEN} ({pct:.2f}%)")
    print(f"PPBB_IDENTITY_CHECKED = {PPBB_CHECKED} | PPBB_MISMATCH = {PPBB_MISMATCH}")
    # è§£æè®¡æ•°ï¼ˆè¡¥ä¸Bï¼‰
    try:
        print(f"RATE_PARSE_FAIL_INPUT = {RATE_PARSE_FAIL_INPUT} | RATE_MISSING_RAW_INPUT = {RATE_MISSING_RAW_INPUT}")
        print(f"MEAN_PARSE_FAIL_INPUT = {MEAN_PARSE_FAIL_INPUT} | MEAN_MISSING_RAW_INPUT = {MEAN_MISSING_RAW_INPUT}")
    except Exception:
        pass
    # æ’æ§½è‡ªè¯ï¼ˆåŸºåº§/æ’æ§½åˆ†ç¦»ï¼‰
    try:
        _compute_core_and_slot_fingerprints()
        if CORE_BASE_FINGERPRINT is not None and STRUCTURE_SLOT_FINGERPRINT is not None:
            (bl, el) = STRUCTURE_SLOT_LINE_RANGE or (None, None)
            print(f"STRUCTURE_SLOT = {STRUCTURE_SLOT_NAME}@{STRUCTURE_SLOT_VERSION} | L{bl}..L{el}")
            print(f"CORE_BASE_FINGERPRINT = {CORE_BASE_FINGERPRINT[:16]}")
            print(f"STRUCTURE_SLOT_FINGERPRINT = {STRUCTURE_SLOT_FINGERPRINT[:16]}")
    except Exception as e:
        print(f"STRUCTURE_SLOT_PROOF_FAIL = {type(e).__name__}: {e}")
    if denom > 0:
        _PROOF_BLOCK_PRINTED = True

def _print_single_screen_error(gv: 'GuardViolation'):
    # ä»»ä½•å¼‚å¸¸ä¹Ÿè¦æ»¡è¶³ï¼šæ°´å° + å¼ºåˆ¶è‡ªè¯å—ï¼ˆè‹¥å·²æ‰“å°åˆ™ä¼šè‡ªåŠ¨å»é‡ï¼‰
    try:
        _print_watermark_once()
    except Exception:
        pass
    try:
        _print_force_proof_block()
    except Exception:
        pass
    try:
        _flush_audit_log("FAIL")
    except Exception:
        pass
    print(f"âŒâŒâŒ è§¦å‘æ¡ç›®={gv.rule_id} | code={gv.code} | phase={gv.phase} | evidence={gv.evidence}")


class MetricGuardRow(dict):
    """EXECUTE/SETTLE é˜¶æ®µï¼šrow å·²å»æŒ‡æ ‡åŒ–ï¼›ä»»ä½•è¯»å–æŒ‡æ ‡é”®ä¸€å¾‹ raiseã€‚"""
    def get(self, k, default=None):
        if k in METRIC_KEYS:
            raise RuntimeError(f"ILLEGAL_METRIC_ACCESS_IN_EXECUTE: {k}")
        return super().get(k, default)

    def __getitem__(self, k):
        if k in METRIC_KEYS:
            raise RuntimeError(f"ILLEGAL_METRIC_ACCESS_IN_EXECUTE: {k}")
        return super().__getitem__(k)

class Snapshot:
    """STAR_ROW æœ€å°ä¸å¯å˜å¿«ç…§ï¼šç¦æ­¢ç›´è¯»æŒ‡æ ‡ï¼ˆå¿…é¡»èµ° secure_read_metricï¼‰ã€‚
    é¢å¤–å…ƒä¿¡æ¯ï¼ˆå†»ç»“åŒºé”æ­»ï¼‰ï¼šexh_pair / rate_mode / rate_bucket_l1 / rate_bucket_r / rate_bucket
    - è¿™äº›å­—æ®µåªå…è®¸åœ¨å†™å¿«ç…§æ—¶ä¸€æ¬¡æ€§ç»‘å®šï¼ŒæŠ•æ”¾ç‚¹ååªè¯»ä¸é‡ç®—ã€‚
    """
    __slots__ = (
        "_metrics", "_boot_id", "_idx", "_seen_all", "_rr", "_source",
        "_exh_pair", "_rate_mode", "_rate_bucket_l1", "_rate_bucket_r", "_rate_bucket", "_rate_raw_text", "_mean_raw_text"
    )

    def __init__(self, metrics: dict, *, boot_id, idx, seen_all, rr, source="STAR_ROW"):
        self._metrics = dict(metrics)
        self._boot_id = boot_id
        self._idx = int(idx)
        self._seen_all = int(seen_all)
        self._rr = rr
        self._source = source

        # å†»ç»“åŒºå…ƒä¿¡æ¯ï¼šé»˜è®¤æœªç»‘å®šï¼ˆå¿…é¡»ç”± secure_write_star_snapshot ç»‘å®šï¼‰
        self._exh_pair = None
        self._rate_mode = None
        self._rate_bucket_l1 = None
        self._rate_bucket_r = None
        self._rate_bucket = None
        self._rate_raw_text = ""
        self._mean_raw_text = ""

    # ---- å…ƒä¿¡æ¯ï¼ˆå…è®¸ç›´è¯»ï¼‰----
    @property
    def boot_id(self): return self._boot_id

    @property
    def idx(self): return self._idx

    @property
    def seen_all(self): return self._seen_all

    @property
    def rr(self): return self._rr

    @property
    def source(self): return self._source

    # ---- å†»ç»“åŒºï¼šå˜åŒ–ç‡å”¯ä¸€å…¥å£ç»‘å®šç»“æœï¼ˆå…è®¸ç›´è¯»ï¼‰----
    @property
    def exh_pair(self): return self._exh_pair

    @property
    def rate_mode(self): return self._rate_mode

    @property
    def rate_bucket_l1(self): return self._rate_bucket_l1

    @property
    def rate_bucket_r(self): return self._rate_bucket_r

    @property
    def rate_bucket(self): return self._rate_bucket

    def _bind_rate_fields(self, *, exh_pair, rate_mode, rate_bucket_l1, rate_bucket_r, rate_bucket):
        """åªå…è®¸ç»‘å®šä¸€æ¬¡ï¼›åç»­ä»»ä½•å†æ¬¡ç»‘å®šéƒ½è§†ä¸ºæ±¡æŸ“ã€‚"""
        if self._rate_bucket is not None:
            raise RuntimeError("RATE_FIELDS_ALREADY_BOUND")
        self._exh_pair = exh_pair
        self._rate_mode = rate_mode
        self._rate_bucket_l1 = rate_bucket_l1
        self._rate_bucket_r = rate_bucket_r
        self._rate_bucket = rate_bucket

    # ---- ç¦æ­¢ dict é£æ ¼ä¸å±æ€§ç›´è¯»æŒ‡æ ‡ ----
    def get(self, *args, **kwargs):
        raise RuntimeError("SNAPSHOT_DIRECT_GET_FORBIDDEN: use secure_read_metric")

    def __getitem__(self, k):
        raise RuntimeError("SNAPSHOT_DIRECT_ITEM_FORBIDDEN: use secure_read_metric")

    def __getattribute__(self, name):
        if name in METRIC_KEYS:
            raise RuntimeError(f"SNAPSHOT_DIRECT_ATTR_FORBIDDEN: {name}")
        return object.__getattribute__(self, name)
def phase_transition(phase, to_phase):
    order = {"SCAN": 0, "DECISION": 1, "EXECUTE": 2, "SETTLE": 3, "DONE": 4, "REPORT": 9}
    if phase not in order or to_phase not in order:
        raise RuntimeError("PHASE_INVALID")
    if order[to_phase] < order[phase]:
        raise RuntimeError(f"PHASE_BACKJUMP: {phase}->{to_phase}")
    return to_phase


def advance_one_row(cursor, records, *, phase, boot_id):
    """æ¨è¿›å”¯ä¸€å…¥å£ï¼ˆé”æ­»ï¼‰ã€‚

    ç›®çš„ï¼šå¯¹å¤–åªæš´éœ²â€œé€è¡Œæ¨è¿›â€ï¼Œç¦æ­¢ä»»ä½• idx+åç§»/éšæœºè·³è½¬è¯»å–æœªæ¥è¡Œã€‚
    - cursor: å½“å‰æ¸¸æ ‡ï¼ˆintï¼‰ï¼ŒæŒ‡å‘å½“å‰è¡Œ
    - records: å½“å‰æ‰¹æ¬¡çš„è¡Œåˆ—è¡¨
    è¿”å›ï¼šnew_cursorï¼ˆintï¼‰ï¼›è‹¥è¶Šç•Œè¿”å› None

    è¯´æ˜ï¼šå‡½æ•°å†…éƒ¨ä½¿ç”¨ +1 å±äºâ€œå°è£…å†…å®ç°â€ï¼Œå¯¹å¤–ä¸æš´éœ²åç§»é‡èƒ½åŠ›ã€‚
    """
    if cursor is None:
        return None
    try:
        c = int(cursor)
    except Exception:
        raise RuntimeError(f"ADVANCE_CURSOR_INVALID: boot_id={boot_id} cursor={cursor}")
    nxt = c + 1
    if nxt < 0 or nxt >= len(records):
        return None
    return nxt
def secure_read_metric(snap, key, phase, *, who, idx, boot_id, seen_all):
    """è¯»æŒ‡æ ‡å”¯ä¸€å…¥å£ï¼ˆé”æ­»ï¼‰ã€‚

    å¥‘çº¦ï¼šsecure_read_metric(snap, key, phase, *, who, idx, boot_id, seen_all)
      - key âˆˆ {diff, rate, mean, rate_raw, mean_raw}
      - å…è®¸ï¼š
          (A) phase==DECISION ä¸” who==STAR ä¸” seen_all>=9 ä¸” snap.source==STAR_ROW
          (B) phase==REPORT ä¸” who==REPORT ä¸” snap.source==STAR_ROWï¼ˆä»…ç”¨äºæ±‡æ€»è¾“å‡ºï¼Œä¸å‚ä¸å†³ç­–ï¼‰
      - å…¶ä»–ï¼šraise
    """
    if key not in METRIC_KEYS:
        raise RuntimeError("METRIC_NAME_INVALID")

    # ä»…å…è®¸ STAR_ROW å¿«ç…§
    try:
        if getattr(snap, "source", None) != "STAR_ROW":
            raise RuntimeError("SNAPSHOT_SOURCE_INVALID")
    except Exception:
        raise RuntimeError("SNAPSHOT_SOURCE_INVALID")

    ok_decision = (phase == "DECISION" and who == "STAR")
    ok_report = (phase == "REPORT" and who == "REPORT")
    if not (ok_decision or ok_report):
        raise RuntimeError(f"ILLEGAL_METRIC_ACCESS: phase={phase} who={who} metric={key}")

    # seen_all é—¨ç¦ï¼šBOOT_FILTER=ON æ—¶è¦æ±‚ >=9ï¼›BOOT_FILTER=OFF æ—¶æ”¾å¼€ï¼ˆ>=1ï¼‰
    min_seen = 9 if BOOT_FILTER else 1
    try:
        sa = int(seen_all)
    except Exception:
        raise RuntimeError("SNAPSHOT_SEEN_PARSE_FAIL")
    if sa < min_seen:
        # ä¿æŒæ—§é”™è¯¯ç è¯­ä¹‰ï¼šä»…åœ¨ min_seen==9 æ—¶è§¦å‘
        raise RuntimeError("SNAPSHOT_SEEN_LT9")

    # ä¸€è‡´æ€§ï¼ˆå°½é‡åšï¼Œä¸å¯è§£æåˆ™ä¸é˜»æ–­ï¼‰
    try:
        if int(getattr(snap, "idx")) != int(idx):
            raise RuntimeError("SNAPSHOT_IDX_MISMATCH")
    except Exception:
        pass
    try:
        if int(getattr(snap, "seen_all")) != int(seen_all):
            raise RuntimeError("SNAPSHOT_SEEN_MISMATCH")
    except Exception:
        pass
    try:
        if str(getattr(snap, "boot_id")) != str(boot_id):
            raise RuntimeError("SNAPSHOT_BOOT_MISMATCH")
    except Exception:
        pass

    # å–å€¼ï¼ˆç”¨ object.__getattribute__ ç»•è¿‡ __getattribute__ é™åˆ¶ï¼‰
    metrics = object.__getattribute__(snap, "_metrics")
    return metrics.get(key)

def secure_write_star_snapshot(row, phase, *, seen_all, rr, boot_id, star_idx, star_snapshot_is_none, exh_pair=None):
    """å†™å¿«ç…§å”¯ä¸€å…¥å£ï¼ˆé”æ­»ï¼‰ã€‚
    å˜åŒ–ç‡å”¯ä¸€å…¥å£ï¼š
      - exh_pair = æŠ•æ”¾ç‚¹ä¸Šä¸€æ¡ç»“æœ + æŠ•æ”¾ç‚¹è¿™ä¸€æ¡ç»“æœï¼ˆå«Tåˆ™æ— æ•ˆï¼‰
      - åœ¨æ­¤å¤„ä¸€æ¬¡æ€§ç»‘å®šï¼šrate_mode / rate_bucket_l1 / rate_bucket_r / rate_bucket(active)
      - æŠ•æ”¾ç‚¹ååªè¯»è¿™äº›æ¡¶åï¼Œç¦æ­¢ä¸‹æ¸¸é‡ç®—
    """
    if phase != "DECISION":
        raise RuntimeError("STAR_SNAPSHOT_PHASE_NOT_DECISION")
    if not star_snapshot_is_none:
        raise RuntimeError("STAR_SNAPSHOT_DUPLICATE")
    if rr == "T":
        raise RuntimeError("STAR_SNAPSHOT_ON_T")

    # seen_all é—¨ç¦ï¼šBOOT_FILTER=ON æ—¶è¦æ±‚ >=9ï¼›BOOT_FILTER=OFF æ—¶æ”¾å¼€ï¼ˆ>=1ï¼‰
    min_seen = 9 if BOOT_FILTER else 1
    try:
        sa = int(seen_all)
    except Exception:
        raise RuntimeError("STAR_SNAPSHOT_SEEN_PARSE_FAIL")
    if sa < min_seen:
        # ä¿æŒæ—§é”™è¯¯ç è¯­ä¹‰ï¼šä»…åœ¨ min_seen==9 æ—¶è§¦å‘
        raise RuntimeError("STAR_SNAPSHOT_SEEN_LT9")

    # åªåœ¨ DECISION/STAR è¯»æŒ‡æ ‡
    tmp_snap = Snapshot(
        {"diff": row.get("diff"), "rate": row.get("rate"), "mean": row.get("mean"),
         "rate_raw": row.get("rate_raw"), "mean_raw": row.get("mean_raw")},
        boot_id=boot_id, idx=star_idx, seen_all=seen_all, rr=rr, source="STAR_ROW"
    )

    # diff=0 ç›´æ¥é˜»æ–­ï¼ˆé”æ­»ï¼‰
    d = secure_read_metric(tmp_snap, "diff", phase, who="STAR", idx=star_idx, boot_id=boot_id, seen_all=seen_all)
    try:
        if int(float(d)) == 0:
            raise RuntimeError("STAR_SNAPSHOT_DIFF_ZERO")
    except Exception:
        raise RuntimeError("STAR_SNAPSHOT_DIFF_PARSE_FAIL")

    # å˜åŒ–ç‡ï¼šå”¯ä¸€å…¥å£ä¸€æ¬¡æ€§ç»‘å®šï¼ˆ0å€¼å¼ºåŒ–åœ¨ _rate_quartet å†…å®Œæˆï¼‰
    r = secure_read_metric(tmp_snap, "rate", phase, who="STAR", idx=star_idx, boot_id=boot_id, seen_all=seen_all)
    mode, l1b, rb, active = _rate_quartet(exh_pair, r)
    tmp_snap._bind_rate_fields(
        exh_pair=exh_pair, rate_mode=mode,
        rate_bucket_l1=l1b, rate_bucket_r=rb, rate_bucket=active
    )

    return tmp_snap

def write_star_snapshot(phase, star_row, star_idx):
    """å…¼å®¹å…¥å£ï¼šå†…éƒ¨è½¬å‘åˆ° secure_write_star_snapshotï¼ˆç¦æ­¢å…¶ä»–å†™æ³•ï¼‰ã€‚"""
    rr = star_row.get("r")
    seen_all = star_row.get("seen_all")
    boot_id = star_row.get("boot_id", star_row.get("shoe_id"))
    return secure_write_star_snapshot(
        star_row, phase,
        seen_all=seen_all, rr=rr, boot_id=boot_id, star_idx=star_idx,
        star_snapshot_is_none=True
    )

def _to_row_lite(row):
    """å»æŒ‡æ ‡åŒ–ï¼šè¿›å…¥ EXECUTE/SETTLE çš„ row åªä¿ç•™å¿…è¦å­—æ®µã€‚"""
    keep = {
        "r": row.get("r"),
        "shoe_id": row.get("shoe_id"),
        "boot_id": row.get("boot_id", row.get("shoe_id")),
        "idx": row.get("idx"),
        "seen_all": row.get("seen_all"),
        "file": row.get("file"),
        "sub_batch": row.get("sub_batch"),
    }
    return MetricGuardRow(keep)

def guard_future_rows(records, start_j):
    """ä» start_j å¼€å§‹æŠŠåç»­è¡Œæ›¿æ¢ä¸º RowLite(MetricGuardRow)ï¼Œä»æ ¹æºå»æŒ‡æ ‡ã€‚"""
    for k in range(start_j, len(records)):
        r = records[k]
        if isinstance(r, MetricGuardRow):
            continue
        records[k] = _to_row_lite(r)

# ==========================
# å…¨å±€å¼€å…³ï¼ˆå¿…é¡»æ˜¾å¼å®šä¹‰ï½œé¿å… NameErrorï¼‰
# ==========================
# ç›‘æµ‹å¼€å…³ï¼š0=å…³ï¼Œ1=å¼€ï¼ˆé»˜è®¤å…³ï¼›ä»…å½±å“â€œç›‘æµ‹/é›·è¾¾â€è¾“å‡ºï¼Œä¸å¾—å½±å“é›¶æœªæ¥ä¸ä¸‹æ³¨è·¯å¾„ï¼‰
MONITOR_ENABLE = 0

# éªŒè¯åˆ†æ‹†å¼€å…³ï¼š0=å…³ï¼Œ1=å¼€ï¼ˆé»˜è®¤å…³ï¼›è‹¥å¼€å¯ï¼Œå¿…é¡»ä»æ»¡è¶³é›¶æœªæ¥ä¸ä¸€æ¬¡æ€§æ‰«æçº¦æŸï¼‰
VERIFY_SPLIT_ENABLE = 0




# è¡¨å¤´è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡
_HEADER_MAPPING_PRINTED = False

# PP/BB æ’ç­‰å¼è‡ªè¯è®¡æ•°ï¼ˆé”æ­»ï¼‰
ENFORCE_PPBB_SEMANTICS = 1  # 1=å¼ºåˆ¶æŠ½æ£€ç‚¹å·®æ’ç­‰å¼ä¸ç»“æœæ˜ å°„ï¼ˆPP=é—²ç‚¹/BB=åº„ç‚¹ï¼‰
# ============================================================
# åŸºåº•æŒ‡çº¹ç»‘å®šï¼ˆé”æ­»ï½œç”¨äºâ€œå†»ç»“åŒº/è§„åˆ™åŒºç¡¬éš”ç¦»â€ï¼‰
# - BASELINE_HASH_POLICY:
#   - OFF: ä¸æ ¡éªŒï¼ˆæœ€å®½æ¾ï¼Œé€‚åˆå…ˆè·‘é€š/å¿«é€Ÿè¯•ç­–ç•¥ï¼‰
#   - WARN: æ‰“å°ä¸€è¡ŒWARNä¸ä¸­æ–­ï¼ˆå¼€å‘æœŸé»˜è®¤ï¼‰
#   - ENFORCE: ä¸åŒ¹é…ç›´æ¥æŠ¥é”™ï¼ˆå‘å¸ƒæœŸå†»ç»“ï¼‰
BASELINE_HASH_POLICY = "WARN"  # OFF / WARN / ENFORCE
ENFORCE_BASELINE_HASH = (BASELINE_HASH_POLICY == "ENFORCE")
WARN_BASELINE_HASH = (BASELINE_HASH_POLICY == "WARN")
EXPECTED_SOURCE_HASHES = {
    "secure_read_metric": "bcb3372ccd58fbb3d6fd79c426f60996b9ae8bfa04015f36d877ca3df44083c0",
    "secure_write_star_snapshot": "37e6215177ca6ff3ce4cb44f3e10b7f20bbc8b4cfe48657cacd8a0a6e284bf3c",
    "write_star_snapshot": "3c24ae66fbeb0d3a7f2daf699792c6b957d47ff512f18b488493f48745208e22",
    "phase_transition": "57d446d741a08163ed8f964d8edfb17bf4f9247dc42f23a1702d3d5eff7ad490",
    "advance_one_row": "1177db2eecbd85cd8c5f8894a309ce190dc1e3901fd06c082716b10cb594390d",
    "load_all_boots": "5763b0f4dd836c69c8bc72c41301938ddd3ddb0e752a4b28ea502dc76285bc72",
    "_audit_forbid_idx_offset": "d2755d9f2f5610fc202e4368accf5005a329b6d1406b19cf7484915609158671",
    "_audit_structure_slot_integrity": "f827836a9ea7b13a28a058f7edab2723b81626f4f4e82f356990267323843ae1",
}
PPBB_CHECKED = 0
PPBB_MISMATCH = 0
PPBB_FIRST_EVIDENCE = None

# ==========================
# æ­£å€¼è§¦å‘è‡ªå®¡é—¸é—¨ï¼ˆæ—¶é—´ç®¡ç†å±€ï½œé”æ­»ï¼‰
# ==========================
# å¼€å…³ï¼š1=å¯ç”¨ï¼Œ0=å…³é—­
POSITIVE_AUDIT_ENABLE = 1

# è§¦å‘é—¨æ§›ï¼ˆäºŒé€‰ä¸€æˆ–åŒæ—¶å¯ç”¨ï¼›é»˜è®¤ä»… Total>0ï¼‰
POSITIVE_AUDIT_TRIGGER_TOTAL = 1   # Total_Profit > 0
POSITIVE_AUDIT_TRIGGER_AVG = 0     # Avg_Profit > 0

# å½±å­é‡ç®—ï¼ˆå¯é€‰ï½œé»˜è®¤å…³ï¼›ä»…ç”¨äºè‡ªè¯ä¸€è‡´æ€§ï¼Œä¸æ”¹ç­–ç•¥é€»è¾‘ï¼‰
POSITIVE_AUDIT_SHADOW_RECHECK = 0

# è¿è¡Œæ€è‡ªè¯æ ‡è®°ï¼ˆé”æ­»ï¼‰
_WATERMARK_PRINTED = False
_PROOF_BLOCK_PRINTED = False
_SELFTEST_PASSED = False
_SOURCE_HASHES_PRINTED = False


# è¾“å‡ºé™é»˜å¼€å…³ï¼š1=é™é»˜ï¼ˆä»…ä¿ç•™ä¸»æŠ¥å‘Š+å¼ºåˆ¶è‡ªè¯ï¼›ä¸æ‰“å°è¡¨å¤´è‡ªè¯/L1åˆ†å¸ƒ/è¿ç»­ç»Ÿè®¡ï¼‰ï¼Œ0=è¯¦ç»†
# ğŸ€è¦†ç›–é”šç‚¹003_é™é»˜å¼€å…³ï¼ˆ0=å…¨é‡æŠ¥å‘Šé»˜è®¤æ˜¾ç¤ºï¼›1=åªä¿ç•™æœ€ç®€ç»“æœï¼‰
SILENT_MODE = 1

# å®¡æŸ¥è·‘å¼€å…³ï¼ˆæ—¶é—´ç®¡ç†å±€ï½œé”æ­»ï¼‰
# è§„åˆ™ï¼šå½“ AUDIT_RUN=1 æ—¶ï¼Œå¿…é¡»æ— æ¡ä»¶è¾“å‡ºâ€œå®¡æŸ¥è·‘å¿…å‡ºå—â€ï¼ˆå« L1 ä¸‰å—é”æ­»æ ‡é¢˜ï¼‰ï¼Œä¸å— SILENT_MODE å½±å“ã€‚
AUDIT_RUN = 0  # 0=æ™®é€šè·‘ï¼›1=å®¡æŸ¥è·‘ï¼ˆå®¡æŸ¥è·‘å¿…å‡ºï¼‰

# ============================================================
# å®¡è®¡æ—¥å¿—ç¼“å†²ï¼ˆé»˜è®¤é™é»˜ï½œä»…å¤±è´¥/æŠ¥é”™è¾“å‡ºï½œé”æ­»ï¼‰
# - ç›®çš„ï¼šé¿å…å“ˆå¸Œ/loc/å®¡è®¡æ˜ç»†å ç”¨æ‰“å°é¢æ¿
# - è¡Œä¸ºï¼šæ­£å¸¸âœ…é€šè¿‡ä¸æ‰“å°ï¼›é‡åˆ°âŒâŒâŒæˆ–å¼‚å¸¸æ—¶ä¸€æ¬¡æ€§åå‡ºç¼“å†²åŒº
# ============================================================
AUDIT_FAIL_ONLY = 1  # 1=ä»…å¤±è´¥è¾“å‡ºâœ…ï¼›0=æ€»æ˜¯è¾“å‡ºï¼ˆè°ƒè¯•ç”¨ï¼‰
_AUDIT_LOG_BUF = []

def _audit_log(line: str):
    try:
        _AUID = AUDIT_FAIL_ONLY
    except Exception:
        _AUID = 1
    # å§‹ç»ˆè®°å½•ï¼›æ˜¯å¦æ‰“å°ç”± flush å†³å®š
    _AUDIT_LOG_BUF.append(str(line))

def _flush_audit_log(tag: str = ""):
    global _AUDIT_LOG_BUF
    if not _AUDIT_LOG_BUF:
        return
    # ä»…åœ¨å¤±è´¥è·¯å¾„è°ƒç”¨æœ¬å‡½æ•°ï¼›å› æ­¤ä¸å†é¢å¤–åˆ¤æ–­é€šè¿‡/å¤±è´¥
    head = "ã€å®¡è®¡æ—¥å¿—ï¼ˆä»…å¤±è´¥è¾“å‡ºï¼‰ã€‘"
    if tag:
        head += f" {tag}"
    print(head)
    for x in _AUDIT_LOG_BUF:
        print(x)
    _AUDIT_LOG_BUF = []

# é´çº§å¼€å…³ï¼ˆé”æ­»ï¼‰ï¼šä»…é™åˆ¶â€œå®é™…è½æ³¨â€æ˜¯å¦å…è®¸å‘ç”Ÿåœ¨å‰8å£ï¼ˆseen_all=1..8ï¼‰
# BOOT_FILTER=ONâœ…ï¼šç¦ä¸‹æ³¨ seen_shift=1..8ï¼›ç¬¬9å£èµ·å…è®¸
# BOOT_FILTER=OFFâ›”ï¼šé´é¦–å…è®¸ä¸‹æ³¨
BOOT_FILTER = 0  # 1=ONâœ…ï¼Œ0=OFFâ›”
BOOT_FILTER_TEXT = "BOOT_FILTER=ONâœ…(ç¦ä¸‹æ³¨ seen_shift=1..8)" if BOOT_FILTER else "BOOT_FILTER=OFFâ›”(é´é¦–å…è®¸ä¸‹æ³¨)"

# BOOT_FILTER ç¦åŒºå¤„ç†ç­–ç•¥ï¼ˆå†»ç»“åŒºçœŸæºï½œé”æ­»ï¼‰
# 0=SKIP_STARï¼šå‘½ä¸­ç¦åŒºâ™»â­åªè·³è¿‡è¯¥â­ï¼Œç»§ç»­åœ¨åŒä¸€é´å¯»æ‰¾ä¸‹ä¸€é¢—â™»â­ï¼ˆéé¡ºå»¶ï¼‰
# 1=ABORT_BOOTï¼šå‘½ä¸­ç¦åŒºâ™»â­ç›´æ¥ä½œåºŸæ•´é´ï¼ˆä¸å†å¯»æ‰¾ä¸‹ä¸€é¢—â™»â­ï¼‰
BOOT_FILTER_FORBIDDEN_ABORT = 0

# é´çº§å¼€å…³æ ‡ç­¾ï¼ˆä¾›è¡¨å¤´/è‡ªè¯ç»Ÿä¸€è°ƒç”¨ï¼Œé¿å… NameErrorï¼‰
def _boot_filter_label() -> str:
    return BOOT_FILTER_TEXT

BET_IN_FORBIDDEN_SEEN = 0  # å®é™…è½æ³¨ç‚¹è½åœ¨ seen_all=1..8 çš„è®¡æ•°ï¼ˆå‘ç°å³ raiseï¼‰
# ============================================================
# ç»“æ„æ‰«æå¼€å…³ï¼ˆç»“æ„é—¸é—¨ï½œé”æ­»ï¼‰
# ============================================================
STRUCT_SCAN = 1  # 1=ONâœ…ï¼Œ0=OFFâ›”ï¼ˆä»…è‡ªè¯ç”¨ï¼ŒOFFæ—¶ç¦æ­¢ä»»ä½•ç­–ç•¥æ‰§è¡Œï¼‰
STRUCT_SCAN_TEXT = "STRUCT_SCAN=ONâœ…(ç»“æ„æ‰«æå¼€å¯)" if STRUCT_SCAN else "STRUCT_SCAN=OFFâ›”(ç»“æ„æ‰«æå…³é—­-ä»…è‡ªè¯)"
# ============================================================
# ç»“æ„æ’æ§½åŒºï¼ˆç‰ˆæœ¬Aï½œå”¯ä¸€å…è®¸å‡ºç°ç»“æ„é€»è¾‘çš„åŒºåŸŸï½œé”æ­»ï¼‰
# - åç»­æ›´æ¢ç»“æ„ï¼šåªå…è®¸æ›¿æ¢ã€Œç»“æ„æ’æ§½åŒºå¼€å§‹/ç»“æŸã€ä¸¤è¡Œä¹‹é—´çš„å†…å®¹
# - å…¶ä½™ä»»ä½•ä½ç½®å‡ºç°ç»“æ„åˆ¤æ–­/ç»“æ„å‡½æ•°è§†ä¸ºæ±¡æŸ“ï¼ˆè‡ªæ£€ä¼šæ‹¦æˆªï¼‰
# ============================================================

# ============================================================
# ç»“æ„æ’æ§½ï½œæ¸…å•ä¸æŒ‡çº¹ï¼ˆåŸºåº§/æ’æ§½åˆ†ç¦»ï¼‰
# - æ ¸å¿ƒåŸºåº§æŒ‡çº¹ï¼šæ’é™¤ç»“æ„æ’æ§½æ–‡æœ¬ï¼Œç”¨äºâ€œåŸºåº•å†»ç»“â€åˆ¤å®š
# - æ’æ§½æŒ‡çº¹ï¼šä»…ç»“æ„æ’æ§½æ–‡æœ¬ï¼Œç”¨äºâ€œç»“æ„å¯å˜â€è®°å½•
# - æ’æ§½å¿…é¡»å¯è¢«è¾¹ç•Œæ ‡è¯†å”¯ä¸€å®šä½ï¼š0ä¸ªæˆ–>1ä¸ªå‡åˆ¤æ­»
# ============================================================
STRUCTURE_SLOT_NAME = "STRUCTURE_SLOT"
STRUCTURE_SLOT_VERSION = "V2"
CORE_BASE_FINGERPRINT = None
STRUCTURE_SLOT_FINGERPRINT = None
STRUCTURE_SLOT_LINE_RANGE = None  # (begin_line, end_line)

# ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_BEGINï¼ˆæ•´æ®µè¦†ç›–ç”¨æ­¤è¡Œå®šä½ï¼›è¦†ç›–èŒƒå›´=æœ¬è¡Œåˆ°å¯¹åº”_ENDï¼‰
# [SLOT_BEGIN] STRUCTURE_SLOT
# [STRUCT_SLOT_BEGIN]
# è¾“å‡ºç­–ç•¥ï¼šæœ¬æ’æ§½ä»…æ”¾â€œç»“æ„é…ç½®è¡¨â€ï¼›ç®—æ³•åœ¨å†»ç»“åŒºï¼ˆé¿å…å†™æ‰‹æ”¹åï¼‰
# ç»“æ„é…ç½®è¡¨ï¼ˆè¦†ç›–åŒºå¯æ”¹ï½œåªå¡«è¿™ä¸€å¼ è¡¨ï¼‰
# åˆ—ï¼šstep | side(S/W/B/P) | min_len | max_len | mark(â­=ç»“æ„ç»ˆç‚¹)
# v2 é”æ­»ï¼šâ­ å¿…é¡»å”¯ä¸€ä¸”å‡ºç°åœ¨æœ€åä¸€è¡Œï¼›è¦†ç›–åŒºä¸å¾—å†™ä»»ä½•æ‰«æ/é—¨ç¦é€»è¾‘
# é»˜è®¤ç»“æ„ï¼šSâ‰¥3 â†’ W1-2 â†’ Sâ­
STRUCT_CONFIG_TEXT = """step	side	min_len	max_len	mark
1	S	3	999	
2	W	1	2	
3	S	1	999	â­
"""

def scan_structure(records):
    """ç»“æ„æ’æ§½ï¼ˆè¦†ç›–åŒºï¼‰ï¼šåªæä¾›é…ç½®ï¼›æ‰«æå™¨åœ¨å†»ç»“åŒºã€‚"""
    return _frozen_scan_structure(records, STRUCT_CONFIG_TEXT)
# [STRUCT_SLOT_END]
# [SLOT_END] STRUCTURE_SLOT
# ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_END

STRUCT_DEF_HASH = None  # AUTOï¼ˆç”± STRUCT_CONFIG_TEXT + Anchor è®¡ç®—ï¼‰
_STRUCT_SUMMARY_PRINTED = False

# ==========================
# å†»ç»“åŒºï½œç»“æ„æ‰«æå¼•æ“ï¼ˆé…ç½®é©±åŠ¨ï½œé”æ­»ï¼‰
# ==========================
# ç›®æ ‡ï¼šç»“æ„è¡¨æ ¼å¯ç”±è¦†ç›–åŒºå¡«å†™ï¼›æ‰«æç®—æ³•ä¸å£å¾„å›ºå®šåœ¨å†»ç»“åŒºï¼Œé¿å…å†™æ‰‹æ”¹åã€‚

SW_RULE = {
    "MODE": "RUNLEN",           # æ®µé•¿å£å¾„ï¼šè¿ç»­æ®µé•¿
    "VALID_R": ("B", "P"),      # ä»…BPå‚ä¸ç»“æ„æ®µé•¿
    "IGNORE_T": True,           # T ä¸å‚ä¸ã€ä¸æ‰“æ–­
    "ZERO_DIFF_INVALID": True,  # ç‚¹å·®==0 ä¸å‚ä¸ã€ä¸æ‰“æ–­

    # æœªå®šä¹‰æœŸ temp_S å£å¾„ï¼ˆé”æ­»ï½œæ–¹æ¡ˆBï¼‰
    "TEMP_INIT": "FIRST_VALID_WINNER",  # é¦–ä¸ªæœ‰æ•ˆå£èµ¢å®¶å³ temp_S
    "HYST_SWITCH": 3,                   # è¢«åè¶…é˜ˆå€¼ï¼šå¯¹æ–¹é¢†å…ˆ>=3æ‰åˆ‡æ¢
    "WINNER_SOURCE": "DIFF_SIGN",       # èƒœæ–¹åªè®¤ diff ç¬¦å·ï¼š<0=P >0=B =0=T
}

# Anchorï¼ˆé”šç‚¹ï¼‰å£å¾„ï¼ˆå†»ç»“åŒºçœŸæºï½œé”æ­»ï¼‰
# - FROM_BOOT_START_LOCK_SWï¼ˆé»˜è®¤ï¼‰ï¼šä»é´é¦–å¼€å§‹æ‰«æï¼›S/W ç”±â€œè°å…ˆå‡ºç°è¿ç»­æœ‰æ•ˆå£æ®µé•¿>=3â€é”å®šä¸ºæœ€ç»ˆå¼ºæ–¹
STRUCT_ANCHOR_MODE = "FROM_BOOT_START_LOCK_SW"


def _boot_filter_rule():
    """é´çº§è§„åˆ™ï¼ˆå†»ç»“åŒºçœŸæºï¼‰"""
    return {
        "min_seen": 9,                       # BOOT_FILTER=ON æ—¶å…è®¸ä¸‹æ³¨/å†™å…¥å¿«ç…§çš„æœ€å° seen_all
        "forbidden_lo": 1,
        "forbidden_hi": 8,                   # ç¦åŒºï¼šseen_all=1..8
        "forbidden_action": "ABORT_BOOT" if BOOT_FILTER_FORBIDDEN_ABORT else "SKIP_STAR",
    }

BOOT_FILTER_RULE = _boot_filter_rule()

def _cfg_parse_int(x):
    try:
        if x is None:
            return None
        if isinstance(x, bool):
            return int(x)
        if isinstance(x, (int, float)):
            if isinstance(x, float) and (x != x):  # nan
                return None
            return int(x)
        s = str(x).strip()
        if s == "" or s.lower() == "none" or s.lower() == "nan":
            return None
        return int(float(s))
    except Exception:
        return None

def _cfg_is_valid_struct_row(rec: dict):
    """ç»“æ„è¡Œæœ‰æ•ˆæ€§ï¼šä»¥ç‚¹å·®æ¨èƒœè´Ÿï¼ˆç”¨æˆ·å£å¾„ï¼šdiff<0=P, diff>0=B, diff==0=Tï¼‰ã€‚
    ä»…å½“ diff å¯è§£æä¸”é0 æ—¶è§†ä¸ºæœ‰æ•ˆå£ï¼›T/0 åªä½ç§»ä¸è®¡æ®µé•¿ã€‚
    """
    d = _cfg_parse_int(rec.get("diff"))
    if d is None:
        return False
    if SW_RULE["ZERO_DIFF_INVALID"] and d == 0:
        return False
    # èµ¢å®¶ä¾§ä» diff æ¨å¯¼ï¼Œé¿å… r/Exhaust è§£æå¼‚å¸¸å¯¼è‡´è¯¯åˆ¤ä¸ºæ— æ•ˆå£
    rec["_r_by_diff"] = "B" if d > 0 else ("P" if d < 0 else "T")
    return rec["_r_by_diff"] in ("B", "P")

def _cfg_parse_struct_table(text: str):
    """è§£æè¦†ç›–åŒºç»“æ„è¡¨ï¼ˆSTRUCT-Lang v2ï¼‰ã€‚
    å…è®¸ï¼šN è¡Œï¼ˆN>=1ï¼‰ï¼Œå­—æ®µï¼šstep | side | min_len | max_len | mark
    sideï¼šS/Wï¼ˆå¼ºå¼±æ–¹ï¼‰æˆ– B/Pï¼ˆç»å¯¹æ–¹ï¼‰
    v2 é”æ­»æ ¡éªŒï¼š
      - step å¿…é¡»è¿ç»­é€’å¢ï¼ˆ1..Nï¼‰
      - min/max ä¸ºæ­£æ•´æ•°ä¸” min<=max
      - â­ å¿…é¡»å”¯ä¸€ä¸”å‡ºç°åœ¨æœ€åä¸€è¡Œ
    """
    if text is None:
        raise RuntimeError("STRUCT_CONFIG_INVALID: empty")
    raw_lines = []
    for raw in str(text).splitlines():
        s = raw.strip()
        if not s:
            continue
        if s.startswith("#"):
            continue
        raw_lines.append(s)
    if not raw_lines:
        raise RuntimeError("STRUCT_CONFIG_INVALID: empty")

    # è·³è¿‡è¡¨å¤´è¡Œï¼ˆåŒ…å« step/side/min_len/max_lenï¼‰
    if ("step" in raw_lines[0].lower()) and ("side" in raw_lines[0].lower()):
        raw_lines = raw_lines[1:]
    if not raw_lines:
        raise RuntimeError("STRUCT_CONFIG_INVALID: empty")

    rows = []
    for s in raw_lines:
        parts = [p for p in re.split(r"\s+|\t+", s.strip()) if p != ""]
        if len(parts) < 4:
            continue
        step = _cfg_parse_int(parts[0])
        side = str(parts[1]).strip().upper()
        min_len = _cfg_parse_int(parts[2])
        max_len = _cfg_parse_int(parts[3])
        mark = str(parts[4]).strip() if len(parts) >= 5 else ""
        if step is None or min_len is None or max_len is None:
            continue
        rows.append({
            "step": int(step),
            "side": side,
            "min_len": int(min_len),
            "max_len": int(max_len),
            "mark": mark,
        })

    rows.sort(key=lambda x: x["step"])
    if len(rows) < 1:
        raise RuntimeError("STRUCT_CONFIG_INVALID: need>=1")

    # step è¿ç»­é€’å¢ï¼ˆ1..Nï¼‰
    for i, r in enumerate(rows, 1):
        if r["step"] != i:
            raise RuntimeError("STRUCT_CONFIG_INVALID: step_not_continuous")

    # å­—æ®µæ ¡éªŒ
    for r in rows:
        if r["side"] not in ("S", "W", "B", "P"):
            raise RuntimeError("STRUCT_CONFIG_INVALID: bad_side")
        if r["min_len"] <= 0 or r["max_len"] <= 0:
            raise RuntimeError("STRUCT_CONFIG_INVALID: minmax_must_be_positive")
        if r["min_len"] > r["max_len"]:
            raise RuntimeError("STRUCT_CONFIG_INVALID: min_gt_max")

    # â­ å”¯ä¸€ä¸”åœ¨æœ€åä¸€è¡Œï¼ˆv2 é”æ­»ï¼‰
    star_steps = [r["step"] for r in rows if ("â­" in (r.get("mark") or ""))]
    if len(star_steps) != 1:
        raise RuntimeError("STRUCT_CONFIG_INVALID: star_must_be_unique")
    if star_steps[0] != rows[-1]["step"]:
        raise RuntimeError("STRUCT_CONFIG_INVALID: star_must_be_last")

    return rows

def _cfg_norm_struct_text(text: str) -> str:
    """ç»“æ„è¡¨è§„èŒƒåŒ–æ–‡æœ¬ï¼ˆç”¨äº HASHï¼‰ã€‚"""
    if text is None:
        return ""
    lines = []
    for raw in str(text).splitlines():
        s = raw.strip()
        if not s:
            continue
        if s.startswith("#"):
            continue
        lines.append(s)
    if lines and ("step" in lines[0].lower()) and ("side" in lines[0].lower()):
        lines = lines[1:]
    return "\n".join(lines).strip()

def _cfg_struct_expr(rows) -> str:
    """ç»“æ„è¡¨è¾¾ï¼ˆç”¨äºæ‰“å°ï¼‰ï¼šä¾‹ Sâ‰¥3 â†’ W1-2 â†’ Sâ­"""
    parts = []
    for i, r in enumerate(rows, 1):
        side = r["side"]
        mn = int(r["min_len"])
        mx = int(r["max_len"])
        is_last = (i == len(rows))
        seg = ""
        if (not is_last) or (not (mn == 1 and mx >= 999)):
            if mx >= 999:
                seg = f"â‰¥{mn}"
            elif mn == mx:
                seg = f"{mn}"
            else:
                seg = f"{mn}-{mx}"
        mark = "â­" if is_last else ""
        parts.append(f"{side}{seg}{mark}")
    return " â†’ ".join(parts)

def _cfg_struct_hash(text: str, anchor_mode: str) -> str:
    """ç»“æ„ HASHï¼ˆå« Anchorï¼‰ã€‚"""
    norm = _cfg_norm_struct_text(text)
    payload = (str(anchor_mode or "") + "\n" + norm).encode("utf-8")
    return hashlib.md5(payload).hexdigest()[:8]

def _cfg_config_uses_sw(rows) -> bool:
    return any((r.get("side") in ("S", "W")) for r in (rows or []))

def _cfg_anchor_define_after_s_defined(records):
    """å®šä¹‰ Anchorï¼šS_DEFINED_IDX ä¸ strong_absï¼ˆB/Pï¼‰ã€‚
    å£å¾„é”æ­»ï¼ˆé´é¦–æ‰«æç‰ˆï¼‰ï¼š
      - strong_absï¼šè°å…ˆå‡ºç°â€œè¿ç»­æœ‰æ•ˆå£æ®µé•¿ï¼ˆRUNLENï¼‰>=3â€ï¼Œè°å°±æ˜¯ Sï¼ˆå¼ºï¼‰
      - S_DEFINED_IDXï¼šè¯¥ RUNLEN è¾¾åˆ°ç¬¬3å£æ‰€åœ¨çš„ records è¡Œå·ï¼ˆ0-based idxï¼‰
      - åªè®¡æœ‰æ•ˆå£ï¼šrâˆˆ{B,P} ä¸” diff!=0ï¼›T/0 åªä½ç§»
    """
    run_side = None
    run_len = 0
    for i, rec in enumerate(records or []):
        if not _cfg_is_valid_struct_row(rec):
            continue
        r = (rec.get("r") or "").strip()
        if r == run_side:
            run_len += 1
        else:
            run_side = r
            run_len = 1
        if run_len >= 3:
            return i, run_side
    return None, None

def scan_by_config_v2(records, rows, anchor_mode, sw_rule):
    """å†»ç»“åŒºï¼šé…ç½®é©±åŠ¨ç»“æ„æ‰«æå™¨ v2ï¼ˆå¤šæ®µï½œé´é¦–æ‰«æç‰ˆï½œRUNLENï¼‰ã€‚

    è¿”å›ï¼š("STRUCT_OK"|"STRUCT_FAIL", entry_star_idx_or_None, strong_abs_or_None, info)

    å£å¾„é”æ­»ï¼š
    - æ‰«æä» records ç¬¬ä¸€è¡Œå¼€å§‹ï¼ˆä¸åš Anchor æˆªæ–­ï¼‰
    - strong_absï¼šè°å…ˆå‡ºç°â€œè¿ç»­æœ‰æ•ˆå£æ®µé•¿ï¼ˆRUNLENï¼‰>=3â€ï¼Œè°å°±æ˜¯ Sï¼ˆå¼ºï¼‰ï¼›ä¹‹åä¸å†åˆ‡æ¢
    - æœªå®šä¹‰æœŸï¼štemp_S/temp_W=å½“å‰ç´¯è®¡é¢†å…ˆæ–¹ï¼ˆæœ‰æ•ˆå£ç´¯è®¡ cntB/cntPï¼›å¹³æ‰‹ KEEP_LASTï¼›é¦–ä¸ªæœ‰æ•ˆå£å…œåº•ï¼‰
      ä¸” temp_S ä¸€æ—¦åˆ‡æ¢ï¼šB1 é‡ç½®åˆ° step1ï¼ˆé˜²æ®µå†…æ¢è¾¹æ¼‚ç§»ï¼‰
    - æ®µé•¿ç´¯è®¡ï¼šç»“æ„æ®µé•¿æŒ‰ RUNLENï¼ˆè¿ç»­åŒä¾§æœ‰æ•ˆå£ï¼‰ï¼›T/0 åªä½ç§»ä¸è®¡æ®µé•¿ã€ä¸æ‰“æ–­
    - BOOT_FILTER ç¦åŒºï¼šæŒ‰ä½ç§»å£ seen_shift=1..8ï¼ˆå«T/0ï¼‰ï¼Œä»…å½±å“ ENTRYâ™»â­ï¼›RAWâ™»â­ä¸å—å½±å“
    - æ®µè¾¹ç•Œï¼šä»¥â€œä¾§å˜/mismatchâ€ä½œä¸ºè‡ªç„¶è¾¹ç•Œï¼›è¾¾åˆ° min_len ä¸ä¼šåœ¨åŒä¸€å£å¼ºè¡Œè·¨æ®µ
    """
    info = {
        "fail_reason": None,

        # RAW / ENTRYï¼ˆåŒâ™»â­ï¼‰
        "raw_star_idx": None,
        "entry_star_idx": None,

        # ç¦åŒºä½œåºŸï¼ˆå¿…é¡»å‡ºç°ï¼‰
        "skipped_forbidden_star_cnt": 0,     # ç¦åŒºå‘½ä¸­çš„â­è¢«ä½œåºŸæ¬¡æ•°
        "forbidden_star_cnt": 0,             # ç¦åŒºå‘½ä¸­æ€»æ¬¡æ•°ï¼ˆå«ABORT/å…¶å®ƒï¼‰
        "forbidden_star_first_seen": None,   # é¦–æ¬¡ç¦åŒºå‘½ä¸­çš„ RAWâ™»â­ idx

        # çŠ¶æ€é‡ç½®è®¡æ•°ï¼ˆå¿…é¡»å‡ºç°ï¼‰
        "reset_to_step1_cnt": 0,             # æ‰€æœ‰å›åˆ° step1 çš„æ¬¡æ•°ï¼ˆå«ç¦åŒº/ä¾§å˜/æº¢å‡ºç­‰ï¼‰
        "reset_forbidden_cnt": 0,            # ç¦åŒºä½œåºŸå¯¼è‡´çš„é‡ç½®æ¬¡æ•°ï¼ˆåº”ä¸ skipped_forbidden_star_cnt ä¸€è‡´ï¼‰
        "reset_side_switch_cnt": 0,          # temp_S å‘ç”Ÿåˆ‡æ¢å¯¼è‡´çš„é‡ç½®æ¬¡æ•°

        # temp_S è‡ªè¯
        "temp_init_idx": None,               # temp_S é¦–æ¬¡å»ºç«‹çš„ idxï¼ˆé¦–ä¸ªæœ‰æ•ˆå£ï¼‰
        "temp_switch_cnt": 0,                # temp_S åˆ‡æ¢æ¬¡æ•°ï¼ˆè¢«åè¶…>=é˜ˆå€¼ï¼‰

        # å®¡è®¡å­—æ®µ
        "anchor_mode": anchor_mode,
        "struct_hash": _cfg_struct_hash(STRUCT_CONFIG_TEXT, anchor_mode),
        "struct_expr": _cfg_struct_expr(rows),
        "s_defined_idx": None,
    }

    step_i = 0          # 0-based
    seg_len = 0

    # strong_abs / weak_absï¼šæœ€ç»ˆ S/Wï¼ˆç»å¯¹æ–¹ï¼‰
    strong_abs = None
    weak_abs = None

    # æœªå®šä¹‰æœŸ tempï¼ˆé¢†å…ˆæ–¹ï¼‰
    cntB = 0
    cntP = 0
    keep_last_leader = None  # temp_Sï¼ˆç»å¯¹æ–¹ B/Pï¼‰

    # ç”¨äºé”å®š strong_abs çš„ RUNLENï¼ˆç»å¯¹æ–¹ï¼‰
    run_side = None
    run_len = 0

    rule = BOOT_FILTER_RULE
    forbidden_lo, forbidden_hi = rule["forbidden_lo"], rule["forbidden_hi"]
    forbidden_action = rule.get("forbidden_action", "SKIP_STAR")

    def _opp(bp):
        return "P" if bp == "B" else ("B" if bp == "P" else None)

    def _expected_abs(side: str):
        # ç»å¯¹æ–¹
        if side in ("B", "P"):
            return side
        # å¼ºå¼±æ–¹
        if side in ("S", "W"):
            if strong_abs is not None:
                return strong_abs if side == "S" else weak_abs
            # æœªå®šä¹‰æœŸï¼šä¾èµ– temp_S/temp_W
            if keep_last_leader is None:
                return None
            return keep_last_leader if side == "S" else _opp(keep_last_leader)
        return None

    def _reset(reason: str = None):
        nonlocal step_i, seg_len
        step_i = 0
        seg_len = 0
        # è®¡æ•°ï¼šç”¨äºéªŒæ”¶â€œç¦åŒºå‘½ä¸­å¿…é¡»é‡ç½®â€
        info["reset_to_step1_cnt"] += 1
        if reason == "FORBIDDEN":
            info["reset_forbidden_cnt"] += 1
        elif reason == "SIDE_SWITCH":
            info["reset_side_switch_cnt"] += 1

    def _maybe_commit_star(cand_star_idx, seen_shift):
        # RAWâ™»â­ï¼šè®°å½•ç¬¬ä¸€é¢—çº¯ç»“æ„æ˜Ÿï¼ˆæ— è®ºæ˜¯å¦è¢«ç¦åŒºè·³è¿‡ï¼‰
        if info["raw_star_idx"] is None:
            info["raw_star_idx"] = cand_star_idx

        if BOOT_FILTER and (forbidden_lo <= seen_shift <= forbidden_hi):
            info["forbidden_star_cnt"] += 1
            if info["forbidden_star_first_seen"] is None:
                info["forbidden_star_first_seen"] = cand_star_idx

            if forbidden_action == "ABORT_BOOT":
                info["fail_reason"] = "FORBIDDEN_ABORT"
                return "STRUCT_FAIL", None, strong_abs, info

            # SKIP_STARï¼šè¯¥â­ä½œåºŸï¼Œé‡ç½®ç»“æ„åŒ¹é…çŠ¶æ€ï¼Œç»§ç»­æ‰¾ä¸‹ä¸€é¢—ï¼ˆæ¢äº‹ä»¶ï¼‰
            info["skipped_forbidden_star_cnt"] += 1
            _reset("FORBIDDEN")
            return None

        info["entry_star_idx"] = cand_star_idx
        return "STRUCT_OK", cand_star_idx, strong_abs, info

    for i, rec in enumerate(records or []):
        idx = i                 # records è¡Œå·ï¼ˆ0-basedï¼‰
        seen_shift = i + 1      # ä½ç§»å£ï¼ˆå«T/0ï¼‰

        if not _cfg_is_valid_struct_row(rec):
            # æ— æ•ˆå£ï¼šåªä½ç§»ï¼Œä¸è®¡æ®µé•¿ï¼Œä¸æ‰“æ–­
            continue

        # èƒœæ–¹åªè®¤ diff ç¬¦å·ï¼ˆé”æ­»ï¼‰ï¼š<0=P >0=B =0/T
        d = _cfg_parse_int(rec.get("diff"))
        if d is None:
            r_abs = "T"
        else:
            r_abs = "B" if d > 0 else ("P" if d < 0 else "T")
        rec["_r_by_diff"] = r_abs

        # 1) RUNLENï¼šç”¨äºé”å®š strong_absï¼ˆè°å…ˆè¿ç»­>=3ï¼‰
        if r_abs == run_side:
            run_len += 1
        else:
            run_side = r_abs
            run_len = 1

        if strong_abs is None and run_len >= 3:
            strong_abs = run_side
            weak_abs = _opp(strong_abs)
            info["s_defined_idx"] = idx

        # 2) æœªå®šä¹‰æœŸ temp_Sï¼ˆé”æ­»ï½œæ–¹æ¡ˆB + è¿Ÿæ»é˜ˆå€¼ï¼‰
        # åªè®¡æœ‰æ•ˆå£ç´¯è®¡ï¼šd=cntB-cntP
        if r_abs == "B":
            cntB += 1
        elif r_abs == "P":
            cntP += 1

        d_bp = cntB - cntP

        # æ–¹æ¡ˆBï¼šé¦–ä¸ªæœ‰æ•ˆå£èµ¢å®¶å³å»ºç«‹ temp_Sï¼ˆä¸ç­‰å¾…é˜ˆå€¼ï¼‰
        if keep_last_leader is None:
            keep_last_leader = r_abs
            info["temp_init_idx"] = idx
        else:
            leader = keep_last_leader

            # è¿Ÿæ»åˆ‡æ¢ï¼šåªæœ‰è¢«åè¶…åˆ°å¯¹æ–¹é¢†å…ˆ>=HYST_SWITCH æ‰å…è®¸åˆ‡æ¢
            thr = int(SW_RULE.get("HYST_SWITCH", 3))
            if keep_last_leader == "B" and d_bp <= -thr:
                leader = "P"
            elif keep_last_leader == "P" and d_bp >= thr:
                leader = "B"

            if leader != keep_last_leader:
                info["temp_switch_cnt"] += 1
                # æœªé”å®šæœŸä¾§å˜ï¼šå¿…é¡»å›åˆ° step1ï¼ˆé˜²æ®µå†…æ¢è¾¹æ¼‚ç§»ï¼‰
                if strong_abs is None:
                    _reset("SIDE_SWITCH")
                keep_last_leader = leader

        # ä¸€ä¸ªæœ‰æ•ˆå£å¯èƒ½è§¦å‘â€œæ®µç»“æŸ/è·¨æ®µ/é‡ç½®â€ï¼Œå› æ­¤ç”¨ while å…è®¸åŒä¸€å£è¢«å¤šæ¬¡å½’å±ï¼ˆä»…åœ¨ mismatch æ—¶ï¼‰
        while True:
            cur = rows[step_i]
            exp = _expected_abs(cur["side"])
            if exp is None:
                _reset()
                break

            if r_abs == exp:
                seg_len += 1

                # è¶…ä¸Šé™ï¼šé‡ç½®å¹¶å°è¯•ä»¥å½“å‰å£ä½œä¸ºæ–°èµ·ç‚¹
                if seg_len > int(cur["max_len"]):
                    _reset()
                    # å…è®¸å½“å‰å£ä½œä¸ºæ–°èµ·ç‚¹ï¼ˆç»§ç»­ whileï¼‰
                    continue

                # â­ï¼šæœ€åä¸€æ®µè¾¾åˆ° min_lenï¼ˆå…è®¸â€œæœ€æ—©æ»¡è¶³å³â­â€ï¼‰
                if step_i == (len(rows) - 1) and seg_len >= int(cur["min_len"]):
                    res = _maybe_commit_star(idx, seen_shift)
                    if res is not None:
                        return res
                    # SKIP_STARï¼šç»§ç»­ä¸‹ä¸€å£
                    break

                # åœ¨ RUNLEN å£å¾„ä¸‹ï¼šè¾¾åˆ° min_len ä¸ä¼šåœ¨åŒä¸€å£å¼ºè¡Œè·¨æ®µï¼ˆé¿å…â€œåŒä¸€å£è¢«ä¸¤æ®µåŒæ—¶æ¶ˆè´¹â€ï¼‰
                break

            # mismatchï¼ˆä¾§å˜/ä¸åŒ¹é…ï¼‰ï¼šå½“å‰å£ä¸å±äºæœ¬æ®µï¼Œå°è¯•ç»“æŸæœ¬æ®µå¹¶æŠŠå½“å‰å£å½’å±åˆ°ä¸‹ä¸€æ®µ/æ–°èµ·ç‚¹
            if seg_len == 0:
                # å°šæœªè¿›å…¥æ®µï¼šå…è®¸å›åˆ° step1 é‡æ–°è§£é‡Š
                if step_i != 0:
                    _reset()
                    continue
                # step1 éƒ½ä¸åŒ¹é…ï¼šæœ¬å£æ— æ³•ä½œä¸ºèµ·ç‚¹
                break

            # æ®µå·²å¼€å§‹ï¼šæ£€æŸ¥æœ¬æ®µæ˜¯å¦æ»¡è¶³æœ€çŸ­
            if seg_len < int(cur["min_len"]):
                # æ®µå¤ªçŸ­ï¼šé‡ç½®ï¼Œå¹¶å°è¯•å½“å‰å£ä½œä¸ºæ–°çš„èµ·ç‚¹
                _reset()
                continue

            # æ®µæ»¡è¶³ï¼šè¿›å…¥ä¸‹ä¸€æ®µï¼Œå¹¶ç”¨åŒä¸€å£é‡è¯•ï¼ˆè¯¥å£å±äºä¸‹ä¸€æ®µçš„é¦–å£ï¼‰
            step_i += 1
            if step_i >= len(rows):
                _reset()
                break
            seg_len = 0
            continue

    if info["forbidden_star_cnt"] > 0:
        info["fail_reason"] = "ONLY_FORBIDDEN"
    else:
        info["fail_reason"] = "NO_CANDIDATE"
    return "STRUCT_FAIL", None, strong_abs, info

def _get_struct_summary_line_and_hash():
    """ç»™æŠ¥å‘Šç”¨ï¼šç»“æ„æ‘˜è¦è¡Œ + HASHï¼ˆå« Anchorï¼‰ã€‚"""
    try:
        rows = _cfg_parse_struct_table(STRUCT_CONFIG_TEXT)
        expr = _cfg_struct_expr(rows)
        h = _cfg_struct_hash(STRUCT_CONFIG_TEXT, STRUCT_ANCHOR_MODE)
        return f"ç»“æ„æ‘˜è¦ï¼š{expr} | HASH={h}", h
    except Exception:
        return "ç»“æ„æ‘˜è¦ï¼š<PARSE_FAIL>", "NA"
def _frozen_scan_structure(records, struct_config_text):
    """å†»ç»“åŒºç»“æ„æ‰«æï¼ˆé…ç½®é©±åŠ¨ v2ï¼šå¤šæ®µ + Anchorï¼‰
    è¿”å›ï¼š("STRUCT_OK"|"STRUCT_FAIL", star_idx_or_None, strong_side_or_None, info)
    - star_idxï¼šENTRYâ™»â­ï¼ˆé´çº§é—¨ç¦åå¯å…¥åœºçš„â­ï¼›å…¼å®¹æ—§å­—æ®µï¼‰
    - info åŒæ—¶åŒ…å« RAWâ™»â­ ä¸ HASH ç­‰å®¡è®¡å­—æ®µ
    """
    anchor_mode = STRUCT_ANCHOR_MODE

    try:
        rows = _cfg_parse_struct_table(struct_config_text)
    except Exception as e:
        return "STRUCT_FAIL", None, None, {
            "fail_reason": f"PARSE_FAIL:{e}",
            "forbidden_star_cnt": 0,
            "forbidden_star_first_seen": None,
        }

    st, entry_star_idx, strong_abs, info = scan_by_config_v2(records, rows, anchor_mode, SW_RULE)
    if st != "STRUCT_OK":
        return "STRUCT_FAIL", None, strong_abs, info

    entry_star_idx = info.get("entry_star_idx", entry_star_idx)
    info["raw_star_idx"] = info.get("raw_star_idx")
    info["entry_star_idx"] = entry_star_idx
    info["struct_hash"] = info.get("struct_hash") or _cfg_struct_hash(struct_config_text, anchor_mode)
    info["struct_expr"] = info.get("struct_expr") or _cfg_struct_expr(rows)

    return "STRUCT_OK", entry_star_idx, strong_abs, info
# ==========================
# æ‰“å°æ ¼å¼å·¥å…·ï¼ˆé”æ­»ï¼‰
# ==========================
def _pct(n, d, nd=2):
    if d <= 0:
        return "0%"
    return f"{(n * 100.0 / d):.{nd}f}%"

def _cnt_pct(n, d, nd=2):
    return f"{n} ({_pct(n, d, nd)})"

# å¼€å…³æ‰“å°ç¡¬é”ï¼ˆé”æ­»ï¼‰ï¼šè¡¨å¤´+å¼ºåˆ¶è‡ªè¯ å‡å¿…é¡»æ‰“å°
_PRINTED_SWITCHES_HEADER = False
_PRINTED_SWITCHES_PROOF = False

def _print_switches_block(where: str):
    """ç¡¬é”ï¼šå¿…é¡»æ‰“å° BOOT_FILTER ä¸ STRUCT_SCANï¼›å¹¶æ‰“æ ‡è®°ä¾›æ–­è¨€ã€‚"""
    global _PRINTED_SWITCHES_HEADER, _PRINTED_SWITCHES_PROOF
    print(f"ç»“æ„é—¸é—¨ï¼š{STRUCT_SCAN_TEXT}")
    print(f"é´çº§å¼€å…³ï¼š{_boot_filter_label()}")
    if where == "HEADER":
        _PRINTED_SWITCHES_HEADER = True
    elif where == "PROOF":
        _PRINTED_SWITCHES_PROOF = True
        _PRINTED_SWITCHES_HEADER = True  # PROOF å·²æ‰“å°åŒæ ·å¼€å…³ï¼Œè§†åŒæ»¡è¶³è¡¨å¤´è‡ªè¯
    else:
        # æœªçŸ¥ä½ç½®ä»ä¸å…è®¸é™é»˜æ”¾è¿‡
        raise RuntimeError("âŒ _print_switches_block(where) where éæ³•")
# ä¸Šä¸‹æ–‡ï¼ˆç”¨äºæœ€å°æº¯æºæ‰“å°ï¼‰
_CTX_FILE = ""
_CTX_SUBBATCH = ""


def _audit_forbid_idx_offset():
    """
    å®‰å…¨è‡ªæ£€ï¼ˆé”æ­»ï½œæ‰§è¡Œ/ç»“ç®—æ®µï¼‰ï¼š
    - ç¦æ­¢ï¼šä»¥ idx ä¸ºåŸºå‡†ç›´æ¥æ¨å¯¼â€œæœªæ¥è¡Œå·â€ï¼ˆä¾‹å¦‚ï¼šidx ä¸åç§»é‡æ‹¼æ¥å¾—åˆ°æŸè¡Œï¼‰
    - ç¦æ­¢ï¼šåœ¨æ‰§è¡Œ/ç»“ç®—æ®µå›è¯» diff/rate/mean ä½œä¸ºåˆ¤æ–­ä¾æ®
    è¯´æ˜ï¼šåªå®¡è®¡ run_strategy_on_boot() å†…â€œç»“ç®—å¼€å§‹é”šç‚¹â€ä¹‹åçš„ä»£ç ï¼Œé¿å…è¯¯ä¼¤â€œæŠ•æ”¾å‰å¿«ç…§â€ã€‚
    """
    if not SILENT_MODE:
        print("=== å®‰å…¨è‡ªæ£€å¼€å§‹ ===")
    # 1) æŠ½å–ç­–ç•¥æºç ï¼ˆæ— æ³•è¯»å–åˆ™ç›´æ¥åˆ¤å®šä¸é€šè¿‡ï¼‰
    try:
        src = inspect.getsource(run_strategy_on_boot)
    except Exception:
        raise RuntimeError("SELF_TEST_FAIL: CANNOT_READ_SOURCE_RUN_STRATEGY")

    # 2) åªå®¡è®¡â€œæ‰§è¡Œ/ç»“ç®—æ®µâ€ï¼šä»é”šç‚¹å¼€å§‹å¾€å
    anchor = "# 3) EXECUTE"
    pos = src.find(anchor)
    audit_src = src[pos:] if pos >= 0 else src

    # 3) ç¦æ­¢ç‰‡æ®µï¼ˆæ‰§è¡Œ/ç»“ç®—æ®µï¼‰
    # æ³¨æ„ï¼šä¸ºäº†é¿å…â€œè‡ªæ£€å­—ç¬¦ä¸²æœ¬èº«â€è§¦å‘æ›´ä¸Šå±‚çš„æºç é›·è¾¾ï¼Œæœ¬å¤„ç”¨æ‹¼æ¥ç”Ÿæˆæ¨¡å¼ä¸²ã€‚
    a = "idx"
    sp = " +"
    lbr = "records["
    forbidden = [
        # æœªæ¥è¡Œå·ç›´ç®—ï¼ˆç¦æ­¢ï¼‰
        a + sp + " step_idx", a + "+step_idx",
        # ç¦æ­¢ star_idx åç§»ç›´ç®—
        "star_idx + 1", "star_idx+1", "star_idx +", "star_idx+",
        # ç¦æ­¢ EXECUTE/SETTLE ç›´è¯»æŒ‡æ ‡
        '.get("diff")', '.get("rate")', '.get("mean")', '["diff"]', '["rate"]', '["mean"]',

        a + sp + " b_idx", a + "+b_idx",
        lbr + a + sp, lbr + a + "+",

        # ç»“ç®—/æ‰§è¡Œé˜¶æ®µå°†æ¸¸æ ‡æŒ‡å‘ç»“ç®—è¡Œå¹¶å›è¯»æŒ‡æ ‡ï¼ˆç¦æ­¢ï¼‰
        "settle_idx", "last_bet_idx",
        "records[settle_idx]", "records[last_bet_idx]",
        "records [settle_idx]", "records [last_bet_idx]",

        # ç»•è·¯å†™æ³•ï¼ˆç¦æ­¢ï¼‰ï¼šåŒºé—´è¯»å–/åŒºé—´å¾ªç¯/è¡¨æ ¼å¼ç´¢å¼•
        lbr + a + ":", lbr + a + " :", "records[ " + a + ":", "records[ " + a + " :",
        lbr + a + "+1:", lbr + a + sp + " 1:", lbr + a + "+1:",
        "range(" + a, "range(" + a + sp, "range( " + a,
        "iloc[",
    ]

    hit = [s for s in forbidden if s in audit_src]

    if hit:
        print("âŒâŒâŒ ä¸é€šè¿‡: æ‰§è¡Œ/ç»“ç®—æ®µæ£€æµ‹åˆ°ç¦æ­¢ç‰‡æ®µ:", ",".join(hit))
        lines = audit_src.splitlines()
        shown = 0
        for i, line in enumerate(lines, 1):
            if any(h in line for h in hit):
                print(f"  HIT|Line {i}|{line.strip()}")
                shown += 1
                if shown >= 6:
                    break
        if not SILENT_MODE:
            print("=== å®‰å…¨è‡ªæ£€å®Œæˆ ===")
        raise RuntimeError("æ‰§è¡Œ/ç»“ç®—æ®µå­˜åœ¨ç¦æ­¢ç‰‡æ®µ")

    print("âœ… å®‰å…¨è‡ªæ£€é€šè¿‡ï¼šæ‰§è¡Œ/ç»“ç®—æ®µæœªæ£€æµ‹åˆ°ç¦æ­¢ç‰‡æ®µã€‚")
    if not SILENT_MODE:
        print("=== å®‰å…¨è‡ªæ£€å®Œæˆ ===")
def _audit_structure_slot_integrity() -> None:
    """
    ç»“æ„æ’æ§½å®Œæ•´æ€§è‡ªæ£€ï¼ˆå¼€å‘æœŸé˜²è¯¯ä¼¤ç‰ˆæœ¬ï¼‰ï¼š

    1) åªä»¥ã€Œè¦†ç›–é”šç‚¹001ã€åˆ¤å®šç»“æ„æ’æ§½è¾¹ç•Œï¼ˆé¿å…è¯´æ˜æ–‡å­—/æ³¨é‡Šè¯¯åˆ¤ï¼‰ï¼š
       - # ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_BEGIN
       - # ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_END

    2) æ’æ§½å†…éƒ¨å¿…é¡»ä¸”åªèƒ½åŒ…å«ï¼š
       - 1 ä¸ª scan_structure å®šä¹‰
       - 1 æ¡ STRUCT_CONFIG_TEXT å¸¸é‡

    3) è¦†ç›–åŒºç¦æ­¢å‡ºç°ä»»ä½•æ‰«æ/é—¨ç¦é€»è¾‘ç—•è¿¹ï¼ˆç¡¬å®¡è®¡ï¼‰ï¼š
       - continue / for / while / BOOT_FILTER / seen_all / range(
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            src = f.read()
    except Exception as e:
        raise RuntimeError(f"âŒ æ— æ³•è¯»å–æºç ç”¨äºç»“æ„æ’æ§½è‡ªæ£€ï¼š{e}")

    lines = src.splitlines()

    ANCHOR001_BEGIN = "ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_" "BEGIN"
    ANCHOR001_END   = "ğŸ€è¦†ç›–é”šç‚¹001_ç»“æ„æ’æ§½_" "END"
    begin_pat = r"^[ \t]*#\s*" + re.escape(ANCHOR001_BEGIN) + r".*$"
    end_pat   = r"^[ \t]*#\s*" + re.escape(ANCHOR001_END)   + r".*$"

    begin_ms = [i for i, line in enumerate(lines) if re.match(begin_pat, line)]
    end_ms   = [i for i, line in enumerate(lines) if re.match(end_pat, line)]

    if len(begin_ms) != 1 or len(end_ms) != 1:
        raise RuntimeError(
            "âŒ ç»“æ„æ’æ§½é”šç‚¹è¡Œå¿…é¡»ä¸”åªèƒ½å„å‡ºç° 1 æ¬¡ï¼š"
            f"BEGIN={len(begin_ms)}({begin_ms}) END={len(end_ms)}({end_ms})"
        )
    begin_line = begin_ms[0]
    end_line = end_ms[0]
    if end_line <= begin_line:
        raise RuntimeError("âŒ ç»“æ„æ’æ§½é”šç‚¹é¡ºåºé”™è¯¯ï¼šEND åœ¨ BEGIN ä¹‹å‰")

    slot_lines = lines[begin_line:end_line]
    slot_text = "\n".join(slot_lines)

    scan_hits = re.findall(r"^\s*def\s+scan_structure\s*\(", slot_text, flags=re.MULTILINE)
    cfg_hits  = re.findall(r"^\s*STRUCT_CONFIG_TEXT\s*=", slot_text, flags=re.MULTILINE)

    if len(scan_hits) != 1 or len(cfg_hits) != 1:
        raise RuntimeError(
            "âŒ ç»“æ„æ’æ§½å†…å®¹å¼‚å¸¸ï¼š"
            f"scan_structure={len(scan_hits)} STRUCT_CONFIG_TEXT={len(cfg_hits)}"
            f" | slot_lines={begin_line+1}..{end_line}"
        )

    # è¦†ç›–åŒºç¡¬å®¡è®¡ï¼šç¦æ­¢æ‰«æ/é—¨ç¦é€»è¾‘ç—•è¿¹
    forbid = ["continue", " for ", " while ", "BOOT_FILTER", "seen_all", "range("]
    hit = [s for s in forbid if s in slot_text]
    if hit:
        raise RuntimeError("âŒ è¦†ç›–åŒºå‡ºç°ç¦æ­¢é€»è¾‘ç‰‡æ®µï¼š" + ",".join(hit))

    # è¿½åŠ ï¼šè¦†ç›–é”šç‚¹002ï¼ˆæŠ¥å‘Šæ±‡æ€»ï¼‰å”¯ä¸€æ€§å®¡è®¡ï¼ˆå…¨æ–‡ä»¶ç¡¬è¦æ±‚ï¼‰
    ANCHOR002_BEGIN = "ğŸ€è¦†ç›–é”šç‚¹002_æŠ¥å‘Šæ±‡æ€»_" "BEGIN"
    ANCHOR002_END   = "ğŸ€è¦†ç›–é”šç‚¹002_æŠ¥å‘Šæ±‡æ€»_" "END"
    begin_pat2 = r"^[ \t]*#\s*" + re.escape(ANCHOR002_BEGIN) + r".*$"
    end_pat2   = r"^[ \t]*#\s*" + re.escape(ANCHOR002_END)   + r".*$"
    begin_ms2 = [i for i, line in enumerate(lines) if re.match(begin_pat2, line)]
    end_ms2   = [i for i, line in enumerate(lines) if re.match(end_pat2, line)]
    if len(begin_ms2) != 1 or len(end_ms2) != 1:
        raise RuntimeError(
            "âŒ æŠ¥å‘Šæ±‡æ€»é”šç‚¹è¡Œå¿…é¡»ä¸”åªèƒ½å„å‡ºç° 1 æ¬¡ï¼š"
            f"BEGIN={len(begin_ms2)}({begin_ms2}) END={len(end_ms2)}({end_ms2})"
        )
def _update_run(run_side, run_len, r):
    # çŠ¶æ€ T ä½ç§»é›¶åå·®ï¼šrun_side/run_len ä¸å˜  # [cite: 13]
    if r == "T":
        return run_side, run_len  # [cite: 13]
    if not _is_bp(r):
        return run_side, run_len  # [cite: 13]
    if run_side is None or r != run_side:
        return r, 1  # [cite: 13]
    return run_side, run_len + 1  # [cite: 13]

def _compute_max_runs_first9(records):
    # åªçœ‹å‰ 9 å£ï¼ˆseen_all=1..9ï¼ŒçŠ¶æ€ B/P/T éƒ½ç®—ä½ç§»å£æ•°ï¼‰  # [cite: 14]
    seen_all = 0  # [cite: 14]
    run_side = None  # [cite: 14]
    run_len = 0  # [cite: 14]
    max_run = {"B": 0, "P": 0}  # [cite: 14]
    for rec in records:
        seen_all += 1  # [cite: 14]
        run_side, run_len = _update_run(run_side, run_len, rec["r"])  # [cite: 14]
        if run_side in ("B","P"):
            if run_len > max_run[run_side]:
                max_run[run_side] = run_len  # [cite: 14]
        if seen_all >= 9:
            break  # [cite: 14]
    return max_run["B"], max_run["P"], seen_all  # [cite: 14]

def _self_stop_tracker_init():
    return {"run_side": None, "run_len": 0, "seen_b3": False, "seen_p3": False}  # [cite: 14]

def _self_stop_tracker_step(st, r):
    st["run_side"], st["run_len"] = _update_run(st["run_side"], st["run_len"], r)  # [cite: 15]
    if st["run_side"] == "B" and st["run_len"] >= 3:
        st["seen_b3"] = True  # [cite: 15]
    if st["run_side"] == "P" and st["run_len"] >= 3:
        st["seen_p3"] = True  # [cite: 15]
    return st  # [cite: 15]

def _should_self_stop(st):
    # ä¸¤è¾¹éƒ½æ›¾å‡ºç°æ®µé•¿â‰¥3 â†’ è‡ªåœ  # [cite: 15]
    return st["seen_b3"] and st["seen_p3"]  # [cite: 15]
from collections import defaultdict

# ==========================
# è¿æ®µç»Ÿè®¡ï¼ˆåŒæŒ‡æ ‡ç›¸é‚»æ€ï½œé”æ­»ï¼‰  # [cite: 15]
# ==========================
# ç›®æ ‡ï¼šåœ¨â€œå•æŒ‡æ ‡æ— è§„å¾‹â€çš„å‰æä¸‹ï¼Œåªè§‚å¯Ÿâ€œåŒæŒ‡æ ‡ç›¸é‚»æ€â€çš„åˆ†å¸ƒï¼Œç”¨äº STOP å€™é€‰ç­›é€‰ï¼›  # [cite: 15]
# çº¦æŸï¼šè¿ç»­ç»Ÿè®¡åªèƒ½åŸºäºâ€œæŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨â€åšäº‹åæ±‡æ€»ï¼›å†³ç­–é€»è¾‘ä»å¿…é¡»æ»¡è¶³â€œå†³ç­–å£åŸºå‡†ï¼ˆé›¶æœªæ¥ï¼‰â€ã€‚  # [cite: 15]
#
# å¿«ç…§å£å¾„ï¼ˆé”æ­»ï½œå£å¾„ Bï¼‰ï¼šæ¯æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘è®°å½•ä¸€æ¬¡å¿«ç…§ï¼ˆå«çŠ¶æ€ T åçš„é‡å¤æŠ•æ”¾ï¼‰ï¼Œå¿«ç…§æ¥è‡ªâ€œæŠ•æ”¾ç‚¹å½“è¡Œâ€åŸå§‹æŒ‡æ ‡ã€‚  # [cite: 15]
# è¿ç»­é•¿åº¦ï¼ˆé”æ­»ï¼‰ï¼šç›¸é‚»æ€ï¼ˆä¸Šä¸€æ¬¡â†’è¿™ä¸€æ¬¡ï¼‰ã€‚  # [cite: 15]
#
# å¿«ç…§å­—æ®µï¼ˆå»ºè®®ç­–ç•¥è¿”å› snapshots åˆ—è¡¨ï¼Œæ¯æ¡è‡³å°‘åŒ…å«ï¼‰ï¼š  # [cite: 15]
#   - bet_n: ç¬¬å‡ æ¬¡å®é™…æŠ•æ”¾ï¼ˆä» 1 å¼€å§‹ï¼›å«çŠ¶æ€ T é‡å¤æŠ•æ”¾ä¼šå¯¼è‡´ bet_n > 4ï¼‰  # [cite: 15]
#   - diff: ç‚¹å·®ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - rate: å˜åŒ–ç‡ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - mean: å‡å·®ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - trade_bust: æœ¬ç¬”äº¤æ˜“æœ€ç»ˆæ˜¯å¦é˜ˆå€¼å‡»ç©¿ï¼ˆ0/1ï¼Œç”¨äºè®¡ç®—â€œåç»­é˜ˆå€¼å‡»ç©¿ç‡â€ï¼‰  # [cite: 15]
#
# è¾“å‡ºï¼ˆé”æ­»ï½œAI å‹å¥½ï¼‰ï¼š  # [cite: 15]
#   A) (|ç‚¹å·®|æ¡¶, rate ç›‘æµ‹æ¡¶) çš„ç›¸é‚»æ€åˆ‡æ¢æ¦œï¼šS_{t-1}â†’S_tï¼ˆTopKï¼‰  # [cite: 15]
#   B) (|ç‚¹å·®|æ¡¶, mean æ¡¶) çš„ç›¸é‚»æ€åˆ‡æ¢æ¦œï¼šS_{t-1}â†’S_tï¼ˆTopKï¼‰  # [cite: 15]
#   æ¯æ¡åˆ‡æ¢è¾“å‡ºï¼šå‡ºç°æ¬¡æ•°ã€åç»­é˜ˆå€¼å‡»ç©¿æ•°ã€åç»­é˜ˆå€¼å‡»ç©¿ç‡ï¼ˆexhaustion / å‡ºç°æ¬¡æ•°ï¼‰  # [cite: 15]
#   é»˜è®¤åªè¾“å‡ºâ€œæ ·æœ¬é‡ >= é˜ˆå€¼â€çš„åˆ‡æ¢ï¼Œé¿å…å™ªå£°ã€‚  # [cite: 15]
CONT_STATS_ENABLE = 0  # [cite: 15]
CONT_MAX_BET_N = 12  # [cite: 15]
CONT_MIN_SAMPLES = 500  # [cite: 15]
CONT_TOPK = 20  # [cite: 15]


def _abs_diff_bucket(diff: int) -> str:
    # ç»å¯¹å€¼ç‚¹å·®æ¡¶ï¼š0,1,2,...,9,9+ï¼ˆ9+ è¡¨ç¤º >=10ï¼›9 ä»…è¡¨ç¤º ==9ï¼‰
    absd = abs(diff)
    if absd >= 10:
        return "9+"
    return str(absd)



def _safe_int(v: Any):
    """å®‰å…¨è½¬ intï¼šNone/ç©ºä¸²/'None'/'nan' ç­‰è§†ä¸ºæ— æ•ˆï¼›å¤±è´¥è¿”å› Noneã€‚"""
    if v is None:
        return None
    if isinstance(v, bool):
        return int(v)
    if isinstance(v, int):
        return v
    try:
        s = str(v).strip()
    except Exception:
        return None
    if s == "":
        return None
    sl = s.lower()
    if sl in ("none", "nan", "null"):
        return None
    try:
        # å…¼å®¹ '3.0' è¿™ç§è¾“å…¥
        return int(float(s))
    except Exception:
        return None

def _l1_abs_diff_bucket(diff_raw: Any) -> str:
    """ç‚¹å·®æ¡¶ï¼š0..9 + 9+ï¼ˆå…± 10+1 ä¸ªä½ç½®ï¼‰ã€‚"""
    d = _safe_int(diff_raw)
    if d is None:
        return "æ— æ•ˆ"
    ad = abs(int(d))
    if ad >= 10:
        return "9+"
    return str(ad)

# ===== å†»ç»“åŒºï¼šå˜åŒ–ç‡åˆ†æ¡¶é˜ˆå€¼ï¼ˆåªè¯»å­—æ®µï¼›ä»…ç”¨äºåˆ†æ¡¶æ˜ å°„ï½œé”æ­»ï¼‰=====
# L1ï¼šå‰å°/å‰å¤§/æå€¼/æ— æ•ˆï¼ˆé”æ­»ï¼‰
L1_RATE_TH_SMALL = -2.0   # r > -2  -> å‰å°
L1_RATE_TH_BIG   = -3.0   # -3 < r <= -2 -> å‰å¤§ï¼›r <= -3 -> æå€¼
# L2/L3/L4ï¼šå‡é€Ÿ/åŠ é€Ÿ/æå€¼/æ— æ•ˆï¼ˆé”æ­»ï¼‰
R_RATE_TH_SLOW = 0.0      # r < 0 -> å‡é€Ÿ
R_RATE_TH_FAST = 2.0      # 0 <= r < 2 -> åŠ é€Ÿï¼›r >= 2 -> æå€¼

def _rate_monitor_bucket(rate):
    """L2/L3/L4 å››æ¡¶ï¼šå‡é€Ÿ/åŠ é€Ÿ/æå€¼/æ— æ•ˆï¼ˆé”æ­»ï¼‰ã€‚"""
    if rate is None:
        return "æ— æ•ˆ"
    try:
        r = float(rate)
    except Exception:
        return "æ— æ•ˆ"

    # å¼ºåŒ–ï¼š0 å¿…é¡»å½’â€œåŠ é€Ÿâ€ï¼ˆä¸æ˜¯æ— æ•ˆï¼‰
    if r == 0.0:
        return "åŠ é€Ÿ"
    if r < R_RATE_TH_SLOW:
        return "å‡é€Ÿ"
    if r < R_RATE_TH_FAST:
        return "åŠ é€Ÿ"
    return "æå€¼"

def _l1_rate_bucket(rate):
    """L1 å››æ¡¶ï¼šå‰å°/å‰å¤§/æå€¼/æ— æ•ˆï¼ˆé”æ­»ï¼‰ã€‚"""
    if rate is None:
        return "æ— æ•ˆ"
    try:
        r = float(rate)
    except Exception:
        return "æ— æ•ˆ"

    # å¼ºåŒ–ï¼š0 å¿…é¡»å½’â€œå‰å°â€ï¼ˆä¸æ˜¯æ— æ•ˆï¼‰
    if r == 0.0:
        return "å‰å°"
    if r > L1_RATE_TH_SMALL:
        return "å‰å°"
    if L1_RATE_TH_BIG < r <= L1_RATE_TH_SMALL:
        return "å‰å¤§"
    return "æå€¼"

def _rate_mode_from_exhaustion(exh):
    """ç¡¬é—¸é—¨ï¼šäºŒä½ç  -> æ¨¡å¼ï¼ˆä¸­æ–‡é”æ­»ï¼‰ã€‚
    è§„åˆ™ï¼š
      - åªè¦åŒ…å« 'T'ï¼šä¸€å¾‹åˆ¤ä¸ºâ€œæ— æ•ˆâ€ï¼ˆä¸åšè¿‡æ»¤ï¼‰
      - ä»…å½“æ°å¥½ä¸ºä¸¤ä½ä¸”éƒ½åœ¨ {B,P}ï¼š
          * BB / PP â†’ åŠ å‡é€Ÿ
          * BP / PB â†’ å‰å¤§å°
      - å…¶ä»–ï¼šæ— æ•ˆ
    """
    if exh is None:
        return "æ— æ•ˆ"
    s = str(exh).strip().upper()
    if not s:
        return "æ— æ•ˆ"
    if "T" in s:
        return "æ— æ•ˆ"
    if s in ("BB", "PP"):
        return "åŠ å‡é€Ÿ"
    if s in ("BP", "PB"):
        return "å‰å¤§å°"
    return "æ— æ•ˆ"

def _rate_quartet(exh_pair, rate_value):
    """å”¯ä¸€å…¥å£ï¼šè¿”å› (mode, l1_bucket, r_bucket, active_bucket)"""
    mode = _rate_mode_from_exhaustion(exh_pair)
    # ä¸¤å¥—æ¡¶éƒ½ç®—å‡ºæ¥ï¼ˆå†™å¿«ç…§ä¸€æ¬¡æ€§ç»‘å®šï¼‰ï¼Œé¿å…ä¸‹æ¸¸é‡å¤å®ç°
    l1b = _l1_rate_bucket(rate_value)
    rb = _rate_monitor_bucket(rate_value)

    if mode == "å‰å¤§å°":
        active = l1b
    elif mode == "åŠ å‡é€Ÿ":
        active = rb
    else:
        active = "æ— æ•ˆ"

    # 0å€¼å¼ºåŒ–ï¼šè‹¥ rate_value æ˜¯æœ‰æ•ˆ 0ï¼Œå¿…é¡»è½åœ¨é¢„æœŸæ¡¶
    try:
        if rate_value is not None and float(rate_value) == 0.0:
            if l1b != "å‰å°":
                raise RuntimeError("RATE_ZERO_L1_BUCKET_MISMATCH")
            if rb != "åŠ é€Ÿ":
                raise RuntimeError("RATE_ZERO_R_BUCKET_MISMATCH")
    except Exception:
        # è‹¥è¿™é‡Œå¼‚å¸¸ï¼Œè¯´æ˜ä¸Šæ¸¸æŠŠç¼ºå¤±ç¡¬è½¬0 æˆ– bucket å®ç°è¢«æ±¡æŸ“
        raise

    return mode, l1b, rb, active
def _l1_mean_bucket(diff, mean):
    # L1 å‡å·®åˆ†æ¡¶é”æ­»ä¸º 4 æ¡¶ï¼š|å‡å·®|<3 / |å‡å·®|>=3 / mean=0 / æ— æ•ˆ
    # åªè¯» meanï¼ˆä¸é‡ç®—/ä¸ä¿®æ­£ï¼‰ï¼Œdiff å‚æ•°ä¿ç•™ä½†ä¸å‚ä¸åˆ†æ¡¶ã€‚
    bucket, invalid = _mean_bucket(mean)
    return bucket, invalid


def _mean_bucket(mean):
    """å‡å·®åˆ†æ¡¶ï¼ˆå†»ç»“åŒºå”¯ä¸€å…¥å£ï½œåªè¯»è¾“å…¥ï¼Œä¸é‡ç®—åŸå§‹æŒ‡æ ‡ï¼‰
    è¿”å›: (bucket, invalid_flag)
      - æ— æ•ˆ=ç©º/None/nan/è§£æå¤±è´¥ -> ("æ— æ•ˆ", True)
      - mean == 0 -> ("mean=0", False)
      - |mean| >= 3 -> ("|å‡å·®|>=3", False)
      - |mean| < 3 -> ("|å‡å·®|<3", False)
    """
    m = safe_float(mean, default=None, kind="MEAN")
    if m is None:
        return "æ— æ•ˆ", True
    if m == 0:
        return "mean=0", False
    return ("|å‡å·®|>=3" if abs(m) >= 3 else "|å‡å·®|<3"), False


# ==================== å†»ç»“åŒºï½œæŠ•æ”¾é“¾è·¯ï¼ˆL1-L4ï¼‰å”¯ä¸€å…¥å£ BEGIN ====================
# ç›®çš„ï¼ˆé”æ­»ï¼‰ï¼š
# - L1/L2/L3/L4 çš„â€œåˆ†å±‚å­—æ®µ + è¯»é”™å³é€€â€ï¼›
# - æœªå¯ç”¨é˜¶æ®µï¼šä¸å†™å¿«ç…§ã€ä¸å…¥è§„åˆ™æ—æ ·æœ¬æ± ï¼›ä»»ä½•è¯»å–=è¶Šæƒé€€å‡ºï¼›
# - æ•°æ®ç¼ºå¤±ï¼ˆrate/mean ç©º/None/nan/è§£æå¤±è´¥ï¼‰ï¼šè¿›å…¥â€œæ— æ•ˆæ¡¶â€ç»§ç»­è·‘ï¼Œå¹¶åœ¨æŠ¥å‘Šè¾“å‡º TopN åŸå§‹å­—ç¬¦ä¸²æ ·ä¾‹ã€‚

_STAGE_LIST = ("L1", "L2", "L3", "L4")

def _stage_to_bet_n(stage: str) -> int:
    m = {"L1": 1, "L2": 2, "L3": 3, "L4": 4}
    if stage not in m:
        raise ValueError(f"bad stage={stage}")
    return m[stage]

_ALLOWED_SNAP_SOURCE = ("STAR_ONLY", "L1", "L2", "L3", "L4")

# æŠ¥å‘Šå‚æ•°ï¼ˆå†»ç»“åŒºåªè¯»è¿™ä¸€å¤„ï¼›å¤–éƒ¨ç»“æ„æ’æ§½ä¸å¾—ä¼ªé€ ï¼‰
# - ç›®æ ‡å±‚å”¯ä¸€æ¥æºï¼šTARGET_STAGEï¼ˆç¼ºçœæŒ‰ L4ï¼‰
# - åˆ†å±‚å¼€å…³ï¼šENABLE_L1..ENABLE_L4
TARGET_STAGE = "L4"
ENABLE_L1 = 0
ENABLE_L2 = 0
ENABLE_L3 = 0
ENABLE_L4 = 1

# è§„åˆ™æ—æ‰«æå¼€å…³ï¼ˆæŠ¥å‘Šå‚æ•°ï¼‰
RULESCAN_ON = 1

# Î”è‡ªè¯å®¡è®¡å¼€å…³ï¼ˆå†»ç»“åŒºï¼‰
DELTA_AUDIT_ON = 1         # 1=æ‰“å°[L4_Î”è‡ªè¯]ä¸ä½œåºŸåˆ¤å®šï¼›0=å®Œå…¨å…³é—­
DELTA_AUDIT_ENFORCE = 1    # 1=ä½œåºŸå³é€€å‡º(é€€å‡ºç é0)ï¼›0=åªæ‰“å°ä½œåºŸä½†ç»§ç»­è·‘ï¼ˆè§„åˆ™æ—æ¦œå•è·³è¿‡ï¼‰
RULESCAN_MIN_CNT = 1000
RULESCAN_TOPN = 5

class _UNSET_T:
    pass

_UNSET = _UNSET_T()

@dataclass(frozen=True)
class StageSnap:
    # æœ€å°é›†ï¼ˆé”æ­»ï¼‰
    stage: str
    bet_n: int
    rule_id: str
    exhaustion: str  # é”ä¸º exh_pairï¼ˆå¦‚ "BB"/"PP"/"BP"/"PB"ï¼‰ï¼Œæ— æ•ˆåˆ™ä¸º "æ— æ•ˆ"
    diff_raw: int
    rate_raw: float | None
    mean_raw: float | None
    diff_bucket: str
    mean_bucket: str
    snap_source: str

    snap_seq: int  # æ¯é´ä»1é€’å¢ï¼Œä»…æ’åº/å®¡è®¡
    profit_to_here: float = 0.0  # æœ¬æ¬¡é˜¶æ®µå¿«ç…§å†™å…¥æ—¶åˆ»ï¼šå·²çœŸå®ç»“ç®—å‡ºæ¥çš„å‡€å€¼ï¼ˆç”¨äºåäº‹å®Î”ï¼‰

    # åˆ†å±‚å­—æ®µï¼ˆç‰©ç†éš”ç¦»ï¼šè¯»é”™å³é€€ï¼‰
    rate_bucket_L1: str | _UNSET_T = _UNSET
    rate_bucket_L2: str | _UNSET_T = _UNSET
    rate_bucket_L3: str | _UNSET_T = _UNSET
    rate_bucket_L4: str | _UNSET_T = _UNSET

    # ä»…ç”¨äºâ€œç¼ºå¤±æ ·ä¾‹ TopNâ€è‡ªè¯
    _rate_raw_text: str = ""
    _mean_raw_text: str = ""

def _stage_enabled(stage: str) -> bool:
    if stage == "L1":
        return bool(ENABLE_L1)
    if stage == "L2":
        return bool(ENABLE_L2)
    if stage == "L3":
        return bool(ENABLE_L3)
    if stage == "L4":
        return bool(ENABLE_L4)
    return False

def _guard_stage(stage: str, code: str, why: str, *, boot_id=None, idx=None, phase: str = "REPORT", rule_id: str = "0", evidence_extra: str = "") -> None:
    """å†»ç»“åŒºç¡¬æ‹¦æˆªï¼šé˜¶æ®µ/å¥‘çº¦/è¶Šæƒç±»é”™è¯¯å¿…é¡»é€€å‡ºã€‚"""
    evidence = f"boot_id={boot_id} idx={idx}"
    if evidence_extra:
        evidence = evidence + " " + str(evidence_extra)
    _raise_guard(code=code, rule_id=rule_id, phase=phase, msg=f"[é“¾è·¯]{why} | stage={stage}", evidence=evidence, exit_code=2)


def _guard_stage_read(snap: StageSnap, stage: str, field: str) -> str:
    if not _stage_enabled(stage):
        _guard_stage(stage, "STAGE_DISABLED_READ", f"æœªå¯ç”¨é˜¶æ®µè¢«è¯»å–ï¼š{field}")
    if snap.stage != stage:
        _guard_stage(stage, "STAGE_MISMATCH_READ", f"è¯»é”™é˜¶æ®µï¼šsnap.stage={snap.stage} ä½†è¯»å–={stage}.{field}")
    v = getattr(snap, field)
    if v is _UNSET:
        _guard_stage(stage, "STAGE_FIELD_FORBIDDEN", f"è¯»é”™åˆ†å±‚å­—æ®µï¼š{field}")
    return v

def _rate_bucket_for_stage(stage: str, rate) -> str:
    # L1ï¼šå‰å°/å‰å¤§/æå€¼/æ— æ•ˆï¼ˆé”æ­»ï¼‰
    # L2-L4ï¼šå‡é€Ÿ/åŠ é€Ÿ/æå€¼/æ— æ•ˆï¼ˆé”æ­»ï¼‰
    if stage == "L1":
        return _l1_rate_bucket(rate)
    return _rate_monitor_bucket(rate)

def _exhaustion_pair_for_stage(star: Snapshot) -> str:
    try:
        v = star.exh_pair
        if not v:
            return "æ— æ•ˆ"
        return str(v)
    except Exception:
        return "æ— æ•ˆ"

def _bind_raw_text_fields(star: Snapshot, rate_raw_text, mean_raw_text) -> None:
    try:
        star._rate_raw_text = "" if rate_raw_text is None else str(rate_raw_text)
    except Exception:
        star._rate_raw_text = "<?>"
    try:
        star._mean_raw_text = "" if mean_raw_text is None else str(mean_raw_text)
    except Exception:
        star._mean_raw_text = "<?>"

def _make_stage_snap_from_star(
    *,
    stage: str,
    star: Snapshot,
    rule_id: str,
    snap_source: str,
    boot_id: int,
    snap_seq: int,
) -> StageSnap:
    if stage not in _STAGE_LIST:
        _guard_stage(stage, "STAGE_INVALID", "éæ³•é˜¶æ®µå", boot_id=boot_id, idx=getattr(star, "idx", None))
    if snap_source not in _ALLOWED_SNAP_SOURCE:
        _guard_stage(stage, "SNAP_SOURCE_INVALID", f"snap_source éæ³•ï¼š{snap_source}", boot_id=boot_id, idx=getattr(star, "idx", None))
    if not _stage_enabled(stage):
        _guard_stage(stage, "STAGE_DISABLED_WRITE", "æœªå¯ç”¨é˜¶æ®µä»å†™å…¥å¿«ç…§", boot_id=boot_id, idx=getattr(star, "idx", None))

    diff = secure_read_metric(star, "diff", phase="REPORT", who="REPORT", idx=getattr(star, "idx", None), boot_id=boot_id, seen_all=getattr(star, "seen_all", None))
    rate = secure_read_metric(star, "rate", phase="REPORT", who="REPORT", idx=getattr(star, "idx", None), boot_id=boot_id, seen_all=getattr(star, "seen_all", None))
    mean = secure_read_metric(star, "mean", phase="REPORT", who="REPORT", idx=getattr(star, "idx", None), boot_id=boot_id, seen_all=getattr(star, "seen_all", None))

    diff_bucket = _l1_abs_diff_bucket(int(diff))
    if stage == "L1":
        mean_bucket, _ = _l1_mean_bucket(int(diff), mean)
    else:
        mean_bucket, _ = _mean_bucket(mean)
    exh_pair = _exhaustion_pair_for_stage(star)
    rb = _rate_bucket_for_stage(stage, rate)

    kwargs = {"rate_bucket_L1": _UNSET, "rate_bucket_L2": _UNSET, "rate_bucket_L3": _UNSET, "rate_bucket_L4": _UNSET}
    kwargs[f"rate_bucket_{stage}"] = rb

    return StageSnap(
            stage=stage,
            bet_n=_stage_to_bet_n(stage),
            rule_id=rule_id,
        exhaustion=exh_pair,
        diff_raw=int(diff),
        rate_raw=rate,
        mean_raw=mean,
        diff_bucket=diff_bucket,
        mean_bucket=mean_bucket,
        snap_source=snap_source,
        snap_seq=snap_seq,
        profit_to_here=profit_to_here,
        _rate_raw_text=getattr(star, "_rate_raw_text", ""),
        _mean_raw_text=getattr(star, "_mean_raw_text", ""),
        **kwargs,
    )



def _make_stage_snap_from_cache(
    *,
    stage: str,
    rule_id: str,
    rr: str,
    cache_row: dict,
    snap_source: str,
    snap_seq: int,
    profit_to_here: float,
) -> StageSnap:
    """é˜¶æ®µå¿«ç…§ï¼šåªå…è®¸ä»â€œä¸Šä¸€æ‰‹å·²ç»“ç®—ä¸”éTâ€çš„ç¼“å­˜è¡Œå–ä¸‰æŒ‡æ ‡ï¼ˆé›¶æœªæ¥ï¼‰ã€‚"""
    if stage not in _STAGE_LIST:
        raise RuntimeError(f"stage invalid: {stage}")

    # å…è®¸ç¼ºå¤±ï¼Œä½†å¿…é¡»è½å…¥æ— æ•ˆæ¡¶ï¼ˆç¦æ­¢ç¡¬è½¬0ï¼‰
    diff_v = _safe_int(cache_row.get("diff"))
    diff_bucket = _abs_diff_bucket(diff_v) if diff_v is not None else "æ— æ•ˆ"

    rate_v = cache_row.get("rate")  # float | None
    mean_v = cache_row.get("mean")  # float | None

    rate_bucket = _rate_bucket_for_stage(stage, rate_v)
    mean_bucket, _ = _mean_bucket(mean_v)
    # åŸå§‹æ–‡æœ¬ä»…ç”¨äº TopN è‡ªè¯
    rate_raw_text = str(cache_row.get("rate_raw") if cache_row.get("rate_raw") is not None else ("" if rate_v is None else rate_v))
    mean_raw_text = str(cache_row.get("mean_raw") if cache_row.get("mean_raw") is not None else ("" if mean_v is None else mean_v))

    kw_rate = {}
    if stage == "L1":
        kw_rate["rate_bucket_L1"] = rate_bucket
    elif stage == "L2":
        kw_rate["rate_bucket_L2"] = rate_bucket
    elif stage == "L3":
        kw_rate["rate_bucket_L3"] = rate_bucket
    elif stage == "L4":
        kw_rate["rate_bucket_L4"] = rate_bucket

    return StageSnap(
            stage=stage,
            bet_n=_stage_to_bet_n(stage),
            rule_id=rule_id,
        exhaustion=rr,  # é”æ­»ï¼šå½“æ¬¡ç»“ç®—ç»“æœ(B/P/T)
        diff_raw=int(diff_v or 0),
        rate_raw=rate_v,
        mean_raw=mean_v,
        diff_bucket=diff_bucket,
        mean_bucket=mean_bucket,
        snap_source=snap_source,
        snap_seq=snap_seq,
        profit_to_here=safe_float(profit_to_here, default=None, kind="GEN"),
        _rate_raw_text=rate_raw_text,
        _mean_raw_text=mean_raw_text,
        **kw_rate,
    )

def stage_rate_bucket(snap: StageSnap, stage: str) -> str:
    return _guard_stage_read(snap, stage, f"rate_bucket_{stage}")

# ==================== å†»ç»“åŒºï½œæŠ•æ”¾é“¾è·¯ï¼ˆL1-L4ï¼‰å”¯ä¸€å…¥å£ END ====================


def _init_cont_agg():
    return {
        "pair_rate": {},         # key: (bet_n, prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_mean": {},         # key: (bet_n, prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_rate_overall": {}, # key: (prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_mean_overall": {}, # key: (prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "max_bet_n_seen": 0,  # [cite: 21]
    }

def _agg_add(d, key, bust_flag):
    if key not in d:
        d[key] = [0, 0]  # [cite: 22]
    d[key][0] += 1  # [cite: 22]
    d[key][1] += int(1 if bust_flag else 0)  # [cite: 22]

def _cont_consume_snapshots(agg, snapshots):
    # snapshots: list of dicts with bet_n,diff,rate,mean,trade_exhaustion  # [cite: 23]
    if not snapshots:
        return  # [cite: 23]
    snaps = [x for x in snapshots if isinstance(x, dict) and "bet_n" in x]  # [cite: 23]
    snaps.sort(key=lambda x: int(x.get("bet_n", 0)))  # [cite: 23]
    if len(snaps) < 2:
        return  # [cite: 23]

    bust_flag = int(snaps[-1].get("trade_bust", 0))  # [cite: 23]
    for i in range(1, len(snaps)):
        a = snaps[i-1]  # [cite: 23]
        b = snaps[i]  # [cite: 23]
        try:
            bn = int(b.get("bet_n", 0))  # [cite: 23]
        except Exception:
            bn = 0  # [cite: 23]
        if bn > agg["max_bet_n_seen"]:
            agg["max_bet_n_seen"] = bn  # [cite: 23]

        prev_rate = (_abs_diff_bucket(a.get("diff", 0)), _rate_monitor_bucket(a.get("rate")))  # [cite: 24]
        curr_rate = (_abs_diff_bucket(b.get("diff", 0)), _rate_monitor_bucket(b.get("rate")))  # [cite: 24]
        prev_mean = (_abs_diff_bucket(a.get("diff", 0)), _mean_bucket(a.get("mean"))[0])  # [cite: 24]
        curr_mean = (_abs_diff_bucket(b.get("diff", 0)), _mean_bucket(b.get("mean"))[0])  # [cite: 24]

        _agg_add(agg["pair_rate"], (bn, prev_rate, curr_rate), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_mean"], (bn, prev_mean, curr_mean), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_rate_overall"], (prev_rate, curr_rate), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_mean_overall"], (prev_mean, curr_mean), bust_flag)  # [cite: 24]

def _print_top_transitions(title, d, min_samples, topk):
    rows = []  # [cite: 25]
    for k, (cnt, bust) in d.items():
        if cnt < min_samples:
            continue  # [cite: 25]
        br = bust / cnt if cnt else 0.0  # [cite: 25]
        rows.append((br, cnt, bust, k))  # [cite: 25]
    rows.sort(reverse=True, key=lambda x: (x[0], x[1]))  # [cite: 25]
    print(title)  # [cite: 25]
    if not rows:
        print("ï¼ˆæ— è¾“å‡ºï¼šæ ·æœ¬é‡ä¸è¶³ï¼‰")  # [cite: 25]
        return  # [cite: 25]
    for i, (br, cnt, bust, k) in enumerate(rows[:topk], 1):
        print(f"{i:02d}. {k} | æ¬¡æ•°={cnt} | é˜ˆå€¼å‡»ç©¿={bust} | é˜ˆå€¼å‡»ç©¿ç‡={br:.4f}")  # [cite: 26]


# ============================================================
# ç»Ÿä¸€ä»£ç æ¨¡æ¿ï¼ˆV4ï¼Œåºåˆ—é•¿åº¦å£å¾„ï½œä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“ï¼‰
# çº¦æŸï¼š
# 1) åªè¯»å–å½“å‰ç›®å½•ä¸‹æ‰€æœ‰ .csv
# 2) ä¸å†™æ­»ä»»ä½•ç»å¯¹è·¯å¾„
# 3) è‡ªåŠ¨è¯†åˆ«æ‰¹æ¬¡åˆ—/ç»“æœ/ç‚¹å·®/å˜åŒ–ç‡/å‡å·®
# 4) ç»“æœå¿…é¡»æ˜ å°„ä¸º B/P/T
# 5) ä¸¥æ ¼é›¶æœªæ¥ï¼šrun_strategy_on_boot å†…ä¸¥ç¦è®¿é—®æœªæ¥è¡Œ
# 6) â€œåç»§è¡Œâ€ç»Ÿä¸€å®šä¹‰ï¼šç´§éšæŠ•æ”¾ç‚¹çš„åç»§è¡Œï¼ˆä¸è·³è¿‡çŠ¶æ€ T ä½ç§»é›¶åå·®ï¼‰
# 7) å•è¾¹/åŒè¾¹ï¼šå‰ 9 å£åˆ†ç±»ï¼›å•è¾¹å¼±ç´¯è®¡ >=3 è½¬åŒè¾¹ï¼›äº¤æ˜“æ¬¡æ•°é™åˆ¶è§æ¨¡æ¿æ–‡æ¡£
#
# æ³¨æ„ï¼šæœªæ¥æ–°å¢/ä¿®æ”¹ç­–ç•¥ï¼Œåªæ”¹ run_strategy_on_boot(records) å†…éƒ¨é€»è¾‘
# ============================================================

# ============================================================
# ç»“æœæ˜ å°„è¡¨ï¼šå·²å®Œæˆ BPT å…¨é˜¶è„±æ•ï¼Œç‰©ç†åŒ¹é…å®éªŒå®¤æ ‡å‡†åŒ– CSV
# ============================================================
MAP_RESULT = {"B": "B", "P": "P", "T": "T"}

def map_result(v):
    if v is None:
        return None
    s = str(v).strip()
    if s in MAP_RESULT:
        return MAP_RESULT[s]
    s2 = s.upper()
    if s2 in MAP_RESULT:
        return MAP_RESULT[s2]
    return None

# ------------------------------------------------------------
# å·¥å…·ï¼šå®‰å…¨è¯»å– float / intï¼ˆåªè¯»ï¼Œä¸è®¡ç®—ï¼‰
# ------------------------------------------------------------
RATE_MISSING_RAW_INPUT = 0
RATE_PARSE_FAIL_INPUT = 0
RATE_INVALID_RAW = 0   # rate_raw æ— æ•ˆ(None)è®¡æ•°
RATE_INVALID_BUCKET = 0  # å˜åŒ–ç‡åˆ†æ¡¶=æ— æ•ˆ è®¡æ•°
RATE_INVALID_ASSERT_ON = True  # æ— æ•ˆè®¡æ•°ä¸€è‡´æ€§æ–­è¨€å¼€å…³ï¼ˆå»ºè®®ä¿æŒTrueï¼‰
MEAN_MISSING_RAW_INPUT = 0
MEAN_PARSE_FAIL_INPUT = 0
def safe_float(v, default=None, *, kind="GEN"):
    """å®‰å…¨è§£æ floatï¼šæ°¸ä¸å´©æºƒï¼›ç¼ºå¤±/ä¸å¯è§£æ -> Noneï¼Œå¹¶è®¡æ•°ï¼ˆè¡¥ä¸Bï½œé”æ­»ï¼‰"""
    global RATE_MISSING_RAW_INPUT, RATE_PARSE_FAIL_INPUT, MEAN_MISSING_RAW_INPUT, MEAN_PARSE_FAIL_INPUT
    if _is_raw_missing(v):
        if kind == "RATE":
            RATE_MISSING_RAW_INPUT += 1
        elif kind == "MEAN":
            MEAN_MISSING_RAW_INPUT += 1
        return default
    try:
        return float(v)
    except Exception:
        if kind == "RATE":
            RATE_PARSE_FAIL_INPUT += 1
        elif kind == "MEAN":
            MEAN_PARSE_FAIL_INPUT += 1
        return default

def _is_raw_missing(x):
    if x is None:
        return True
    s = str(x).strip().lower()
    return (s == "" or s == "none" or s == "nan")

def safe_int(v, default=0):
    try:
        if v is None or v == "":
            return default
        return int(float(v))
    except Exception:
        return default

# ------------------------------------------------------------
# 1) æ•°æ®åŠ è½½ï¼ˆå›ºå®šï¼‰
# ------------------------------------------------------------
# ------------------------------------------------------------
# 0) åˆ—è¯†åˆ«ä¸æ˜ å°„ï¼ˆå›ºå®šï½œåªè¯»ï¼‰
# ------------------------------------------------------------
def _norm_key(k):
    return str(k).strip().lower() if k is not None else ""

def _first_hit(keys, candidates):
    key_norm = { _norm_key(k): k for k in keys }
    for c in candidates:
        cc = _norm_key(c)
        if cc in key_norm:
            return key_norm[cc]
    return None

def detect_columns(row0):
    """
    è¾“å…¥ï¼šrow0ï¼ˆDictReader è¯»åˆ°çš„ä¸€è¡Œ dictï¼‰
    è¾“å‡ºï¼šcol_batch, col_end, col_result, col_diff, col_rate, col_mean

    é´è¾¹ç•Œå£å¾„ï¼ˆé”æ­»ï¼‰ï¼š
    - æ‰¹æ¬¡/é´å·ï¼šSub-Batch
    - é´ç»“æŸï¼šé´ç»“æŸï¼ˆä»…æœ€åä¸€å£ä¸º1ï¼Œå…¶ä½™ä¸º0ï¼›è‹¥ç¼ºå¤±/ä¸ä¸€è‡´åˆ™æŠ¥é”™ï¼‰
    """
    keys = list(row0.keys()) if isinstance(row0, dict) else []

    # Sub-Batchï¼ˆé´å·/æ‰¹æ¬¡å·ï¼‰
    col_batch = _first_hit(keys, ["Sub-Batch", "sub-batch", "sub_batch", "subbatch", "æ‰¹æ¬¡", "æ‰¹æ¬¡å·", "batch", "Batch"])
    # é´ç»“æŸ
    col_end = _first_hit(keys, ["é´ç»“æŸ", "shoe_end", "shoe end", "end", "End", "ç»“æŸ", "boot_end", "BootEnd"])

    # ç»“æœåˆ—ï¼šå¸¸è§ Exhaustionï¼ˆå€¼ä¸ºB/P/Tï¼‰
    col_result = _first_hit(keys, ["Exhaustion", "exhaustion", "ç»“æœ", "result", "Result", "Outcome", "outcome"])

    # ç‚¹å·®/å˜åŒ–ç‡/å‡å·®ï¼ˆæ”¯æŒ 2/M3ï¼‰
    col_diff = _first_hit(keys, ["ç‚¹å·®", "diff", "Diff", "spread", "Spread", "delta", "Delta"])
    col_rate = _first_hit(keys, ["å˜åŒ–ç‡", "rate", "Rate", "roc", "ROC", "r", "R", "2"])
    col_mean = _first_hit(keys, ["å‡å·®", "mean", "Mean", "avg", "Avg", "average", "Average", "M3", "m3"])

    return col_batch, col_end, col_result, col_diff, col_rate, col_mean



# ==========================
# å…³é”®å‡½æ•°æºç å“ˆå¸Œï¼ˆsha256ï½œé”æ­»ï¼‰
# ==========================
def _print_source_hashes():
    """
    æ‰“å°å…³é”®å‡½æ•°æºç  sha256ï¼ˆé”æ­»ï¼‰ï¼š
    - ä»»æ„å‡½æ•°ç¼ºå¤±/æºç ä¸å¯å¾—/è¢«åŒ…è£¹/è¿è¡Œæ€æ›¿æ¢é£é™©ï¼šç›´æ¥ raise
    - æºç ä¸­å‡ºç° exec/eval/compile ç­‰é«˜å±å­—æ ·ï¼šç›´æ¥ raise
    """
    computed = {}
    global _SOURCE_HASHES_PRINTED
    targets = [
        "secure_read_metric",
        "secure_write_star_snapshot",
        "write_star_snapshot",
        "phase_transition",
        "advance_one_row",
        "run_strategy_on_boot",
        "load_all_boots",
"_audit_forbid_idx_offset",
        "_audit_structure_slot_integrity",
    ]

    _audit_log("ã€SOURCE_HASHESã€‘")
    for name in targets:
        fn = globals().get(name)
        if not callable(fn):
            raise RuntimeError(f"SELF_AUDIT_FAIL: MISSING_FUNC:{name}")

        code = getattr(fn, "__code__", None)
        if code is None:
            raise RuntimeError(f"SELF_AUDIT_FAIL: NO_CODEOBJ:{name}")

        try:
            fn_file = os.path.abspath(code.co_filename)
            this_file = os.path.abspath(__file__)
            if fn_file != this_file:
                raise RuntimeError(f"SELF_AUDIT_FAIL: FUNC_FILE_MISMATCH:{name}:{fn_file}")
        except Exception as e:
            raise RuntimeError(f"SELF_AUDIT_FAIL: FUNC_FILE_CHECK_ERROR:{name}:{e}")

        try:
            s = inspect.getsource(fn)
        except Exception as e:
            raise RuntimeError(f"SELF_AUDIT_FAIL: GETSOURCE_FAIL:{name}:{e}")

        # é«˜å±å…³é”®å­—ï¼ˆç¦æ­¢ï¼‰
        bad_tokens = ["exec(", "eval(", "compile(", "types.FunctionType", "__import__(", "importlib"]
        for t in bad_tokens:
            if t in s:
                raise RuntimeError(f"SELF_AUDIT_FAIL: BAD_TOKEN:{name}:{t}")

        h = hashlib.sha256(s.encode("utf-8")).hexdigest()
        computed[name] = h
        loc = len(s.splitlines())
        _audit_log(f"{name} : {h} : loc={loc}")
    # åŸºåº•æŒ‡çº¹ç»‘å®šï¼šå¯¹ç…§ EXPECTED_SOURCE_HASHESï¼ˆé”æ­»ï¼‰
    if EXPECTED_SOURCE_HASHES:
        mism = []
        for k, exp in EXPECTED_SOURCE_HASHES.items():
            got = computed.get(k)
            if got is None or got != exp:
                mism.append((k, exp, got))
        if mism:
            head = mism[0]
            msg = f"BASELINE_HASH_MISMATCH: {head[0]} exp={str(head[1])[:12]} got={str(head[2])[:12]}"
            if ENFORCE_BASELINE_HASH:
                raise RuntimeError(msg)
            elif WARN_BASELINE_HASH:
                _audit_log("WARN:" + msg)
            else:
                pass



    _SOURCE_HASHES_PRINTED = True


# ==========================
# æ­£å€¼è§¦å‘è‡ªå®¡é—¸é—¨ï¼ˆæ—¶é—´ç®¡ç†å±€ï½œé”æ­»ï¼‰
# ==========================
def SELF_AUDIT_GATE(final_metrics):
    """
    è§¦å‘æ¡ä»¶ï¼šTotal>0 æˆ– Avg>0ï¼ˆç”±å¼€å…³æ§åˆ¶ï¼‰
    å¤±è´¥ç­–ç•¥ï¼šä»»ä½•ä¸€æ¡ä¸æ»¡è¶³ï¼Œæ‰“å°æœ€å°è¯æ®å raise ç»ˆæ­¢ï¼ˆç¦æ­¢åé”™ï¼‰
    """
    def _fail(item_no, evidence):
        if not SILENT_MODE:
            print("=== æ­£å€¼è§¦å‘è‡ªå®¡ ===")
        print(f"Trigger: Total={final_metrics.get('total_profit')} | Avg={final_metrics.get('avg_profit')}")
        print("SELF_AUDIT=FAILâŒ")
        print(f"è§¦å‘çš„æœ€å°åˆæ ¼çº¿æ¡ç›®ç¼–å·={item_no}")
        print(f"å‘½ä¸­æœ€å°è¯æ®ç‰‡æ®µæ‘˜è¦ï¼š{evidence}")
        _raise_guard(code="SELF_AUDIT_FAIL", rule_id=item_no, phase="DONE", msg=f"SELF_AUDIT_FAIL item={item_no}", evidence=reason, exit_code=3)

    # B) äº¤ä»˜å¯å®¡è¾“å‡ºé”æ­»ï¼ˆé¦–å±è¦ç´ æ˜¯å¦å·²æ‰“å°ï¼‰
    if not _WATERMARK_PRINTED:
        _fail(1, "é¦–å±æ°´å°æœªæ‰“å°ï¼šWATERMARK_TEXT")
    if not _PROOF_BLOCK_PRINTED:
        _fail(2, "ç¼ºå¤±ã€å¼ºåˆ¶è‡ªè¯è¾“å‡ºã€‘å—ï¼šPROOF_BLOCK_PRINTED=0")
    if not _SELFTEST_PASSED:
        _fail(3, "ç¡¬æ³¨å…¥è‡ªæ£€æœªé€šè¿‡ï¼šSELFTEST_PASSED=0")
    if not _SOURCE_HASHES_PRINTED:
        _fail(4, "ç¼ºå¤±ã€SOURCE_HASHESã€‘å“ˆå¸Œæ¸…å•ï¼šSOURCE_HASHES_PRINTED=0")

    # C) é´çº§ç¦åŒºä¸‹æ³¨ï¼ˆå¿…é¡»ä¸º 0ï¼‰
    if final_metrics.get("bet_in_forbidden_seen", 0) != 0:
        _fail(5, f"BET_IN_FORBIDDEN_SEEN={final_metrics.get('bet_in_forbidden_seen')}")

    # A) è¡¨å¤´/è¯­ä¹‰é”æ­»ï¼ˆPP/BB æ’ç­‰å¼å¿…é¡» 0 å¤±é…ï¼‰
    if final_metrics.get("ppbb_mismatch", 0) != 0:
        _fail(6, f"PPBB_MISMATCH={final_metrics.get('ppbb_mismatch')} | EVIDENCE={final_metrics.get('ppbb_first_evidence')}")

    # C) æ ¸å¿ƒè®¡æ•°é—­ç¯
    entry = int(final_metrics.get("entry", 0) or 0)
    match = int(final_metrics.get("match", 0) or 0)
    mismatch = int(final_metrics.get("mismatch", 0) or 0)
    brk = int(final_metrics.get("break", 0) or 0)
    stop = int(final_metrics.get("stop", 0) or 0)
    zero = int(final_metrics.get("zero", 0) or 0)
    if entry != (match + mismatch + brk + stop + zero):
        _fail(7, f"æ’ç­‰å¼é—­ç¯å¤±è´¥ï¼šEntry={entry} != Match({match})+Mismatch({mismatch})+Break({brk})+Stop({stop})+Zero({zero})")

    # PASS
    if not SILENT_MODE:
        print("=== æ­£å€¼è§¦å‘è‡ªå®¡ ===")
    trig = []
    if final_metrics.get("trigger_total"): trig.append("Total>0")
    if final_metrics.get("trigger_avg"): trig.append("Avg>0")
    print("Trigger:", " or ".join(trig) if trig else "N/A")
    print("SELF_AUDIT=PASSâœ…")


def _print_header_mapping_once(row0, cols):
    """è¡¨å¤´è¯†åˆ«è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡ï¼›ç»ä¸å½±å“ä¸»æµç¨‹ã€‚"""
    global _HEADER_MAPPING_PRINTED
    if _HEADER_MAPPING_PRINTED:
        return
    _HEADER_MAPPING_PRINTED = True
    # é™é»˜æ¨¡å¼ï¼šä¸æ‰“å°ï¼Œä½†ä»å®Œæˆè¡¨å¤´è¯†åˆ«ä¸åç»­æµç¨‹
    if SILENT_MODE:
        return

    try:
        sample_row = row0 if isinstance(row0, dict) else {}

        col_batch, col_end, col_result, col_diff, col_rate, col_mean = cols

        print("==================================================")
        print("è¡¨å¤´è¯†åˆ«ï¼ˆè‡ªè¯ï½œä¸€æ¬¡æ€§æ‰“å°ï¼‰")
        print("æ‰¹æ¬¡(Sub-Batch) ->", col_batch)
        print("é´ç»“æŸ ->", col_end)
        print("ç»“æœ ->", col_result)
        print("ç‚¹å·® ->", col_diff)
        print("å˜åŒ–ç‡ ->", col_rate)
        print("å‡å·® ->", col_mean)

        # æ ·ä¾‹è¡Œï¼šåªå±•ç¤ºå‰12ä¸ªé”®
        d = {}
        show_keys = list(sample_row.keys())[:12]
        for k in show_keys:
            d[k] = sample_row.get(k)
        print("æ ·ä¾‹è¡Œ(åŸå§‹):", d)
        print("==================================================")
    except Exception as e:
        print("âš  è¡¨å¤´è‡ªè¯æ‰“å°å¤±è´¥ï¼ˆä¸å½±å“è¿è¡Œï¼‰:", str(e))


def boot_filter(records):
    # é´çº§å®Œæ•´æ€§ï¼šä¸å­˜åœ¨ä¸è¶³ 9 å£çš„é´ï¼›è‹¥å‘ç°åˆ™æŠ¥é”™å¹¶è¾“å‡ºè¯´æ˜ï¼ˆé”æ­»ï¼‰
    if records is None or len(records) < 9:
        # è¯æ®åªéœ€æ‰“å°ä¸€æ¬¡ï¼šæ–‡ä»¶|Sub-Batch|idxï¼ˆè‹¥ç¼ºå¤±åˆ™å°½é‡è¾“å‡ºå·²æœ‰ä¿¡æ¯ï¼‰
        f = None
        sb = None
        last_idx = None
        try:
            if records:
                f = records[0].get("file")
                sb = records[0].get("sub_batch")
                last_idx = records[-1].get("idx")
        except Exception:
            pass
        print("âŒâŒâŒ é´çº§å®Œæ•´æ€§å¤±è´¥ï¼šä¸è¶³9å£ | æ–‡ä»¶|Sub-Batch|idx =", f, sb, last_idx)
        raise RuntimeError("é´çº§å®Œæ•´æ€§å¤±è´¥ï¼šä¸è¶³9å£")
    return True



# ------------------------------------------------------------
# 3) å•æ‰¹æ¬¡ç­–ç•¥å…¥å£ï¼ˆåªå…è®¸æ”¹è¿™é‡Œï¼‰
# ------------------------------------------------------------
def run_strategy_on_boot(records):
    global BET_IN_FORBIDDEN_SEEN
    """å•é´æ‰§è¡Œï¼šç»“æ„->â­(DECISION)->æ‰§è¡Œæ¨è¿›(EXECUTE/SETTLE)ã€‚

    äºŒæ¬¡åŠ å›ºï¼ˆé”æ­»ï¼‰è¦ç‚¹ï¼š
      - æŒ‡æ ‡åªå…è®¸åœ¨ DECISION/STAR å†™å¿«ç…§ä¸è¯»å–ï¼ˆsecure_write_star_snapshot / secure_read_metricï¼‰
      - è¿›å…¥ EXECUTE/SETTLE åï¼Œrecords å…¨éƒ¨å»æŒ‡æ ‡åŒ–ï¼ˆguard_future_rows ä» 0 å¼€å§‹ï¼‰
      - ç¦æ­¢ star_idx + 1 ç­‰â€œidx+åç§»â€ç›´ç®—ï¼šåªèƒ½ç”¨ advance_one_row è‡ªç„¶æ¨è¿›
    """
    if not records or not STRUCT_SCAN:
        return None

    # ğŸ“Œ æŠ½æ ·å…œåº•ï¼šæ¯é´è‡³å°‘ç•™ä¸€æ¡å¯å®šä½ï¼ˆä¸å‚ä¸é€»è¾‘ï¼‰
    try:
        _sample_probe_fallback_update(
            file_name=records[0].get("file"),
            sub_batch=records[0].get("sub_batch"),
            idx=1,
        )
    except Exception:
        pass

    phase = "SCAN"
    decision_used = False

    # å†»ç»“ä¸‰æŒ‡æ ‡ç¼“å­˜ï¼ˆä»…ä¾›é˜¶æ®µå¿«ç…§/æŠ¥è¡¨ä½¿ç”¨ï¼›è¯»å–å¿…é¡»å— last_settled_nonT_idx é—¨ç¦ï¼Œç¦æ­¢æœªæ¥ï¼‰
    metrics_cache = []
    for _r in records:
        metrics_cache.append({
            'diff': _r.get('diff'),
            'rate': _r.get('rate'),
            'mean': _r.get('mean'),
            'rate_raw': _r.get('rate_raw'),
            'mean_raw': _r.get('mean_raw'),
        })

    # 1) ç»“æ„æ‰«æ
    st, star_idx, strong_side, struct_info = scan_structure(records)
    if st != "STRUCT_OK":
        return None

    entry = 1
    match = 0
    mismatch = 0
    stop = 0
    exhaustion = 0
    profit = 0.0

    # 2) DECISIONï¼šä»…â­è¡Œå†™å¿«ç…§
    phase = phase_transition(phase, "DECISION")
    decision_used = True
    star_row = records[star_idx]
    star_seen = star_row.get("seen_all")
    star_rr = star_row.get("r")
    star_boot_id = star_row.get("boot_id", star_row.get("shoe_id"))
    if star_boot_id is None:
        raise RuntimeError("BOOT_ID_MISSING_AT_STAR")

    # å˜åŒ–ç‡ç¡¬é—¸é—¨äºŒä½ç ï¼šæŠ•æ”¾ç‚¹ä¸Šä¸€æ¡ç»“æœ + æŠ•æ”¾ç‚¹è¿™ä¸€æ¡ç»“æœï¼ˆå«Tåˆ™æ— æ•ˆï¼‰
    try:
        prev_rr = records[star_idx - 1].get("r") if star_idx > 0 else None
    except Exception:
        prev_rr = None
    exh_pair = (str(prev_rr) + str(star_rr)) if (prev_rr in ("B", "P") and star_rr in ("B", "P")) else (str(prev_rr) + str(star_rr) if (prev_rr in ("B", "P", "T") and star_rr in ("B", "P", "T")) else None)

    star_snap = secure_write_star_snapshot(
        star_row, phase,
        seen_all=star_seen, rr=star_rr, boot_id=star_boot_id, star_idx=star_idx,
        star_snapshot_is_none=True, exh_pair=exh_pair
    )

    # ä»…ç”¨äºâ€œç¼ºå¤±æ ·ä¾‹ TopNâ€è‡ªè¯ï¼šç»‘å®šåŸå§‹å­—ç¬¦ä¸²ï¼ˆä¸å‚ä¸é€»è¾‘ï¼‰

    _bind_raw_text_fields(star_snap, star_row.get("rate_raw"), star_row.get("mean_raw"))
    # 3) EXECUTEï¼šå»æŒ‡æ ‡åŒ–ï¼ˆæ ¹æºç­ç«ï¼‰
    phase = phase_transition(phase, "EXECUTE")
    guard_future_rows(records, 0)

    # ==========================
    # ç‚¹ä½å£å¾„ï¼ˆé”æ­»ï¼‰ï¼šæ‰«æâ™» / è§¦å‘â™» / ğŸ¯(N_prebet)
    #   - æ‰«æâ™»ï¼šç»“æ„å‘½ä¸­ç‚¹ï¼ˆç”¨äºå®¡è®¡/å®šä½ï¼‰
    #   - è§¦å‘â™»ï¼šç›‘æµ‹å¯åŠ¨ç‚¹ï¼ˆå½“å‰=æ‰«æâ™»ï¼›åç»­å»¶è¿ŸæŠ•æ”¾ç­–ç•¥å¯æ”¹ï¼‰
    #   - ğŸ¯(N_prebet)ï¼šäººç±»å®é™…å–å€¼/ä¸‹æ³¨ç‚¹=å–å€¼ç‚¹ï¼ˆå½“å‰=è§¦å‘â™»ï¼›ğŸ“ŒæŠ½æ ·å–æ­¤ç‚¹ä½ï¼‰
    #   - ç»“ç®—å£Kï¼šä» ğŸ¯_idx+1 èµ·é¦–ä¸ªéTï¼ˆåªç”¨äºç»“ç®—ï¼Œä¸æ‰“å°ã€ä¸å‚ä¸å†³ç­–ï¼‰
    # ==========================
    scan_cycle_seen_all = getattr(star_snap, "seen_all", None)   # æ‰«æâ™»
    trigger_cycle_seen_all = scan_cycle_seen_all                 # è§¦å‘â™»ï¼ˆå½“å‰ç­‰äºæ‰«æâ™»ï¼‰
    n_prebet_seen_all = trigger_cycle_seen_all                   # ğŸ¯ = N_prebetï¼ˆäººç±»å®é™…å–å€¼/ä¸‹æ³¨ç‚¹ï¼‰
    tgt_seen_all = n_prebet_seen_all                             # ğŸ¯ï¼ˆç»Ÿä¸€åˆ«åï¼Œåç»­åªç”¨ğŸ¯ï¼‰
    bet_star_seen_all = tgt_seen_all                             # å…¼å®¹å­—æ®µï¼šæŠ•æ”¾ç‚¹=ğŸ¯ï¼ˆå–å€¼ç‚¹ï¼‰

    # ğŸ“Œ æŠ½æ ·æ¢é’ˆï¼šäººç±»ä¸‹æ³¨ç‚¹=å–å€¼ç‚¹ï¼ˆN_prebetï¼‰ï¼›å†»ç»“åŒºè‡ªå¸¦ï¼Œä¸å—è¦†ç›–åŒºå½±å“ï¼›ä»…ç”¨äºæ‰“å°å®šä½ï¼ˆä¸å‚ä¸é€»è¾‘ï¼‰
    try:
        _sample_probe_update(
            file_name=star_row.get("file") or records[0].get("file"),
            sub_batch=star_row.get("sub_batch") or records[0].get("sub_batch"),
            idx=tgt_seen_all,
            boot_id=star_boot_id,
        )
    except Exception:
        pass

    # æ¨è¿›å™¨ï¼ˆå”¯ä¸€å…è®¸çš„â€œåç»§è¡Œâ€æ–¹å¼ï¼‰
    # 4) æ‰§è¡Œ 1-2-4-8
    target_side = strong_side
    units = [1, 2, 4, 8]
    bet_n = 1
    j = star_idx
    last_settled_nonT_idx = int(star_snap.idx)
    j = advance_one_row(j, records, phase=phase, boot_id=star_boot_id)

    is_settled = False
    trade_bust = 0
    snapshots = []

    stage_snaps = []
    stage_snap_profits = []
    snap_seq = 0
    while bet_n <= 4 and j is not None:
        row = records[j]
        rr = row.get("r")
        if rr == "T":
            j = advance_one_row(j, records, phase=phase, boot_id=star_boot_id)
            continue

        # é´çº§é—¸é—¨ï¼šå®é™…è½æ³¨ç‚¹ä¸å¾—è½åœ¨ seen_all=1..8ï¼ˆéTæ‰ç®—â€œå®é™…è½æ³¨ç‚¹â€ï¼‰
        if BOOT_FILTER and rr != "T":
            try:
                sa = int(row.get("seen_all"))
                if 1 <= sa <= 8:
                    global BET_IN_FORBIDDEN_SEEN
                    BET_IN_FORBIDDEN_SEEN += 1
                    _raise_guard(code="BET_IN_FORBIDDEN_SEEN", rule_id=10, phase="EXECUTE", msg="ç¦åŒºä¸‹æ³¨", evidence=f"file={row.get('file')}|idx={row.get('idx')}|seen_all={row.get('seen_all')}")
            except RuntimeError:
                raise
            except Exception:
                pass
        # é˜¶æ®µå¿«ç…§å†™å…¥ç§»åˆ°â€œèµ¢/è¾“åˆ†æ”¯ï¼šprofit æ›´æ–°ä¹‹åâ€ï¼ˆç”¨äºå†™å…¥ profit_to_hereï¼›å¹¶ä»ä¸Šä¸€æ‰‹å·²ç»“ç®—éTç¼“å­˜è¡Œå–ä¸‰æŒ‡æ ‡ï¼‰

        # ä»…ä¿ç•™å…ƒä¿¡æ¯ï¼ˆä¸å«æŒ‡æ ‡ï¼‰
        snapshots.append({
            "bet_n": bet_n,
            "r": rr,
            "idx": row.get("idx"),
            "seen_all": row.get("seen_all"),
            "shoe_id": row.get("shoe_id"),
            "boot_id": row.get("boot_id", row.get("shoe_id")),
        })

        # Î”å£å¾„ï¼šstopç«¯å‡€å€¼å–â€œæœ¬æ³¨è½æ³¨å‰å·²å®ç°å‡€å€¼â€ï¼ˆé¿å…å›å¡«æˆé´å°¾æœ€ç»ˆå€¼ï¼‰

        profit_before = float(profit)

        u = units[bet_n - 1]
        if rr == target_side:
            # èµ¢
            profit += (u * 0.95 if target_side == "B" else u * 1.0)

            # é˜¶æ®µå¿«ç…§ï¼šå†™å…¥ï¼ˆéTæ‰å†™ï¼›åŒä¸€ bet_n å…è®¸å¤šæ¡ï¼›snap_seq ä»…æ’åº/å®¡è®¡ï¼‰
            stage = f"L{bet_n}"
            if stage in _STAGE_LIST and _stage_enabled(stage):
                if not (0 <= last_settled_nonT_idx < j):
                    raise RuntimeError(
                        f"stage_snap cache idx invalid: last_settled_nonT_idx={last_settled_nonT_idx}, j={j}, boot={star_boot_id}"
                    )
                snap_seq += 1
                stage_snaps.append(
                    _make_stage_snap_from_cache(
                        stage=stage,
                        rule_id="BASE",
                        rr=rr,
                        cache_row=metrics_cache[last_settled_nonT_idx],
                        snap_source=stage,
                        snap_seq=snap_seq,
                        profit_to_here=profit_before,
                    )
                )
                stage_snap_profits.append(float(profit_before))
            last_settled_nonT_idx = j
            match += 1
            is_settled = True
            break
        else:
            # è¾“
            profit -= u

            # é˜¶æ®µå¿«ç…§ï¼šå†™å…¥ï¼ˆéTæ‰å†™ï¼›åŒä¸€ bet_n å…è®¸å¤šæ¡ï¼›snap_seq ä»…æ’åº/å®¡è®¡ï¼‰
            stage = f"L{bet_n}"
            if stage in _STAGE_LIST and _stage_enabled(stage):
                if not (0 <= last_settled_nonT_idx < j):
                    raise RuntimeError(
                        f"stage_snap cache idx invalid: last_settled_nonT_idx={last_settled_nonT_idx}, j={j}, boot={star_boot_id}"
                    )
                snap_seq += 1
                stage_snaps.append(
                    _make_stage_snap_from_cache(
                        stage=stage,
                        rule_id="BASE",
                        rr=rr,
                        cache_row=metrics_cache[last_settled_nonT_idx],
                        snap_source=stage,
                        snap_seq=snap_seq,
                        profit_to_here=profit_before,
                    )
                )
                stage_snap_profits.append(float(profit_before))
            last_settled_nonT_idx = j
            bet_n += 1
            j = advance_one_row(j, records, phase=phase, boot_id=star_boot_id)
            continue

    if not is_settled:
        mismatch += 1
        exhaustion += 1
        trade_bust = 1

    phase = phase_transition(phase, "DONE")

    return {
        "entry": entry,
        "match": match,
        "mismatch": mismatch,
        "break": exhaustion,
        "stop": stop,
        "profit": profit,
        "trade_bust": trade_bust,
        "boot_id": int(star_boot_id),
        "star_snap": star_snap,
        "snapshots": snapshots,
        "stage_snaps": stage_snaps,
        "stage_snap_profits": stage_snap_profits,
        "struct_status": st,
        "struct_strong": strong_side,
        "struct_star_idx": star_idx,
        "struct_fail_reason": struct_info.get("fail_reason"),
        "struct_forbidden_star_cnt": struct_info.get("forbidden_star_cnt", 0),
        "struct_forbidden_star_first_seen": struct_info.get("forbidden_star_first_seen"),
        "decision_used": 1 if decision_used else 0,
        "scan_cycle_seen_all": scan_cycle_seen_all,
        "trigger_cycle_seen_all": trigger_cycle_seen_all,
        "bet_star_seen_all": bet_star_seen_all,

    }



def _find_existing_col(row0: dict, candidates):
    """åœ¨è¡¨å¤´é‡ŒæŒ‰å€™é€‰åæ‰¾åˆ—ï¼ˆå¤§å°å†™ä¸æ•æ„Ÿï¼‰ã€‚æ‰¾ä¸åˆ°è¿”å› Noneã€‚"""
    if not isinstance(row0, dict):
        return None
    # ç›´æ¥åŒ¹é…
    for c in candidates:
        if c in row0:
            return c
    # å°å†™åŒ¹é…
    lower_map = {str(k).lower(): k for k in row0.keys()}
    for c in candidates:
        k = lower_map.get(str(c).lower())
        if k is not None:
            return k
    return None


def _to_int_strict(v):
    if v is None:
        raise RuntimeError("PPBB_PARSE_FAIL(None)")
    s = str(v).strip()
    if s == "" or s.lower() == "none":
        raise RuntimeError("PPBB_PARSE_FAIL(Empty/None)")
    # å…è®¸ "3.0" è¿™ç±»
    return int(float(s))


def _ppbb_identity_sample_check(rows, col_result, col_diff, fname):
    """ç‚¹å·®æ’ç­‰å¼ + ç»“æœæ˜ å°„æŠ½æ£€ï¼ˆé”æ­»è¯­ä¹‰ï¼šPP=é—²ç‚¹ï¼ŒBB=åº„ç‚¹ï¼‰ã€‚

    æŠ½æ£€ï¼š
      - ç‚¹å·® == (BB - PP)
      - éTï¼šBB>PP -> Bï¼›PP>BB -> Pï¼›Tï¼šBB==PP
    ä»»æ„ä¸ä¸€è‡´ï¼šraise å¹¶æ‰“å°æœ€å°è¯æ®ã€‚
    """
    global PPBB_CHECKED, PPBB_MISMATCH, PPBB_FIRST_EVIDENCE
    if not ENFORCE_PPBB_SEMANTICS:
        return

    if not rows:
        return

    row0 = rows[0] if isinstance(rows[0], dict) else {}
    col_bb = _find_existing_col(row0, ["BB", "åº„ç‚¹", "BANKER", "BPoint"])
    col_pp = _find_existing_col(row0, ["PP", "é—²ç‚¹", "PLAYER", "PPoint"])

    if col_bb is None or col_pp is None:
        raise RuntimeError(f"âŒâŒâŒ è¡¨å¤´ç¼ºå¤±ï¼šå¿…é¡»å­˜åœ¨ BB/PPï¼ˆåº„ç‚¹/é—²ç‚¹ï¼‰| æ–‡ä»¶={fname}")

    if col_result is None or col_diff is None:
        # ç»“æœ/ç‚¹å·®åˆ—ç¼ºå¤±ä¼šè¢«ä¸Šæ¸¸å¼ºåˆ¶æ‹¦æˆªï¼›è¿™é‡Œä¸é‡å¤
        return

    sample_n = min(len(rows), 200)
    for i in range(sample_n):
        r = rows[i]
        if not isinstance(r, dict):
            continue

        rr = (r.get(col_result) or "").strip()
        if rr not in ("B", "P", "T"):
            continue

        try:
            bb = _to_int_strict(r.get(col_bb))
            pp = _to_int_strict(r.get(col_pp))
            diff_val = _to_int_strict(r.get(col_diff))
        except Exception as e:
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"PARSE_FAIL | file={fname} | row={i+2} | err={e}"
            print(f"âŒâŒâŒ ç‚¹å·®æ’ç­‰å¼æŠ½æ£€å¤±è´¥ï¼šæ— æ³•è§£æ | æ–‡ä»¶={fname} | è¡Œ={i+2}")
            print(f"  BB={r.get(col_bb)} | PP={r.get(col_pp)} | ç‚¹å·®={r.get(col_diff)} | ç»“æœ={rr}")
            raise

        # 1) ç‚¹å·®æ’ç­‰å¼
        if diff_val != (bb - pp):
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"DIFF_MISMATCH | file={fname} | row={i+2} | BB={bb} PP={pp} diff={diff_val}"
            print(f"âŒâŒâŒ ç‚¹å·®æ’ç­‰å¼ä¸ä¸€è‡´ | æ–‡ä»¶={fname} | è¡Œ={i+2}")
            print(f"  BB={bb} | PP={pp} | ç‚¹å·®={diff_val} | (BB-PP)={bb-pp} | ç»“æœ={rr}")
            raise RuntimeError("PPBB_DIFF_IDENTITY_FAIL")

        # 2) ç»“æœæ˜ å°„ä¸€è‡´æ€§
        if rr == "B" and not (bb > pp):
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"RES_MISMATCH_B | file={fname} | row={i+2} | BB={bb} PP={pp}"
            print(f"âŒâŒâŒ ç»“æœæ˜ å°„ä¸ä¸€è‡´(B) | æ–‡ä»¶={fname} | è¡Œ={i+2}")
            print(f"  BB={bb} | PP={pp} | ç»“æœ={rr}")
            raise RuntimeError("PPBB_RESULT_IDENTITY_FAIL")
        if rr == "P" and not (pp > bb):
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"RES_MISMATCH_P | file={fname} | row={i+2} | BB={bb} PP={pp}"
            print(f"âŒâŒâŒ ç»“æœæ˜ å°„ä¸ä¸€è‡´(P) | æ–‡ä»¶={fname} | è¡Œ={i+2}")
            print(f"  BB={bb} | PP={pp} | ç»“æœ={rr}")
            raise RuntimeError("PPBB_RESULT_IDENTITY_FAIL")
        if rr == "T" and not (bb == pp):
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"RES_MISMATCH_T | file={fname} | row={i+2} | BB={bb} PP={pp}"
            print(f"âŒâŒâŒ ç»“æœæ˜ å°„ä¸ä¸€è‡´(T) | æ–‡ä»¶={fname} | è¡Œ={i+2}")
            print(f"  BB={bb} | PP={pp} | ç»“æœ={rr}")
            raise RuntimeError("PPBB_RESULT_IDENTITY_FAIL")

    PPBB_CHECKED += sample_n


def load_all_boots(csv_files):
    # boots: list of (meta, records)
    boots = []  # æ¯ä¸ªå…ƒç´ ï¼š({"file":..., "sub_batch":...}, [records...])
    boot_id_seq = 0  # å†…éƒ¨é€’å¢é´å·ï¼ˆç”¨äºboot_id/é‹å·ï¼‰

    print("æ£€æµ‹åˆ° CSV æ–‡ä»¶æ•°é‡:", len(csv_files))

    for i, fname in enumerate(csv_files, 1):
        # æ¯ä¸ª CSV æ–‡ä»¶å†… boot_id_seq ä» 1 é‡æ–°è®¡æ•°ï¼ˆæ–‡ä»¶å†…åºå·ï¼‰
        boot_id_seq = 0
        if i % 10 == 0:
            print(f"è¿›åº¦: å·²å¤„ç† {i}/{len(csv_files)} ä¸ªæ–‡ä»¶")

        rows = []
        for enc in ("utf-8", "utf-8-sig", "gbk", "gb18030"):
            try:
                with open(fname, "r", encoding=enc) as f:
                    rows = list(csv.DictReader(f))
                break
            except Exception:
                rows = []

        if not rows:
            continue

        col_batch, col_end, col_result, col_diff, col_rate, col_mean = detect_columns(rows[0])
        _print_header_mapping_once(rows[0], (col_batch, col_end, col_result, col_diff, col_rate, col_mean))
        _ppbb_identity_sample_check(rows, col_result, col_diff, fname)

        if col_batch is None or col_end is None:
            print("âŒâŒâŒ è¡¨å¤´ç¼ºå¤±ï¼šå¿…é¡»åŒæ—¶å­˜åœ¨ Sub-Batch ä¸ é´ç»“æŸ | æ–‡ä»¶ =", fname)
            raise RuntimeError("è¡¨å¤´ç¼ºå¤±ï¼šSub-Batch / é´ç»“æŸ")

        current_batch = None
        current_records = []
        seen_all = 0
        end_seen = 0

        def _finalize_boot():
            nonlocal boot_id_seq
            nonlocal current_batch, current_records, seen_all, end_seen
            if current_batch is None:
                return
            if not current_records:
                return

            # é´ç»“æŸä¸€è‡´æ€§ï¼šä»…æœ€åä¸€å£ä¸º1ï¼Œå…¶ä½™ä¸º0ï¼ˆé”æ­»ï¼‰
            if end_seen != 1:
                print("âŒâŒâŒ é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šé´ç»“æŸ=1æ¬¡æ•°!=1 | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch, (current_records[-1].get("idx") if current_records else None))
                raise RuntimeError("é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šé´ç»“æŸ=1æ¬¡æ•°!=1")
            if safe_int(current_records[-1].get("shoe_end"), 0) != 1:
                print("âŒâŒâŒ é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæœ€åä¸€å£é´ç»“æŸ!=1 | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch, current_records[-1].get("idx"))
                raise RuntimeError("é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæœ€åä¸€å£é´ç»“æŸ!=1")

            boot_id_seq += 1
            for rr in current_records:
                rr["shoe_id"] = boot_id_seq
                rr["boot_id"] = boot_id_seq
                rr["file_idx"] = i
            boots.append(({"file": fname, "file_idx": i, "sub_batch": current_batch, "boot_id": boot_id_seq}, current_records))

            # reset
            current_batch = None
            current_records = []
            seen_all = 0
            end_seen = 0

        for row_i, r in enumerate(rows):
            batch = r.get(col_batch)

            # å­æ‰¹æ¬¡å¯åŠ¨
            if current_batch is None:
                current_batch = batch

            # Sub-Batch å˜æ›´å¿…é¡»ä¸é´ç»“æŸå¯¹é½ï¼ˆé”æ­»ï¼‰ï¼šæœªé‡åˆ°é´ç»“æŸ=1 ä¸å…è®¸å˜æ›´
            if batch != current_batch:
                print("âŒâŒâŒ é´è¾¹ç•Œå¤±è´¥ï¼šSub-Batch åœ¨é´ç»“æŸå‰å‘ç”Ÿå˜æ›´ | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch, (current_records[-1].get("idx") if current_records else None))
                raise RuntimeError("é´è¾¹ç•Œå¤±è´¥ï¼šSub-Batch å˜æ›´æœªå¯¹é½é´ç»“æŸ")

            res_raw = r.get(col_result)
            res = map_result(res_raw)
            if res not in ("B", "P", "T"):
                # æ— æ³•æ˜ å°„çš„ä¸å…¥åº“ï¼ˆé”æ­»ï¼‰
                continue

            diff = safe_int(r.get(col_diff, 0), 0)
            rate_raw = (r.get(col_rate) if col_rate else None)
            mean_raw = (r.get(col_mean) if col_mean else None)
            rate = safe_float(rate_raw, None, kind="RATE") if col_rate else None
            mean = safe_float(mean_raw, None, kind="MEAN") if col_mean else None
            shoe_end = safe_int(r.get(col_end, 0), 0)

            seen_all += 1
            rec = {
                "idx": seen_all - 1,
                "seen_all": seen_all,
                "r": res,
                "diff": diff,
                "rate": rate,
                "mean": mean,
            "rate_raw": rate_raw,
            "mean_raw": mean_raw,
                "file": fname,
                "sub_batch": current_batch,
                "shoe_end": shoe_end,
            }
            current_records.append(rec)

            if shoe_end == 1:
                end_seen += 1
                _finalize_boot()

        # æ–‡ä»¶ç»“æŸï¼šè‹¥ä»æœ‰æœªå°å£çš„é´ â†’ æŠ¥é”™
        if current_batch is not None:
            if current_records:
                print("âŒâŒâŒ é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæ–‡ä»¶ç»“æŸä»æœªé‡åˆ°é´ç»“æŸ=1 | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch, current_records[-1].get("idx"))
                raise RuntimeError("é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæ–‡ä»¶ç»“æŸæœªå°å£")

    print("æŒ‰ Sub-Batch + é´ç»“æŸ åˆ†é´å®Œæˆï¼Œé´æ€»æ•°:", len(boots))
    return boots

# ğŸ€è¦†ç›–é”šç‚¹002_æŠ¥å‘Šæ±‡æ€»_BEGINï¼ˆæ•´æ®µè¦†ç›–ç”¨æ­¤è¡Œå®šä½ï¼›è¦†ç›–èŒƒå›´=æœ¬è¡Œåˆ°å¯¹åº”_ENDï¼‰
def _run_report(csv_files, title):
    global RATE_INVALID_RAW, RATE_INVALID_BUCKET

    boots = load_all_boots(csv_files)
    total_boots = len(boots)

    playable_boots = 0
    skipped_boots = 0

    total_entry = 0
    total_match = 0
    total_mismatch = 0
    total_exhaustion = 0
    total_profit = 0.0

    # ------------------------------------------------------------
    # L1 é”æ­»æ ‡é¢˜ç»Ÿè®¡ï¼ˆæŠ•æ”¾ç‚¹å½“è¡Œï¼‰
    # ------------------------------------------------------------
    l1_diff_dist = defaultdict(int)  # key: '0'..'9','9+'
    l1_rate_dist = defaultdict(int)  # key: å‰å°/å‰å¤§/æå€¼/æ— æ•ˆ
    l1_mean_dist = defaultdict(int)  # key: æœ‰æ•ˆåŒå‘/æœ‰æ•ˆåå‘/ä¸­è½´
    STAR_ON_T = 0
    STAR_DIFF0_AND_R_IN_BP = 0
    MEAN_MISSING_RAW = 0  # æ•°æ®ç¼ºå¤±-ä»…ç»Ÿè®¡
    MEAN_PARSE_FAIL = 0     # è§£æå¤±è´¥-ç›®æ ‡=0
    MEAN_INVALID_BUG = 0  # (ç›®æ ‡=0) ç‚¹å·®=0å´è¢«åˆ¤ä¸ºå‡å·®æ— æ•ˆ
    STRUCT_SCAN_CALLS = 0
    STRUCT_OK = 0
    STRUCT_FAIL = 0
    MISS_MAIN_LT3 = 0
    MISS_WEAK_GT2 = 0
    MISS_NO_CANDIDATE = 0
    MISS_ONLY_FORBIDDEN = 0



    cont_agg = _init_cont_agg() if CONT_STATS_ENABLE else None

    # ------------------------------------------------------------
    # æ‰¹æ¬¡å¤„ç†è¿›åº¦è¾“å‡ºï¼ˆåªæ‰“å°ï½œä¸å‚ä¸ä»»ä½•åˆ¤æ–­ï¼‰
    # ------------------------------------------------------------
    def _print_batch_progress(done, total, bar_width=20, force_newline=False):
        if total <= 0:
            return
        if done < 0:
            done = 0
        if done > total:
            done = total
        ratio = done / total
        filled = int(ratio * bar_width)
        if filled < 0:
            filled = 0
        if filled > bar_width:
            filled = bar_width
        bar = ("=" * filled) + (" " * (bar_width - filled))
        pct = ratio * 100.0
        line = f"è¿›åº¦: [{bar}] {pct:.1f}% ({done:,}/{total:,} æ‰¹æ¬¡)"
        if force_newline:
            print(line)
        else:
            print("\r" + line, end="", flush=True)

    if total_boots > 0:
        print()
        print(f"å¼€å§‹å¤„ç† {total_boots:,} ä¸ªæ‰¹æ¬¡...")

    step = max(1, total_boots // 200) if total_boots > 0 else 1

    boots_out = []  # ä»…å­˜æ”¾ entry æ ·æœ¬çš„æœ€å°å­—æ®µï¼ˆä¾›æŠ•æ”¾é“¾è·¯è§„åˆ™æ—æ‰«æä½¿ç”¨ï¼‰

    for n, (meta, rec) in enumerate(boots, 1):
        if total_boots > 0 and (n == 1 or n == total_boots or (n % step == 0)):
            _print_batch_progress(n, total_boots)
        boot_filter(rec)  # é´çº§å®Œæ•´æ€§æ ¡éªŒï¼ˆä¸è¶³9å£ç›´æ¥æŠ¥é”™ï¼‰

        global _CTX_FILE, _CTX_SUBBATCH
        _CTX_FILE = meta.get('file', '')
        _CTX_SUBBATCH = meta.get('sub_batch', '')
        out = run_strategy_on_boot(rec)

        # ç»“æ„/æŠ•æ”¾ç‚¹ä¸æ»¡è¶³åˆ™ä¸å…¥åœºï¼ˆout=Noneï¼‰ï¼Œå¿…é¡»è·³è¿‡ï¼Œé¿å…ç©ºæŒ‡é’ˆ
        if out is None:
            skipped_boots += 1
            continue

        playable_boots += 1

        # L1 æŠ•æ”¾ç‚¹å½“è¡Œç»Ÿè®¡ï¼šä»…ä½¿ç”¨ star_snapï¼ˆå–å€¼å£é”æ­»ï¼‰
        star = out.get("star_snap")
        # è§„åˆ™æ—æ‰«ææ ·æœ¬æ± ï¼šåªæ”¶ entry çš„æŠ•æ”¾ç‚¹æœ€å°å­—æ®µï¼Œé¿å…äºŒæ¬¡è·‘è¡¨ä¸å¤§å¯¹è±¡å †ç§¯
        if out.get("entry") and isinstance(star, Snapshot):
            boots_out.append({
                "entry": 1,
                "boot_id": int(out.get("boot_id", meta.get("boot_id", -1))),
                "profit": float(out.get("profit", 0.0)),
                "star_snap": star,
                # å…³é”®ï¼šç›®æ ‡å±‚/è§„åˆ™æ—/åˆ†å¸ƒåªèƒ½ä»â€œé˜¶æ®µå¿«ç…§æ± â€å–æ•°
                "stage_snaps": (out.get("stage_snaps") or []),
                "stage_snap_profits": (out.get("stage_snap_profits") or []),
            })

        if isinstance(star, Snapshot):
            sr = star.rr
            sd = secure_read_metric(star, "diff", "REPORT", who="REPORT", idx=star.idx, boot_id=star.boot_id, seen_all=star.seen_all)
            srate = secure_read_metric(star, "rate", "REPORT", who="REPORT", idx=star.idx, boot_id=star.boot_id, seen_all=star.seen_all)
            smean = secure_read_metric(star, "mean", "REPORT", who="REPORT", idx=star.idx, boot_id=star.boot_id, seen_all=star.seen_all)

            if sr == "T":
                STAR_ON_T += 1
            elif sr in ("B", "P"):
                if safe_int(sd, 0) == 0:
                    STAR_DIFF0_AND_R_IN_BP += 1

                l1_diff_dist[_l1_abs_diff_bucket(sd)] += 1
                rb = (getattr(star, "rate_bucket_l1", None) if star is not None else None)
                rb = (rb if rb else "æ— æ•ˆ")
                l1_rate_dist[rb] += 1
                # è‡ªè¯ï¼šæ— æ•ˆè®¡æ•°ä¸€è‡´æ€§ï¼ˆæŠ“â€œæ— æ•ˆè¢«ç¡¬è½¬0â€ï¼‰
                if srate is None:
                    RATE_INVALID_RAW += 1
                if rb == 'æ— æ•ˆ':
                    RATE_INVALID_BUCKET += 1
                # L1å‡å·®åˆ†æ¡¶ï¼šåŒºåˆ†ç¼ºå¤±/è§£æå¤±è´¥ï¼ˆè§£æå¤±è´¥ç›®æ ‡=0ï¼‰
                mean_raw = secure_read_metric(star, "mean_raw", "REPORT", who="REPORT", idx=star.idx, boot_id=star.boot_id, seen_all=star.seen_all)
                mean_val = smean

                if _is_raw_missing(mean_raw):
                    if mean_val is None:
                        MEAN_MISSING_RAW += 1
                        mb = None
                    else:
                        mb, _ = _l1_mean_bucket(sd, mean_val)
                else:
                    if mean_val is None:
                        MEAN_PARSE_FAIL += 1
                        mb = None
                    else:
                        mb, _ = _l1_mean_bucket(sd, mean_val)

                if mb is not None:
                    l1_mean_dist[mb] += 1

        # ç»“æ„æ‰«æè‡ªè¯ç»Ÿè®¡
        if STRUCT_SCAN:
            STRUCT_SCAN_CALLS += 1
            if out.get("struct_status") == "STRUCT_OK":
                STRUCT_OK += 1
            elif out.get("struct_status") == "STRUCT_FAIL":
                STRUCT_FAIL += 1
                fr = out.get("struct_fail_reason")
                if fr == "MAIN_LT3":
                    MISS_MAIN_LT3 += 1
                elif fr == "WEAK_GT2":
                    MISS_WEAK_GT2 += 1
                elif fr == "NO_CANDIDATE":
                    MISS_NO_CANDIDATE += 1
                elif fr == "ONLY_FORBIDDEN":
                    MISS_ONLY_FORBIDDEN += 1

        total_entry += int(out.get("entry", 0))
        total_match += int(out.get("match", 0))
        total_mismatch += int(out.get("mismatch", 0))
        total_exhaustion += int(out.get("exhaustion", 0))
        total_profit += float(out.get("profit", 0.0))

        if (cont_agg is not None) and (not SILENT_MODE):
            _cont_consume_snapshots(cont_agg, out.get("snapshots") or [])

    if total_boots > 0:
        print()  # ç»“æŸè¿›åº¦è¡Œ

    print()
    # ==================== æŠ•æ”¾é“¾è·¯ï½œå±‚å¼€å…³æ‘˜è¦ + ç›®æ ‡å±‚åˆ†å¸ƒ + å˜åŒ–ç‡è§„åˆ™æ—æ‰«æï¼ˆå•åˆ€ï¼‰ ====================
    target_stage = TARGET_STAGE if TARGET_STAGE in _STAGE_LIST else "L4"
    stage_on = {s: _stage_enabled(s) for s in _STAGE_LIST}
    called = {s: False for s in _STAGE_LIST}
    if RULESCAN_ON and stage_on.get(target_stage, False):
        called[target_stage] = True
    if AUDIT_RUN:
        for s in _STAGE_LIST:
            if stage_on.get(s, False):
                called[s] = True
    # reach_targetï¼šåªè®¤â€œé˜¶æ®µå¿«ç…§æ± â€é‡Œç›®æ ‡å±‚çš„ StageSnapï¼ˆstage==snap_source==target_stageï¼‰
    reach_target = 0
    if stage_on.get(target_stage, False):
        for out in boots_out:
            if not out.get("entry"):
                continue
            snaps = out.get("stage_snaps") or []
            if any(isinstance(x, StageSnap) and x.stage == target_stage and x.snap_source == target_stage and x.bet_n == int(target_stage[1:]) for x in snaps):
                reach_target += 1

    try:
        entry_pct2 = (total_entry / total_boots * 100.0) if total_boots else 0.0
        reach_pct2 = (reach_target / total_boots * 100.0) if total_boots else 0.0
    except Exception:
        entry_pct2 = 0.0
        reach_pct2 = 0.0

    print(
        "å±‚å¼€å…³æ‘˜è¦ï¼š"

        + " | ".join([f"{s}={'å¼€' if stage_on[s] else 'å…³'}/è°ƒç”¨={'1' if called[s] else '0'}" for s in _STAGE_LIST])
        + f" | chain_entry={total_entry}({entry_pct2:.2f}%) | reach_target={reach_target}({reach_pct2:.2f}%) | ç›®æ ‡å±‚={target_stage} | è§„åˆ™æ—={'å¼€' if RULESCAN_ON else 'å…³'}"
    )

    print(f"è§„åˆ™æ—å‚æ•°ï¼šæœ€å°å‘½ä¸­æ•°={RULESCAN_MIN_CNT} | TopN={RULESCAN_TOPN} | æ‰«æå½¢æ€=å•æ¡¶/åŒæ¡¶AND/ä¸¤å•æ¡¶OR | ORé€€åŒ–è¿‡æ»¤=Stop%>=99% + æ’çœŸå¼ï¼ˆä»…ORï¼‰")

    # ç›®æ ‡å±‚æœªå¯ç”¨ï¼šæŒ‰å¥‘çº¦ä¸å†™å¿«ç…§ã€ä¸å…¥æ ·æœ¬æ± 
    if not stage_on.get(target_stage, False):
        print(f"[{target_stage}] ç›®æ ‡å±‚æœªå¯ç”¨ï¼šæŒ‰å¥‘çº¦ä¸å†™é˜¶æ®µå¿«ç…§ã€ä¸å…¥æ ·æœ¬æ± ï¼Œè·³è¿‡åˆ†å¸ƒ/è§„åˆ™æ—æ‰«æ")
    else:
        pool = []  # (StageSnap, delta)
        dist_rate = {}
        dist_diff = {}
        dist_mean = {}
        miss_rate = {}
        miss_mean = {}
        cnt_rate_nonneg = 0
        cnt_rate_ge2 = 0
        ex_rate_nonneg = []  # (file_idx, boot_id, snap_seq, rate_text)
        ex_rate_ge2 = []     # (file_idx, boot_id, snap_seq, rate_text)
        # Î” è‡ªè¯è®¡æ•°ï¼ˆåäº‹å®å¢ç›Šï¼‰
        cnt_delta_nonzero = 0
        cnt_stop_missing = 0
        cnt_stop_eq_final = 0
        ex_delta = []  # (file_idx, boot_id, snap_seq, profit_stop, profit_final, delta)


        def _inc(d: dict, k: str, n: int = 1) -> None:
            d[k] = d.get(k, 0) + n

        # ä»… reach_target çš„ç›®æ ‡å±‚æ ·æœ¬å…¥æ± ï¼ˆåªä»é˜¶æ®µå¿«ç…§æ± å–æ•°ï¼Œä¸¥ç¦ records/ç´¢å¼•å›è¯»ï¼‰
        for out in boots_out:
            if not out.get("entry"):
                continue
            snaps = out.get("stage_snaps") or []
            pairs = [(i, x) for i, x in enumerate(snaps) if isinstance(x, StageSnap) and x.stage == target_stage and x.snap_source == target_stage]
            if not pairs:
                continue
            pairs.sort(key=lambda t: int(getattr(t[1], "snap_seq", 0) or 0))
            best_idx, snap = pairs[-1]  # ç›®æ ‡å±‚å–æœ«æ¡å¿«ç…§ï¼ˆsnap_seq æœ€å¤§ï¼‰
            # åäº‹å®å¢ç›Šå£å¾„é”æ­»ï¼šÎ” = profit_stop(å‘½ä¸­æ—¶åˆ»å·²çœŸå®ç»“ç®—) âˆ’ profit_baseline(è£¸è·‘æœ€ç»ˆ)
            _p_base = float(out.get("profit", 0.0) or 0.0)
            _profits = out.get("stage_snap_profits", [])
            if (best_idx < 0) or (best_idx >= len(_profits)):
                cnt_stop_missing += 1
                _p_stop_raw = None
                _p_stop = 0.0
            else:
                _p_stop_raw = _profits[best_idx]
                _p_stop = float(_p_stop_raw or 0.0)
            p = _p_stop - _p_base
            if abs(p) > 1e-12:
                cnt_delta_nonzero += 1
                if len(ex_delta) < 5:
                    ex_delta.append((out.get("file_idx"), out.get("boot_id"), snap.snap_seq, _p_stop, _p_base, p))
            else:
                if (_p_stop_raw is not None) and (abs(_p_stop - _p_base) <= 1e-12):
                    cnt_stop_eq_final += 1
            pool.append((snap, p))

            # å˜åŒ–ç‡åŸå€¼è‡ªè¯ï¼šä»…ç»Ÿè®¡ç›®æ ‡å±‚é˜¶æ®µå¿«ç…§ï¼ˆç”¨äºåˆ¤å®šåŠ é€Ÿ/æå€¼æ˜¯å¦ä¸º 0 çš„â€œæ•°æ®äº‹å®â€ï¼‰
            rv = snap.rate_raw
            if rv is not None:
                if rv >= 0:
                    cnt_rate_nonneg += 1
                    if len(ex_rate_nonneg) < 5:
                        ex_rate_nonneg.append((out.get("file_idx"), out.get("boot_id"), snap.snap_seq, snap._rate_raw_text))
                if rv >= 2:
                    cnt_rate_ge2 += 1
                    if len(ex_rate_ge2) < 5:
                        ex_rate_ge2.append((out.get("file_idx"), out.get("boot_id"), snap.snap_seq, snap._rate_raw_text))

            rb = stage_rate_bucket(snap, target_stage)
            _inc(dist_rate, rb)
            _inc(dist_diff, snap.diff_bucket)
            _inc(dist_mean, snap.mean_bucket)

            if snap.rate_raw is None:
                _inc(miss_rate, snap._rate_raw_text if snap._rate_raw_text is not None else "")
            if snap.mean_raw is None:
                _inc(miss_mean, snap._mean_raw_text if snap._mean_raw_text is not None else "")

        N = len(pool)
        if called.get(target_stage, False):
            if N == 0:
                print(f"[{target_stage}_ç›®æ ‡å±‚åˆ†å¸ƒ] N=0ï¼ˆreach_target=0ï¼‰ï¼Œè·³è¿‡åˆ†å¸ƒ/è§„åˆ™æ—æ‰«æ")
            else:
                parts = []
                if target_stage in ("L2", "L3", "L4"):
                    _order = ["å‡é€Ÿ", "åŠ é€Ÿ", "æå€¼", "æ— æ•ˆ"]
                elif target_stage == "L1":
                    _order = ["å‰å°", "å‰å¤§", "æå€¼", "æ— æ•ˆ"]
                else:
                    _order = sorted(dist_rate.keys())
                for k in _order:
                    v = dist_rate.get(k, 0)
                    parts.append(f"{k}:{v}({(v / N * 100.0) if N else 0.0:.1f}%)")
                print(f"[{target_stage}_å˜åŒ–ç‡åˆ†å¸ƒ] " + " | ".join(parts) + f" | N={N}")
                print(f"[{target_stage}_å˜åŒ–ç‡åŸå€¼è‡ªè¯] >=0:{cnt_rate_nonneg}({(cnt_rate_nonneg/N*100.0) if N else 0.0:.1f}%) | >=2:{cnt_rate_ge2}({(cnt_rate_ge2/N*100.0) if N else 0.0:.1f}%) | æ ·ä¾‹>=0 Top5={ex_rate_nonneg} | æ ·ä¾‹>=2 Top5={ex_rate_ge2}")

                parts = []
                for k in [str(i) for i in range(0, 10)] + ["9+"]:
                    v = dist_diff.get(k, 0)
                    parts.append(f"{k}:{v}({(v/N*100.0):.1f}%)")
                print(f"[{target_stage}_ç‚¹å·®åˆ†å¸ƒ] " + " | ".join(parts) + f" | N={N}")

                # å‡å·®åˆ†å¸ƒï¼ˆé”æ­»å…¨æ¡¶ä½æ˜¾å¼è¾“å‡ºï¼‰
                parts = []
                for k in ["|å‡å·®|<3", "|å‡å·®|>=3", "mean=0", "æ— æ•ˆ"]:
                    v = dist_mean.get(k, 0)
                    parts.append(f"{k}:{v}({(v/N*100.0):.1f}%)")
                print(f"[{target_stage}_å‡å·®åˆ†å¸ƒ] " + " | ".join(parts) + f" | N={N}")

                def _topn(d: dict, n: int = 5):
                    return sorted(d.items(), key=lambda x: (-x[1], x[0]))[:n]

                rate_miss = sum(miss_rate.values())
                mean_miss = sum(miss_mean.values())
                if rate_miss:
                    top = ", ".join([f"'{k}':{v}" for k, v in _topn(miss_rate, 5)])
                    print(f"[{target_stage}_å˜åŒ–ç‡æ— æ•ˆ] cnt={rate_miss}({rate_miss/N*100.0:.1f}%) | Top5={top}")
                if mean_miss:
                    top = ", ".join([f"'{k}':{v}" for k, v in _topn(miss_mean, 5)])
                    print(f"[{target_stage}_å‡å·®æ— æ•ˆ] cnt={mean_miss}({mean_miss/N*100.0:.1f}%) | Top5={top}")

        # Entry/MinHit å…œåº•ï¼šç¡®ä¿ reach_target=0 æ—¶ä¹Ÿå¯æ‰“å°Î”è‡ªè¯ä¸”ä¸å´©
        Entry = int(N or 0)
        MIN_HIT = RULESCAN_MIN_CNT
        if RULESCAN_ON and called.get(target_stage, False) and N:
            Entry = N
            MIN_HIT = RULESCAN_MIN_CNT

            print("")
        print(f"[{target_stage}_Î”è‡ªè¯] é0Î”={cnt_delta_nonzero}({(cnt_delta_nonzero/Entry*100.0) if Entry else 0.0:.1f}%) | stopç¼ºå¤±={cnt_stop_missing} | stop==final={cnt_stop_eq_final} | Top5={ex_delta}")
        # Î”è‡ªè¯ä½œåºŸé˜ˆå€¼ï¼ˆå†»ç»“åŒºé”æ­»ï¼‰ï¼šæ»¡è¶³ä»»ä¸€æ¡å³ä½œåºŸ
        delta_void = False
        void_reason = ""
        if Entry > 0:
            if cnt_stop_missing > 0:
                delta_void = True
                void_reason = "stopç¼ºå¤±>0"
            elif cnt_stop_eq_final == Entry:
                delta_void = True
                void_reason = "stop==final==Entry"
            elif cnt_delta_nonzero == 0:
                delta_void = True
                void_reason = "é0Î”==0ä¸”Entry>0"
        cnt_nonzero_delta_eq0 = max(0, Entry - cnt_delta_nonzero)
        if N == 0:
            print(f"è§„åˆ™æ—æ‰«æå·²è·³è¿‡ï¼šreach_target=0")
        elif DELTA_AUDIT_ON and delta_void:
            print(f"[{target_stage}_Î”ä½œåºŸ] âœ… ä½œåºŸåŸå› ={void_reason} | stopç¼ºå¤±={cnt_stop_missing} | stop==final={cnt_stop_eq_final} | é0Î”==0={cnt_nonzero_delta_eq0}")
            if DELTA_AUDIT_ENFORCE:
                raise RuntimeError(f"Î”ä½œåºŸè§¦å‘ï¼š{void_reason}")
            print(f"è§„åˆ™æ—æ‰«æå·²è·³è¿‡ï¼šÎ”ä½œåºŸ({void_reason})")
        else:
            print(f"è§„åˆ™æ—æ‰«æï¼ˆç›®æ ‡å±‚={target_stage}ï½œEntry={reach_target}ï½œMinHit={MIN_HIT}ï½œæ‰«æ=å•æ¡¶+åŒæ¡¶AND+ä¸¤å•æ¡¶ORï½œä¸æ‰«ä¸‰æ¡¶ï¼‰")
            if True:
                # é¢„è®¡ç®—æ ·æœ¬æ ‡ç­¾
                tag_rows = []  # (rate_bucket, diff_bucket, mean_bucket, pnl)
                obs_rate, obs_diff, obs_mean = set(), set(), set()
                for snap, pnl in pool:
                    rb = stage_rate_bucket(snap, target_stage)
                    db = snap.diff_bucket
                    mb = snap.mean_bucket
                    tag_rows.append((rb, db, mb, pnl))
                    obs_rate.add(rb)
                    obs_diff.add(db)
                    obs_mean.add(mb)

                single = defaultdict(lambda: [0, 0.0])       # (field,val) -> [cnt,sum]
                rate_diff = defaultdict(lambda: [0, 0.0])    # (rb,db) -> [cnt,sum]
                rate_mean = defaultdict(lambda: [0, 0.0])    # (rb,mb) -> [cnt,sum]
                diff_mean = defaultdict(lambda: [0, 0.0])    # (db,mb) -> [cnt,sum]

                for rb, db, mb, pnl in tag_rows:
                    single[("rate", rb)][0] += 1
                    single[("rate", rb)][1] += pnl
                    single[("diff", db)][0] += 1
                    single[("diff", db)][1] += pnl
                    single[("mean", mb)][0] += 1
                    single[("mean", mb)][1] += pnl

                    rate_diff[(rb, db)][0] += 1
                    rate_diff[(rb, db)][1] += pnl
                    rate_mean[(rb, mb)][0] += 1
                    rate_mean[(rb, mb)][1] += pnl
                    diff_mean[(db, mb)][0] += 1
                    diff_mean[(db, mb)][1] += pnl

                def _cond_str(field: str, val: str) -> str:
                    if field == "rate":
                        return f"rate={val}"
                    if field == "diff":
                        return f"diff={val}"
                    if field == "mean":
                        return f"mean={val}"
                    return f"{field}={val}"

                def _rule_id_and(parts):
                    # parts: list of (field,val)
                    inner = "&".join([_cond_str(f, v) for f, v in parts])
                    return f"{target_stage}|{inner}"

                def _rule_id_or(a, b):
                    sa = _cond_str(a[0], a[1])
                    sb = _cond_str(b[0], b[1])
                    return f"{target_stage}|{sa} OR {sb}"

                def _add(rows, kind: str, rule_id: str, hit_cnt: int, sum_pnl: float):
                    if hit_cnt < MIN_HIT:
                        return
                    delta_sum = sum_pnl
                    delta_avg = delta_sum / Entry
                    stop_pct = hit_cnt / Entry
                    rows.append({
                        "kind": kind,
                        "rule_id": rule_id,
                        "hit": hit_cnt,
                        "stop_pct": stop_pct,
                        "delta_sum": delta_sum,
                        "delta_avg": delta_avg,
                    })

                rows = []

                # â‘  å•æ¡¶
                for (field, val), (cnt, s) in single.items():
                    _add(rows, "SINGLE", f"{target_stage}|{_cond_str(field, val)}", cnt, s)

                # â‘¡ åŒæ¡¶ç»„åˆï¼ˆANDï¼‰
                for (rb, db), (cnt, s) in rate_diff.items():
                    _add(rows, "AND", _rule_id_and([("rate", rb), ("diff", db)]), cnt, s)
                for (rb, mb), (cnt, s) in rate_mean.items():
                    _add(rows, "AND", _rule_id_and([("rate", rb), ("mean", mb)]), cnt, s)
                for (db, mb), (cnt, s) in diff_mean.items():
                    _add(rows, "AND", _rule_id_and([("diff", db), ("mean", mb)]), cnt, s)

                # â‘£ OR å¹¶é›†ï¼ˆä»…ä¸¤å•æ¡¶ ORï¼‰
                singles = list(single.keys())  # (field,val)
                def _get_single(k):
                    v = single.get(k)
                    if not v:
                        return (0, 0.0)
                    return v[0], v[1]

                def _get_intersection(a, b):
                    fa, va = a
                    fb, vb = b
                    if fa == fb:
                        if va == vb:
                            cnt, s = _get_single(a)
                            return cnt, s
                        return 0, 0.0
                    # rate/diff
                    if {fa, fb} == {"rate", "diff"}:
                        r = va if fa == "rate" else vb
                        d = vb if fb == "diff" else va
                        cnt, s = rate_diff.get((r, d), (0, 0.0))
                        return cnt, s
                    # rate/mean
                    if {fa, fb} == {"rate", "mean"}:
                        r = va if fa == "rate" else vb
                        m = vb if fb == "mean" else va
                        cnt, s = rate_mean.get((r, m), (0, 0.0))
                        return cnt, s
                    # diff/mean
                    if {fa, fb} == {"diff", "mean"}:
                        d = va if fa == "diff" else vb
                        m = vb if fb == "mean" else va
                        cnt, s = diff_mean.get((d, m), (0, 0.0))
                        return cnt, s
                    return 0, 0.0

                tautology_or_filtered = 0

                def _is_tautology_or(a, b) -> bool:
                    # a/b å½¢å¦‚ ('diff','6') / ('rate','å‡é€Ÿ') / ('mean','|å‡å·®|<3') ç­‰
                    try:
                        fa, va = a
                        fb, vb = b
                    except Exception:
                        return False
                    if fa != fb:
                        return False
                    if fa == "diff":
                        universe = {str(i) for i in range(0, 10)} | {"9+"}
                    elif fa == "rate":
                        universe = {"å‡é€Ÿ", "åŠ é€Ÿ", "æå€¼", "æ— æ•ˆ"}
                    elif fa == "mean":
                        universe = {"|å‡å·®|<3", "|å‡å·®|>=3", "mean=0", "æ— æ•ˆ"}
                    else:
                        return False
                    return {va, vb} == universe

                for i in range(len(singles)):
                    for j in range(i + 1, len(singles)):
                        a = singles[i]
                        b = singles[j]
                        if _is_tautology_or(a, b):
                            tautology_or_filtered += 1
                            continue
                        cnt_a, sum_a = _get_single(a)
                        cnt_b, sum_b = _get_single(b)
                        cnt_ab, sum_ab = _get_intersection(a, b)
                        cnt_or = cnt_a + cnt_b - cnt_ab
                        sum_or = sum_a + sum_b - sum_ab
                        _add(rows, "OR", _rule_id_or(a, b), cnt_or, sum_or)

                # ç»Ÿè®¡è¾“å‡ºï¼ˆA/B/C ä¸‰ç§ä¸»æ’åºï¼‰
                # é€€åŒ–è§„åˆ™è¿‡æ»¤ï¼šStop%è¿‡é«˜é€šå¸¸ç­‰ä»·â€œå…¨è¦†ç›–åœæ‰‹â€ï¼Œä¿¡æ¯é‡ä½ï¼ˆå¼€å‘æœŸå…ˆç›´æ¥è¿‡æ»¤ï¼‰
                RULESCAN_DEGEN_STOP_PCT = 0.99
                _deg_cnt = 0
                if rows:
                    for _r in rows:
                        if (_r.get("kind") == "OR") and (_r.get("stop_pct", 0.0) >= RULESCAN_DEGEN_STOP_PCT):
                            _deg_cnt += 1
                    if _deg_cnt:
                        rows = [_r for _r in rows if not ((_r.get("kind") == "OR") and (_r.get("stop_pct", 0.0) >= RULESCAN_DEGEN_STOP_PCT))]
                        print(f"ï¼ˆé€€åŒ–è§„åˆ™å·²è¿‡æ»¤ï¼š{_deg_cnt} æ¡ï½œé˜ˆå€¼ Stop%â‰¥{RULESCAN_DEGEN_STOP_PCT*100:.1f}%ï½œæ’çœŸORå·²è¿‡æ»¤ï¼š{tautology_or_filtered} æ¡ï¼‰")

                def _fmt_num(x: float, nd=2):
                    sign = "+" if x >= 0 else ""
                    return f"{sign}{x:.{nd}f}"

                def _print_top(title: str, key_fn):
                    top = sorted(rows, key=key_fn, reverse=True)[:RULESCAN_TOPN]
                    print("")
                    print(title)
                    if not top:
                        print("ï¼ˆæ— æ»¡è¶³ MinHit çš„å€™é€‰ï¼‰")
                        return
                    for r in top:
                        print(
                            f"{r['rule_id']}: Stop%={r['stop_pct']*100:.1f}%({r['hit']}/{Entry})ï¼Œ"
                            f"Î”Sum={_fmt_num(r['delta_sum'],2)}ï¼ŒÎ”Avg={_fmt_num(r['delta_avg'],4)}"
                        )

                _print_top("Topï¼ˆä¸»æ’åº=Î”Avgï¼‰", lambda r: r["delta_avg"])
                _print_top("Topï¼ˆä¸»æ’åº=Î”Sumï¼‰", lambda r: r["delta_sum"])
                _print_top("Topï¼ˆä¸»æ’åº=Stop%ï¼‰", lambda r: r["stop_pct"])
        # ==================== æŠ•æ”¾é“¾è·¯ END ====================

    print("============================================================")
    print("ğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°")
    print("============================================================")
    print(title)
    print("============================================================")
    # --- æ ¸å¿ƒç»“æœï¼ˆæ¯æ¬¡è·‘å¿…å‡ºï½œä¸ºç­–ç•¥å®˜/å†™æ‰‹çœ‹ç»“æœï¼‰ ---
    _struct_line, _struct_hash = _get_struct_summary_line_and_hash()
    print(_struct_line)
    print(f"AnchorMode={STRUCT_ANCHOR_MODE}")
    print("PreSW=LEADER_AS_TEMP | Tie=KEEP_LAST | Fallback=FIRST_VALID_WINNER | Switch=B1_RESET_TO_STEP1")
    print("T/0=SHIFT_ONLY_NO_BREAK")
    try:
        _fa = BOOT_FILTER_RULE.get("forbidden_action")
    except Exception:
        _fa = "NA"
    print(f"BOOT_FILTER={'ON' if BOOT_FILTER else 'OFF'} + forbidden_action={_fa}")
    _avg_pnl = (total_profit / total_entry) if total_entry else 0.0
    print(f"ğŸ’¶ğŸ’¶ğŸ’¶ å•æ¬¡å¹³å‡å¢ç›Š: {_avg_pnl:.6f}")
    print(f"ğŸ’¶ğŸ’¶ğŸ’¶ æ€»å‡€å€¼å¢ç›Š  : {total_profit:.2f}")

    if AUDIT_RUN:
        print("æ‰«ææ–¹å¼ï¼šä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“")
        print("æ®µé•¿å£å¾„ï¼šç¦æ­¢è·¨æ®µç´¯è®¡")
        print("æœ¯è¯­é”æ­»ï¼šåªæ‰¿è®¤ã€Œâ­ / æŠ•æ”¾ç‚¹ã€")
        _print_switches_block("HEADER")
        # è¡¨å¤´å¼€å…³è‡ªè¯ï¼ˆé”æ­»ï¼‰ï¼šå³ä½¿é™é»˜æ¨¡å¼ä¹Ÿå¿…é¡»æ‰“å°
        print("ç»“æ„é—¸é—¨ï¼šSTRUCT_SCAN=ONâœ…(ç»“æ„æ‰«æå¼€å¯)")
        print("é´çº§å¼€å…³ï¼šBOOT_FILTER=ONâœ…(ç¦ä¸‹æ³¨ seen_shift=1..8)")
        _sl, _sh = _get_struct_summary_line_and_hash()
        print(_sl)
        print(f"AnchorMode={STRUCT_ANCHOR_MODE}")
        print("PreSW=LEADER_AS_TEMP | Tie=KEEP_LAST | Fallback=FIRST_VALID_WINNER | Switch=B1_RESET_TO_STEP1")
        print("T/0=SHIFT_ONLY_NO_BREAK")
        print(f"BOOT_FILTER={'ON' if BOOT_FILTER else 'OFF'} + forbidden_action={BOOT_FILTER_RULE.get('forbidden_action','NA')}")
        global _STRUCT_SUMMARY_PRINTED
        _STRUCT_SUMMARY_PRINTED = True
        print(f"ç›‘æµ‹å¼€å…³ï¼š{'å¼€' if MONITOR_ENABLE else 'å…³'}")
        print("é˜ˆå€¼å‡»ç©¿å½’å› ï¼šè·¯å¾„å¿«ç…§ï¼ˆæ¯æ¬¡å®é™…æŠ•æ”¾å‰éƒ½å¿«ç…§ï¼›å«çŠ¶æ€ T åçš„é‡å¤æŠ•æ”¾ï¼›å½’å› åªç”¨å¿«ç…§ï¼‰")
        print("------------------------------------------------------------")
        print("TOTAL_BOOT       :", total_boots)
        print("------------------------------------------------------------")
        print("æ€»æ‰¹æ¬¡æ•°    :", total_boots)
        print("å¯å‚ä¸æ‰¹æ¬¡æ•°:", playable_boots)
        print("è·³è¿‡æ‰¹æ¬¡æ•°  :", skipped_boots)
        print("------------------------------------------------------------")
        entry_pct = (total_entry / total_boots * 100.0) if total_boots > 0 else 0.0
        print(f"æ¿€æ´»æ¬¡æ•°    : {total_entry} ({entry_pct:.2f}%)")
        match_pct = (total_match / total_entry * 100.0) if total_entry > 0 else 0.0
        mismatch_pct = (total_mismatch / total_entry * 100.0) if total_entry > 0 else 0.0
        print(f"åŒ¹é…æ¬¡æ•°    : {total_match} ({match_pct:.2f}%)")
        print(f"ä¸åŒ¹é…æ¬¡æ•°  : {total_mismatch} ({mismatch_pct:.2f}%)")

        # ==========================
        # æ­£å€¼è§¦å‘è‡ªå®¡ï¼ˆæ—¶é—´ç®¡ç†å±€ï½œé”æ­»ï½œåœ¨æœ€ç»ˆæ±‡æ€»æ‰“å°ä¹‹å‰ï¼‰
        # ==========================
        avg_profit = (total_profit / total_entry) if total_entry else 0.0
        trigger_total = bool(POSITIVE_AUDIT_TRIGGER_TOTAL and total_profit > 0)
        trigger_avg = bool(POSITIVE_AUDIT_TRIGGER_AVG and avg_profit > 0)

        # Stop/Zeroï¼ˆæœ¬æ¨¡æ¿å½“å‰æœªå¯ç”¨ï¼Œé”æ­»ä¸º 0ï¼Œä½†ä»å‚ä¸é—­ç¯ä¸è‡ªå®¡ï¼‰
        total_stop = 0
        total_zero = 0

        # æ’ç­‰å¼é—­ç¯ï¼ˆé”æ­»ï¼‰
        closure_diff = int(total_entry) - int(total_match + total_mismatch + total_exhaustion + total_stop + total_zero)

        final_metrics = {
            "total_profit": total_profit,
            "avg_profit": avg_profit,
            "entry": total_entry,
            "match": total_match,
            "mismatch": total_mismatch,
            "break": total_exhaustion,
            "stop": total_stop,
            "zero": total_zero,
            "bet_in_forbidden_seen": BET_IN_FORBIDDEN_SEEN,
            "ppbb_mismatch": PPBB_MISMATCH,
            "ppbb_first_evidence": PPBB_FIRST_EVIDENCE,
            "trigger_total": trigger_total,
            "trigger_avg": trigger_avg,
            "closure_diff": closure_diff,
        }

        if POSITIVE_AUDIT_ENABLE and (trigger_total or trigger_avg):
            SELF_AUDIT_GATE(final_metrics)


    _abn = []  # è‡ªè¯å¼‚å¸¸æ”¶é›†å™¨ï¼ˆä¿®å¤ NameErrorï¼‰
    def _abn0(name, val, expect=0):
        try:
            if val != expect:
                _abn.append((name, val, expect))
        except Exception:
            _abn.append((name, 'ERR', expect))
    _abn0('STAR_ON_T', STAR_ON_T)
    _abn0('STAR_DIFF0_AND_R_IN_BP', STAR_DIFF0_AND_R_IN_BP)
    _abn0('MEAN_MISSING_RAW', MEAN_MISSING_RAW)
    _abn0('MEAN_PARSE_FAIL', MEAN_PARSE_FAIL)
    _abn0('MEAN_INVALID_BUG(ç›®æ ‡=0)', MEAN_INVALID_BUG)
    
    # RATE æ— æ•ˆï¼šé 0 ä¸ç®—å¼‚å¸¸ï¼›ä»…åœ¨ä¸€è‡´æ€§å¤±è´¥æ—¶å¼¹å‡ºï¼ˆæ–­è¨€å·²è¦†ç›–ï¼Œä½†ä»ç•™ä¸€è¡Œæç¤ºï¼‰
    if RATE_INVALID_RAW != RATE_INVALID_BUCKET:
        _abn.append(('RATE_INVALID_MISMATCH', f'{RATE_INVALID_RAW}!={RATE_INVALID_BUCKET}', 'equal'))
    
    if PPBB_MISMATCH != 0:
        _abn.append(('PPBB_MISMATCH', PPBB_MISMATCH, 0))
    
    if _abn:
        print('è‡ªè¯å¼‚å¸¸ï¼ˆä»…å¼‚å¸¸å¼¹å‡ºï¼‰:')
        for name, val, exp in _abn:
            print(f'  {name}: {val} (æœŸæœ›={exp})')
    if PPBB_FIRST_EVIDENCE is not None:
        print("  PPBB_FIRST_EVIDENCE:", PPBB_FIRST_EVIDENCE)


    if cont_agg is not None:
        print()
        print("------------------------------------------------------------")
        print("è¿æ®µç»Ÿè®¡ï¼ˆåŒæŒ‡æ ‡ç›¸é‚»æ€ï½œäº‹åæ±‡æ€»ï¼‰")
        print("è¯´æ˜ï¼šä»…åŸºäºæŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨ï¼ˆå«çŠ¶æ€ T é‡å¤æŠ•æ”¾ï¼‰ï¼›æ ·æœ¬é‡ä¸è¶³ä¸è¾“å‡ºã€‚")
        print("é˜ˆå€¼ï¼šmin_samples=%dï½œTopK=%d" % (CONT_MIN_SAMPLES, CONT_TOPK))

        _print_top_transitions(
            "A) (|ç‚¹å·®|,rate ç›‘æµ‹æ¡¶) Overall Top",
            cont_agg["pair_rate_overall"],
            CONT_MIN_SAMPLES,
            CONT_TOPK,
        )
        _print_top_transitions(
            "B) (|ç‚¹å·®|,mean æ¡¶) Overall Top",
            cont_agg["pair_mean_overall"],
            CONT_MIN_SAMPLES,
            CONT_TOPK,
        )

        max_bn = min(int(cont_agg.get("max_bet_n_seen", 0) or 0), CONT_MAX_BET_N)
        for bn in range(2, max_bn + 1):
            tmp_rate = {}
            tmp_mean = {}
            if not isinstance(tmp_rate, dict):
                tmp_rate = {}
            if not isinstance(tmp_mean, dict):
                tmp_mean = {}
            for (bn2, a, b), v in cont_agg["pair_rate"].items():
                if bn2 == bn:
                    tmp_rate[(a, b)] = v
            for (bn2, a, b), v in cont_agg["pair_mean"].items():
                if bn2 == bn:
                    tmp_mean[(a, b)] = v

            _print_top_transitions(
                f"A) bet_n={bn} (|ç‚¹å·®|,rate ç›‘æµ‹æ¡¶) Top",
                tmp_rate,
                CONT_MIN_SAMPLES,
                min(10, CONT_TOPK),
            )
            _print_top_transitions(
                f"B) bet_n={bn} (|ç‚¹å·®|,mean æ¡¶) Top",
                tmp_mean,
                CONT_MIN_SAMPLES,
                min(10, CONT_TOPK),
            )

    
    # ç‰©ç†é”æ­»ï¼šå¿…é¡»æ‰“å°ä¸¤å¤„å¼€å…³ï¼Œå¦åˆ™ç›´æ¥ä½œåºŸ
    if not _PRINTED_SWITCHES_HEADER:
        raise RuntimeError("âŒ ç¼ºå¤±è¡¨å¤´å¼€å…³è‡ªè¯ï¼šBOOT_FILTER/STRUCT_SCAN æœªæ‰“å°")
    if not _PRINTED_SWITCHES_PROOF:
        raise RuntimeError("âŒ ç¼ºå¤±å¼ºåˆ¶è‡ªè¯å¼€å…³ï¼šBOOT_FILTER/STRUCT_SCAN æœªæ‰“å°")

# ğŸ€è¦†ç›–é”šç‚¹002_æŠ¥å‘Šæ±‡æ€»_END

def main():
    try:
        
        # é¦–å±æ°´å°ï¼ˆç¡¬é”æ­»ï¼‰
        print(WATERMARK_TEXT)
        print("BUILD_TAG: " + BUILD_TAG)
        global _WATERMARK_PRINTED
        _WATERMARK_PRINTED = True
        
        # ã€å¼ºåˆ¶è‡ªè¯è¾“å‡ºã€‘ï¼ˆç¡¬é”æ­»ï¼‰
        print("ã€å¼ºåˆ¶è‡ªè¯è¾“å‡ºã€‘")
        _print_switches_block("PROOF")
        # åŸºåº•èº«ä»½è¯ï¼ˆğŸ•çŸ­ç ï¼‰ï¼šå†»ç»“åŒºæŒ‡çº¹ï¼ˆCOREï¼‰å†³å®šï¼›æ’æ§½/è§„åˆ™å˜åŠ¨ä¸åº”å½±å“
        try:
            _compute_core_and_slot_fingerprints()
        except Exception:
            pass
        core8 = ((CORE_BASE_FINGERPRINT or "NA")[:8]).upper()
        slot8 = ((STRUCTURE_SLOT_FINGERPRINT or "NA")[:8]).upper()
        pizza = "ğŸ•" + core8[:4]
        print(f"åŸºåº•èº«ä»½è¯ï¼š{pizza} | CORE8={core8} | SLOT8={slot8}")
        print(f"BET_IN_FORBIDDEN_SEEN = {BET_IN_FORBIDDEN_SEEN} (0.00%)")
        print(f"PPBB_IDENTITY_CHECKED = {PPBB_CHECKED} | PPBB_MISMATCH = {PPBB_MISMATCH}")
        global _PROOF_BLOCK_PRINTED
        _PROOF_BLOCK_PRINTED = True
        
        # ç¡¬æ³¨å…¥è‡ªæ£€ï¼ˆå¿…é¡» raise é˜»æ–­ï¼Œä¸å¾—åé”™ï¼‰
        if not SILENT_MODE:
            print("=== æ­£åœ¨æ‰§è¡Œç¡¬æ³¨å…¥è‡ªæ£€ ===")
        try:
            # ç”¨ä¾‹Aï¼šTè¡Œå†™å¿«ç…§ -> å¿…é¡»é˜»æ–­âœ…
            _ = write_star_snapshot("DECISION", {"r": "T", "seen_all": 9, "diff": 1, "rate": "None", "mean": "None", "shoe_id": "SELFTEST"}, 0)
            raise RuntimeError("SELF_TEST_FAIL: T_SNAPSHOT_NOT_BLOCKED")
        except RuntimeError:
            pass
        
        try:
            # ç”¨ä¾‹Bï¼šéDECISIONè¯»æŒ‡æ ‡ -> å¿…é¡»é˜»æ–­âœ…
            tmp = Snapshot({"diff": 1, "rate": None, "mean": None, "rate_raw": "None", "mean_raw": "None"}, boot_id="SELFTEST", idx=0, seen_all=9, rr="B", source="STAR_ROW")
            _ = secure_read_metric(tmp, "diff", "EXECUTE", who="STAR", idx=0, boot_id="SELFTEST", seen_all=9)
            raise RuntimeError("SELF_TEST_FAIL: NON_DECISION_METRIC_NOT_BLOCKED")
        except RuntimeError:
            pass
        
        try:
            # ç”¨ä¾‹Cï¼šæ‰§è¡Œæ¨è¿›ä¸­è¯»å–æŒ‡æ ‡ï¼ˆé€šè¿‡ MetricGuardRowï¼‰-> å¿…é¡»é˜»æ–­âœ…
            g = MetricGuardRow({"r": "B", "diff": 1, "rate": 0.1, "mean": 1.0})
            _ = g.get("rate")
            raise RuntimeError("SELF_TEST_FAIL: EXECUTE_METRIC_NOT_BLOCKED")
        except RuntimeError:
            pass
        
        print("ç¡¬æ³¨å…¥éªŒè¯=é€šè¿‡âœ…")
        print("éæ³•æŒ‡æ ‡è®¿é—®æ¨¡æ‹Ÿ=å·²é˜»æ–­âœ…")
        print("Tè¡Œå†™å¿«ç…§=å·²é˜»æ–­âœ…")
        print("é˜»æ–­æ–¹å¼=raiseâœ…(æœªåé”™)")
        if not SILENT_MODE:
            print("=== è‡ªæ£€å®Œæˆ ===")
        global _SELFTEST_PASSED
        _SELFTEST_PASSED = True
        _audit_structure_slot_integrity()
        _audit_forbid_idx_offset()
        _print_source_hashes()
        csv_files = sorted([f for f in os.listdir(".") if f.lower().endswith(".csv")])
        if VERIFY_SPLIT_ENABLE and len(csv_files) >= 2:
            mid = len(csv_files) // 2
            _run_report(csv_files[:mid], "éªŒçœŸé˜¶æ®µï¼ˆå‰ 50%ï¼‰")
            _run_report(csv_files[mid:], "éªŒçœŸé˜¶æ®µï¼ˆå 50%ï¼‰")
        else:
            _run_report(csv_files, "ä¼˜åŒ–é˜¶æ®µï¼ˆå…¨é‡ï¼‰")
        
        # ğŸ“Œ æŠ½æ ·æ¢é’ˆè¾“å‡ºï¼ˆå†»ç»“åŒºï¼‰
        _sample_probe_emit()

    except GuardViolation as gv:
        _print_single_screen_error(gv)
        sys.exit(getattr(gv, 'exit_code', 2))
    except (AssertionError, ValueError, KeyError, TypeError) as e:
        gv = _as_guard_from_exception(e)
        _print_single_screen_error(gv)
        sys.exit(getattr(gv, 'exit_code', 2))
    except Exception as e:
        gv = _as_guard_from_exception(e)
        _print_single_screen_error(gv)
        sys.exit(getattr(gv, 'exit_code', 2))


# =========================
# è½»é‡è‡ªå®¡ï¼ˆä»…ç”¨äºâ€œå‡€å€¼è½¬æ­£â€æç¤ºï¼›ä¸æ›¿ä»£ AUDIT_RUN=1 ä¸¥æ ¼å®¡æŸ¥ï¼‰
# ç›®æ ‡ï¼šä¸ä¸­æ–­ä¼˜åŒ–æµç¨‹ï¼›ä»…æç¤ºå…³é”®é£é™©ï¼›ä¸¥ç¦é€’å½’è‡ªå®¡
# =========================
AUTO_SELF_AUDIT_ON_POSITIVE = True   # å‡€å€¼>0 æ—¶è§¦å‘ä¸€æ¬¡â€œè½»é‡è‡ªå®¡æç¤ºâ€
IN_SELF_AUDIT = False               # é˜²é‡å…¥

def _get_total_pnl_for_self_audit():
    """
    å…¼å®¹ä¸åŒæ¨¡æ¿å˜é‡åï¼šå°½é‡è¯»å–â€œæ€»å‡€å€¼/æ€»åˆ©æ¶¦â€ã€‚
    æ‰¾ä¸åˆ°åˆ™è¿”å› Noneï¼ˆä¸è§¦å‘è‡ªå®¡ï¼‰ã€‚
    """
    for k in ("TOTAL_PNL", "total_pnl", "TOTAL_PROFIT", "total_profit", "profit_total", "NET_TOTAL", "net_total"):
        if k in globals():
            v = globals().get(k)
            try:
                return float(v)
            except Exception:
                return None
    return None

def _self_audit_light():
    """
    è½»é‡è‡ªå®¡ï¼š
    - åªåšâ€œå¿…é¡»ç«‹å³ä¸­æ–­â€çš„è‡´å‘½é¡¹ + è‹¥å¹²æç¤ºé¡¹
    - é»˜è®¤ä¸å½±å“ä¸»æµç¨‹ï¼ˆé™¤éè‡´å‘½é¡¹è¢«è§¦å‘ï¼‰
    """
    # è‡´å‘½é¡¹ï¼šç¦ä¸‹æ³¨åŒºå‡ºç°çœŸå®è½æ³¨ï¼ˆå¿…é¡»ä¸­æ–­ï¼Œé¿å…ç»“æœä¸å¯ç”¨ï¼‰
    bet_forbidden = globals().get("BET_IN_FORBIDDEN_SEEN", 0)
    try:
        bet_forbidden = int(bet_forbidden)
    except Exception:
        bet_forbidden = 0

    if bet_forbidden > 0:
        raise RuntimeError(f"BET_IN_FORBIDDEN_SEEN>0ï¼ˆ={bet_forbidden}ï¼‰â€”â€”ç¦ä¸‹æ³¨åŒºå‘ç”ŸçœŸå®è½æ³¨ï¼Œç»“æœä½œåºŸ")

    # æç¤ºé¡¹ï¼šåªåšâ€œå­˜åœ¨æ€§â€æç¤ºï¼Œä¸åšä¸¥æ ¼å£å¾„åˆ¤æ­»
    hints = []
    if globals().get("STRUCT_SCAN", None) is not None and (globals().get("STRUCT_SCAN") is False):
        hints.append("STRUCT_SCAN=OFF")
    if globals().get("BOOT_FILTER", None) is not None and (globals().get("BOOT_FILTER") is False):
        hints.append("BOOT_FILTER=OFF")

    # æ’ç­‰å¼é—­ç¯æç¤ºï¼ˆè‹¥å­˜åœ¨è¿™äº›è®¡æ•°å™¨æ‰æ£€æŸ¥ï¼‰
    entry = globals().get("total_entry", None)
    match = globals().get("total_match", None)
    mismatch = globals().get("total_mismatch", None)
    exhaustion = globals().get("total_exhaustion", None)
    stop = globals().get("total_stop", None)
    zero = globals().get("total_zero", None)

    try:
        if entry is not None:
            entry_i = int(entry)
            parts = []
            for v in (match, mismatch, exhaustion, stop, zero):
                if v is not None:
                    parts.append(int(v))
            if parts:
                if entry_i != sum(parts):
                    hints.append("æ’ç­‰å¼ä¸é—­ç¯ï¼ˆEntryâ‰ åˆ†æ”¯æ€»å’Œï¼‰")
    except Exception:
        # è½»é‡è‡ªå®¡ä¸å› è§£æå¤±è´¥æ‰“æ–­
        pass

    # è¾“å‡ºï¼šä¸€è¡Œæç¤ºï¼Œä¸åˆ·å±
    if hints:
        print("ã€è½»é‡è‡ªå®¡ã€‘âš ï¸ æç¤ºï¼š", " / ".join(hints))
    else:
        print("ã€è½»é‡è‡ªå®¡ã€‘âœ… é€šè¿‡ï¼ˆè½»é‡ï¼‰")

def _auto_self_audit_after_run():
    """
    ä»…åœ¨â€œéä¸¥æ ¼å®¡æŸ¥è·‘â€ä¸”å‡€å€¼>0 æ—¶è§¦å‘ä¸€æ¬¡è½»é‡è‡ªå®¡æç¤ºã€‚
    """
    global IN_SELF_AUDIT
    if IN_SELF_AUDIT:
        return
    if globals().get("AUDIT_RUN", 0) == 1:
        return
    if not globals().get("AUTO_SELF_AUDIT_ON_POSITIVE", False):
        return

    pnl = _get_total_pnl_for_self_audit()
    if pnl is None:
        return
    if pnl <= 0:
        return

    IN_SELF_AUDIT = True
    try:
        _self_audit_light()
    finally:
        IN_SELF_AUDIT = False

if __name__ == "__main__":
    main()
    _auto_self_audit_after_run()
