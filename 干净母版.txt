# ğŸ›¡ï¸ğŸ›¡ï¸ğŸ›¡ï¸
# -*- coding: utf-8 -*-
"""
å¹²å‡€æ¯ç‰ˆï½œæ¼”ç»ƒå¼•æ“ï¼ˆV4ï½œåºåˆ—é•¿åº¦å£å¾„ï½œè‡ªåœï½œä¸€æ¬¡æ€§æ‰«æï½œä¸‰å£æœ¯è¯­ç»Ÿä¸€ï½œæœªæ¥æ•°å°å£ï¼‰
============================================================
ç”¨é€”ï¼šæä¾›ä¸€ä»½å¯å¤åˆ¶çš„å¹²å‡€æ¯ç‰ˆï¼Œç”¨äºä»¥åæ‰€æœ‰ç­–ç•¥å¼€å‘ä¸æ¼”ç»ƒã€‚
ç¡¬è§„åˆ™æ‘˜è¦ï¼š
- åªè¯»ä¸ç®—ï¼šç‚¹å·®/å˜åŒ–ç‡/å‡å·®åªè¯» CSV åŸå€¼ï¼Œä¸åœ¨è„šæœ¬å†…é‡ç®—
- ä¸¥æ ¼é›¶æœªæ¥ï¼šä»»æ„ç´¢å¼• idx æ—¶ï¼Œåªèƒ½ä½¿ç”¨ 0..idx è¡Œåšåˆ¤æ–­
- æœ¯è¯­é”æ­»ï¼šåªä¿ç•™ã€Œâ­ / æŠ•æ”¾ç‚¹ã€ï¼ˆç¨‹åºå†…éƒ¨è¡Œæ¨è¿›ä¸ç»“ç®—ä¸å¯¹å¤–å‘½åï¼‰
- å‰ 9 å£æ•´æ‰¹æ¬¡ç¦ç”¨ï¼šåªçœ‹å‰ 9 å£ï¼›åŒæ–¹æœ€å¤§åºåˆ—é•¿åº¦éƒ½ >=3 -> æ•´æ‰¹æ¬¡ç¦ç”¨
- è‡ªåœï¼šæ‰«æä»æ‰¹æ¬¡é¦–å¼€å§‹ï¼›ä¸€æ—¦ä¸¤è¾¹éƒ½æ›¾å‡ºç°åºåˆ—é•¿åº¦ >=3 -> ç«‹å³ç»“æŸæœ¬æ‰¹æ¬¡æ‰«æ
- æ‰«ææ–¹å¼ï¼šå½»åº•ä¸€æ¬¡æ€§ï¼ˆæ¯æ‰¹æ¬¡æœ€å¤š 1 æ¬¡æŠ•æ”¾ï¼‰ï¼›ç¦ç”¨æŒç»­æ‰«æä¸ 2 æ¬¡æŠ•æ”¾æœºä¼š
"""

import csv
import os
from collections import defaultdict

# è¡¨å¤´è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡
_HEADER_MAPPING_PRINTED = False


SCAN_MODE_LOCKED = "ä¸€æ¬¡æ€§æ‰«æ"
MONITOR_ENABLE = 0  # ç›‘æµ‹å¼€å…³ï¼š0=å…³ï¼›1=å¼€ï¼ˆåŠ¨æ€ç›‘æµ‹/åŠ¨æ€æ­¢æŸï¼‰
# å¤šæ¬¡å†³ç­–ï¼ˆåŠ¨æ€ç›‘æµ‹/åŠ¨æ€æ­¢æŸï½œé”æ­»ï¼‰ï¼šåŒä¸€ç¬”äº¤æ˜“å†…ï¼Œæ¯ä¸€æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘å…è®¸åšä¸€æ¬¡â€œç»§ç»­/STOPâ€å†³å®šï¼›
# å†³ç­–æ—¶åˆ»è§†ä¸ºä¸€æ¬¡â€œæŠ•æ”¾ç‚¹â€ï¼Œåªå…è®¸è¯»å–è¯¥è¡ŒåŠå†å²æŒ‡æ ‡ï¼›ä¸¥ç¦ä½¿ç”¨è¯¥å†³ç­–å£ä¹‹åï¼ˆt+1 åŠä»¥åï¼‰çš„ä»»ä½•ä¿¡æ¯ã€‚
VERIFY_SPLIT_ENABLE = 0  # éªŒçœŸåˆ†æ‹†å¼€å…³ï¼š0=å…³ï¼›1=å¼€ï¼ˆæ–‡ä»¶åæ’åºå‰ 50%/å 50%ï¼‰


# æ³¨ä½å¿«ç…§ç»Ÿè®¡ï¼ˆL2/L3/L4 å„æ³¨ä½å¿«ç…§ï½œé”æ­»ï¼‰
# - åªåšâ€œäº‹åç»Ÿè®¡â€ï¼šä»…åŸºäºã€æŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨ã€‘åšåˆ†å¸ƒï¼›ç¦æ­¢å›è¯» recordsï¼›ç¦æ­¢â€œç›¸é‚»å¯¹æ¯”â€ç±»ç»Ÿè®¡
# - å–å€¼å£ï¼šæ¯æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘å¿«ç…§ï¼ˆå«çŠ¶æ€ T å¯¼è‡´åŒæ³¨é‡å¤æŠ•æ”¾å‰çš„æ¯ä¸€æ¬¡ï¼‰
# - è§‚æµ‹ç›®æ ‡ï¼šç”¨äº STOP ç”»åƒå€™é€‰ï¼Œä¸å¾—å‚ä¸æ¿€æ´»åˆ¤å®šï¼ˆæ¿€æ´»å±‚å¿…é¡»å¯ç‹¬ç«‹è¿è¡Œï¼‰
CONT_STATS_ENABLE = 1
CONT_N_MAX = 12          # åªå±•å¼€å‰ N æ¬¡å®é™…æŠ•æ”¾ï¼ˆå«çŠ¶æ€ T é‡å¤æŠ•æ”¾ï¼‰ï¼›å…¶ä½™åˆå¹¶åˆ° N+ 
CONT_MIN_COUNT = 500     # ä½äºè¯¥æ¬¡æ•°çš„æ ¼å­ä¸å‚ä¸è¾“å‡ºï¼Œé¿å…å™ªå£°
CONT_TOPK = 10           # æ¯ä¸ªä½æ¬¡æœ€å¤šè¾“å‡º TopKï¼ˆæ¡¶æ•°å¾ˆå°‘æ—¶ä¼šè¾“å‡ºå…¨æ¡¶ï¼‰


# ============================================================
# ç»Ÿä¸€ä»£ç æ¨¡æ¿ï¼ˆV4ï¼Œåºåˆ—é•¿åº¦å£å¾„ï½œä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§æŠ•æ”¾ï¼‰
# çº¦æŸï¼š
# 1) åªè¯»å–å½“å‰ç›®å½•ä¸‹æ‰€æœ‰ .csv
# 2) ä¸å†™æ­»ä»»ä½•ç»å¯¹è·¯å¾„
# 3) è‡ªåŠ¨è¯†åˆ«æ‰¹æ¬¡åˆ—/ç»“æœ/ç‚¹å·®/å˜åŒ–ç‡/å‡å·®
# 4) ç»“æœå¿…é¡»æ˜ å°„ä¸º B/P/T
# 5) ä¸¥æ ¼é›¶æœªæ¥ï¼šrun_strategy_on_boot å†…ä¸¥ç¦è®¿é—®æœªæ¥è¡Œ
# 6) â€œä¸‹ä¸€å£/ä¸‹ä¸€è¡Œâ€ç»Ÿä¸€å®šä¹‰ï¼šidx+1ï¼ˆä¸è·³è¿‡çŠ¶æ€ Tï¼‰
# 7) å•è¾¹/åŒè¾¹ï¼šå‰ 9 å£åˆ†ç±»ï¼›å•è¾¹å¼±ç´¯è®¡ >=3 è½¬åŒè¾¹ï¼›äº¤æ˜“æ¬¡æ•°é™åˆ¶è§æ¨¡æ¿æ–‡æ¡£
#
# æ³¨æ„ï¼šæœªæ¥æ–°å¢/ä¿®æ”¹ç­–ç•¥ï¼Œåªæ”¹ run_strategy_on_boot(records) å†…éƒ¨é€»è¾‘
# ============================================================

# ============================================================
# ç»“æœæ˜ å°„è¡¨ï¼šå·²å®Œæˆ BPT å…¨é˜¶è„±æ•ï¼Œç‰©ç†åŒ¹é…å®éªŒå®¤æ ‡å‡†åŒ– CSV
# ============================================================
MAP_RESULT = {"B": "B", "P": "P", "T": "T"}



def map_result(v):
    if v is None:
        return None
    s = str(v).strip()
    if s in MAP_RESULT:
        return MAP_RESULT[s]
    s2 = s.upper()
    if s2 in MAP_RESULT:
        return MAP_RESULT[s2]
    return None

# ------------------------------------------------------------
# å·¥å…·ï¼šå®‰å…¨è¯»å– float / intï¼ˆåªè¯»ï¼Œä¸è®¡ç®—ï¼‰
# ------------------------------------------------------------
def safe_float(v, default=None):
    try:
        if v is None or v == "":
            return default
        return float(v)
    except Exception:
        return default

def safe_int(v, default=0):
    try:
        if v is None or v == "":
            return default
        return int(float(v))
    except Exception:
        return default

# ------------------------------------------------------------
# 1) æ•°æ®åŠ è½½ï¼ˆå›ºå®šï¼‰
# ------------------------------------------------------------
def load_all_boots(csv_files):
    boots = defaultdict(list)
    print("æ£€æµ‹åˆ° CSV æ–‡ä»¶æ•°é‡:", len(csv_files))

    for i, fname in enumerate(csv_files, 1):
        if i % 10 == 0:
            print(f"è¿›åº¦: å·²å¤„ç† {i}/{len(csv_files)} ä¸ªæ–‡ä»¶")

        rows = []
        for enc in ("utf-8", "utf-8-sig", "gbk", "gb18030"):
            try:
                with open(fname, "r", encoding=enc) as f:
                    rows = list(csv.DictReader(f))
                break
            except Exception:
                rows = []

        if not rows:
            continue

        col_shoe, col_result, col_diff, col_rate, col_mean = detect_columns(rows[0])

        _print_header_mapping_once(rows[0], (col_shoe, col_result, col_diff, col_rate, col_mean))
        for r in rows:
            shoe = r.get(col_shoe)
            if shoe is None:
                continue

            res = map_result(r.get(col_result))
            if res not in ("B", "P", "T"):
                continue

            diff = safe_int(r.get(col_diff, 0), 0)
            rate = safe_float(r.get(col_rate), None) if col_rate else None
            mean = safe_float(r.get(col_mean), None) if col_mean else None

            boots[shoe].append({"r": res, "diff": diff, "rate": rate, "mean": mean})

    print("æŒ‰æ‰¹æ¬¡åˆ†ç»„å®Œæˆï¼Œæ‰¹æ¬¡æ€»æ•°:", len(boots))
    return boots


def _run_report(csv_files, title):
    # ============================================================
    # ç‰©ç†å®šä½é”šç‚¹ï¼šäº¤ä»˜éªŒæ”¶æ°´å°ï¼ˆé”æ­»ï½œå”¯ä¸€æœç´¢å®šä½ï¼‰
    # ============================================================
    print("ğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°") 
    
    boots = load_all_boots(csv_files)

    total_boots = len(boots)
    playable = 0
    skipped = 0
    insufficient9 = 0
    unplayable = 0

    total_entry = 0
    total_win = 0
    total_lose = 0
    total_bust = 0
    total_profit = 0.0

    cont_stats = init_cont_stats() if (MONITOR_ENABLE and CONT_STATS_ENABLE) else None


    for _, rec in boots.items():
        info = classify_boot_first9(rec)
        if not info["seen9_ok"]:
            insufficient9 += 1
            continue
        if not info["playable"]:
            unplayable += 1
            continue
        playable += 1

        out = run_strategy_on_boot(rec)

        if cont_stats is not None:
            update_cont_stats(cont_stats, out.get('snapshots', []), int(out.get('bust', 0)) > 0)

        total_entry += int(out.get("entry", 0))
        total_win += int(out.get("win", 0))
        total_lose += int(out.get("lose", 0))
        total_bust += int(out.get("bust", 0))
        total_profit += float(out.get("profit", 0.0))

    total_seen = insufficient9 + unplayable + playable
    skipped = insufficient9 + unplayable

    print() 
    print("============================================================")
    print(title)
    print("============================================================")
    print("æŠ•æ”¾ç‚¹: â­")
    print(f"ç›‘æµ‹å¼€å…³  : {'å¼€' if MONITOR_ENABLE else 'å…³'}")
    print(f"æ‰«ææ–¹å¼  : {SCAN_MODE_LOCKED}")
    print("------------------------------------------------------------")
    print("æ€»æ‰¹æ¬¡æ•°    :", total_seen)
    print("å¯å‚ä¸æ‰¹æ¬¡æ•°:", playable)
    print("è·³è¿‡æ‰¹æ¬¡æ•°  :", skipped)
    print("------------------------------------------------------------")
    print("æ¿€æ´»æ¬¡æ•°    :", total_entry)
    print("åŒ¹é…æ¬¡æ•°    :", total_win)
    print("ä¸åŒ¹é…æ¬¡æ•°  :", total_lose)
    print("é˜ˆå€¼å‡»ç©¿æ¬¡æ•°:", total_bust)
    if total_entry > 0:
        match_rate = total_win / total_entry * 100
        exhaustion_rate = total_bust / total_entry * 100
        print(f"åŒ¹é…ç‡      : {match_rate:.2f}%")
        print(f"é˜ˆå€¼å‡»ç©¿ç‡  : {exhaustion_rate:.2f}%")
        print(f"å•æ¬¡å¹³å‡å¢ç›Š: {total_profit / total_entry:.4f}")
    print(f"æ€»å‡€å€¼å¢ç›Š  : {total_profit:.2f}")

    if cont_stats is not None:
        print_cont_stats(cont_stats)



def main():
    _audit_forbid_idx_offset()
    csv_files = sorted([f for f in os.listdir(".") if f.lower().endswith(".csv")])
    if VERIFY_SPLIT_ENABLE and len(csv_files) >= 2:
        mid = len(csv_files) // 2
        _run_report(csv_files[:mid], "éªŒçœŸé˜¶æ®µï¼ˆå‰50%ï¼‰")
        _run_report(csv_files[mid:], "éªŒçœŸé˜¶æ®µï¼ˆå50%ï¼‰")
    else:
        _run_report(csv_files, "ä¼˜åŒ–é˜¶æ®µï¼ˆå…¨é‡ï¼‰")





# ------------------------------------------------------------
# 2) åˆ—è‡ªåŠ¨è¯†åˆ«ï¼ˆå›ºå®šï¼‰
# ------------------------------------------------------------
def _norm_key(k):
    return str(k).strip().lower() if k is not None else ""

def _first_hit(keys, candidates):
    key_norm = { _norm_key(k): k for k in keys }
    for c in candidates:
        cc = _norm_key(c)
        if cc in key_norm:
            return key_norm[cc]
    return None

def detect_columns(row0):
    """
    è¾“å…¥ï¼šrow0ï¼ˆDictReader è¯»åˆ°çš„ä¸€è¡Œ dictï¼‰
    è¾“å‡ºï¼šcol_shoe, col_result, col_diff, col_rate, col_mean
    ç›®æ ‡ï¼šä¸€æ¬¡æ€§è§£å†³ä½ ç°æœ‰ CSV çš„å¤šç§è¡¨å¤´ï¼ˆå« 2=å˜åŒ–ç‡ã€M3=å‡å·®ã€Exhaustion=B/P/Tã€BB/PP ç­‰ï¼‰ã€‚
    """
    keys = list(row0.keys()) if isinstance(row0, dict) else []

    # é´å·ï¼ˆè‹¥æ²¡æœ‰ï¼Œå…è®¸é€€åŒ–åˆ°å±€å·ï¼‰
    col_shoe = _first_hit(keys, ["é´", "é´å·", "shoe", "Shoe", "æœ¬é´", "æœ¬é´é´å·", "å…¨å±€é´å·", "æœ¬å·é´å·"])
    if col_shoe is None:
        col_shoe = _first_hit(keys, ["å±€å·", "hand", "Hand", "round", "Round"])
    if col_shoe is None and keys:
        col_shoe = keys[0]

    # ç»“æœåˆ—ï¼šä½ æ•°æ®å¸¸è§ Exhaustionï¼ˆå€¼ä¸ºB/P/Tï¼‰
    col_result = _first_hit(keys, ["Exhaustion", "exhaustion", "ç»“æœ", "result", "Result", "Outcome", "outcome"])

    # ç‚¹å·®/å˜åŒ–ç‡/å‡å·®ï¼ˆæ”¯æŒ 2/M3ï¼‰
    col_diff = _first_hit(keys, ["ç‚¹å·®", "diff", "Diff", "spread", "Spread", "delta", "Delta"])
    col_rate = _first_hit(keys, ["å˜åŒ–ç‡", "rate", "Rate", "roc", "ROC", "r", "R", "2"])
    col_mean = _first_hit(keys, ["å‡å·®", "mean", "Mean", "avg", "Avg", "average", "Average", "M3", "m3"])

    return col_shoe, col_result, col_diff, col_rate, col_mean

def _print_header_mapping_once(row0, cols):
    """è¡¨å¤´è¯†åˆ«è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡ï¼›ç»ä¸å½±å“ä¸»æµç¨‹ã€‚"""
    global _HEADER_MAPPING_PRINTED
    if _HEADER_MAPPING_PRINTED:
        return
    _HEADER_MAPPING_PRINTED = True

    try:
        sample_row = row0 if isinstance(row0, dict) else {}
        keys = list(sample_row.keys())

        # æ¸…ç†è¡¨å¤´é”®ï¼šå» BOMã€å»é¦–å°¾ç©ºæ ¼ï¼ˆä¸ä¿®æ”¹åŸæ•°æ®ï¼Œåªç”¨äºåŒ¹é…ï¼‰
        norm_map = {}
        for k in keys:
            if isinstance(k, str):
                kk = k.lstrip("\ufeff").strip()
            else:
                kk = k
            norm_map[kk] = k
        norm_keys = list(norm_map.keys())

        def pick(cands):
            # 1:1 ç‰©ç†åŒ¹é…ï¼ˆä¼˜å…ˆåŸé”®ï¼‰
            for c in cands:
                if c in sample_row:
                    return c
            # 1:1 ç‰©ç†åŒ¹é…ï¼ˆæ¸…ç†åé”®ï¼‰
            for c in cands:
                if c in norm_map:
                    return norm_map[c]
            # æ¨¡ç³ŠåŒ¹é…ï¼ˆæ¸…ç†åé”®ï¼‰
            for k in norm_keys:
                for c in cands:
                    if isinstance(k, str) and isinstance(c, str) and (c.lower() in k.lower()):
                        return norm_map.get(k, k)
            return None

        # cols æ˜¯ detect_columns ä¼ å…¥çš„ç»“æœï¼›è‹¥ä¸º None åˆ™å›é€€æ¨æ–­
        col_shoe, col_result, col_diff, col_rate, col_mean = cols

        # å…œåº•æ¨æ–­ï¼šåªåœ¨ç¼ºå¤±æ—¶è¡¥
        if col_shoe is None:   col_shoe = pick(["å±€å·", "hand", "Hand", "No", "no", "shoe", "é´å·", "é´"])
        if col_result is None: col_result = pick(["Exhaustion", "ç»“æœ", "result", "Result", "r", "R"])
        if col_diff is None:   col_diff = pick(["ç‚¹å·®", "diff", "Diff", "spread", "Spread"])
        if col_rate is None:   col_rate = pick(["å˜åŒ–ç‡", "rate", "Rate", "2", "R2"])
        if col_mean is None:   col_mean = pick(["å‡å·®", "mean", "Mean", "M3", "m3", "avg", "Avg"])

        print("==================================================")
        print("è¡¨å¤´è¯†åˆ«ï¼ˆè‡ªè¯ï½œä¸€æ¬¡æ€§æ‰“å°ï¼‰")
        print("é´ ->", col_shoe)
        print("ç»“æœ ->", col_result)
        print("ç‚¹å·® ->", col_diff)
        print("å˜åŒ–ç‡ ->", col_rate)
        print("å‡å·® ->", col_mean)

        # æ ·ä¾‹è¡Œï¼šåªå±•ç¤ºå‰12ä¸ªé”®
        d = {}
        show_keys = list(sample_row.keys())[:12]
        for k in show_keys:
            d[k] = sample_row.get(k)
        print("æ ·ä¾‹è¡Œ(åŸå§‹):", d)
        print("==================================================")
    except Exception as e:
        # åªè¦ä¸»æµç¨‹èƒ½è·‘ï¼Œè‡ªè¯å¤±è´¥ä¸å½±å“æ‰§è¡Œ
        print("âš  è¡¨å¤´è‡ªè¯æ‰“å°å¤±è´¥ï¼ˆä¸å½±å“è¿è¡Œï¼‰:", str(e))

def classify_boot_first9(records):
    seen = 0
    max_len = {"B": 0, "P": 0}
    cur_side = None
    cur_len = 0

    for row in records:
        if seen >= 9:
            break
        r = row.get("r")
        if r not in ("B", "P", "T"):
            continue
        seen += 1

        if r == "T":
            # çŠ¶æ€ T ä½ç§»é›¶åå·®ä¸”ä¸æ‰“æ–­åºåˆ—é•¿åº¦
            continue

        if cur_side is None:
            cur_side = r
            cur_len = 1
        elif r == cur_side:
            cur_len += 1
        else:
            max_len[cur_side] = max(max_len[cur_side], cur_len)
            cur_side = r
            cur_len = 1

        max_len[cur_side] = max(max_len[cur_side], cur_len)

    seen9_ok = (seen >= 9)
    playable = True
    if seen9_ok and (max_len["B"] >= 3 and max_len["P"] >= 3):
        playable = False

    return {
        "seen9_ok": seen9_ok,
        "playable": playable,
        "max_len_B": max_len["B"],
        "max_len_P": max_len["P"],
    }



# ------------------------------------------------------------
# ------------------------------------------------------------
# 4) æ³¨ä½å¿«ç…§ç»Ÿè®¡ï¼ˆL2/L3/L4ï½œäº‹åç»Ÿè®¡æ¨¡å—ï¼‰
# - åªè¯»å¿«ç…§ï¼Œä¸å›è¯» records
# - ä»…åšâ€œå„æ³¨ä½å¿«ç…§åˆ†æ¡¶åˆ†å¸ƒâ€ï¼ˆä¸åšç›¸é‚»å¯¹æ¯”ï¼‰
# - ç”¨é€”ï¼šç”¨äº STOP ç”»åƒå€™é€‰ï¼›ä¸å¾—å‚ä¸æ¿€æ´»åˆ¤å®š
#
# åˆ†æ¡¶å£å¾„ï¼ˆé”æ­»ï¼‰ï¼š
# 1) å˜åŒ–ç‡ï¼šå‡é€Ÿ(rate<0) / åŠ é€Ÿ(0<=rate<2) / æå€¼(rate>=2) / æ— æ•ˆ
# 2) |å‡å·®|ï¼š<3 / â‰¥3 / æ— æ•ˆ
# 3) |ç‚¹å·®|ï¼šä¸»åˆ†å¸ƒ=1..9ï¼›çº é”™è®¡æ•°=|diff|=0 ä¸ 9+ åˆå¹¶ï¼ˆä¸è¿›å…¥1..9åˆ†å¸ƒï¼‰
# ------------------------------------------------------------
def _bucket_abs_diff_monitor(diff):
    try:
        v = abs(int(diff))
    except Exception:
        v = 0

    if v == 0 or v >= 10:
        return "çº é”™"  # |diff|=0 ä¸ 9+ åˆå¹¶è®¡æ•°
    if 1 <= v <= 9:
        return str(v)
    return "çº é”™"


def _bucket_rate_monitor(rate):
    if rate is None:
        return "æ— æ•ˆ"
    try:
        v = float(rate)
    except Exception:
        return "æ— æ•ˆ"
    if v < 0:
        return "å‡é€Ÿ"
    if v < 2:
        return "åŠ é€Ÿ"
    return "æå€¼"


def _bucket_abs_mean_monitor(mean):
    if mean is None:
        return "æ— æ•ˆ"
    try:
        v = float(mean)
    except Exception:
        return "æ— æ•ˆ"
    if abs(v) >= 3:
        return "â‰¥3"
    return "<3"


def init_cont_stats():
    return {
        "rate": defaultdict(lambda: {"cnt": 0, "bust": 0}),
        "mean": defaultdict(lambda: {"cnt": 0, "bust": 0}),
        "diff": defaultdict(lambda: {"cnt": 0, "bust": 0}),
        "meta": {"snap_total": 0, "boot_with_snap": 0, "MEAN_INVALID_BUG": 0},
    }


def update_cont_stats(cont_stats, snapshots, bust_flag):
    # snapshots: list[dict]ï¼Œæ¯æ¡è‡³å°‘åŒ…å« bet_no/diff/rate/mean
    if not snapshots:
        return

    cont_stats["meta"]["boot_with_snap"] += 1
    cont_stats["meta"]["snap_total"] += len(snapshots)

    for i, s in enumerate(snapshots, 1):
        n = safe_int(s.get("bet_no", i), i)
        n_label = n if n <= CONT_N_MAX else f"{CONT_N_MAX}+"

        d_bucket = _bucket_abs_diff_monitor(s.get("diff", 0))
        r_bucket = _bucket_rate_monitor(s.get("rate", None))
        m_bucket = _bucket_abs_mean_monitor(s.get("mean", None))

        # çº é”™ï¼šmean æ— æ•ˆè®¡å…¥ MEAN_INVALID_BUG
        if m_bucket == "æ— æ•ˆ":
            cont_stats["meta"]["MEAN_INVALID_BUG"] += 1

        k_rate = (n_label, r_bucket)
        k_mean = (n_label, m_bucket)
        k_diff = (n_label, d_bucket)

        cont_stats["rate"][k_rate]["cnt"] += 1
        cont_stats["mean"][k_mean]["cnt"] += 1
        cont_stats["diff"][k_diff]["cnt"] += 1
        if bust_flag:
            cont_stats["rate"][k_rate]["bust"] += 1
            cont_stats["mean"][k_mean]["bust"] += 1
            cont_stats["diff"][k_diff]["bust"] += 1


def _print_dist_block(title, bucket_dict, ordered_buckets):
    print()
    print("------------------------------------------------------------")
    print(title)
    print("ï¼ˆæ³¨ä½å¿«ç…§åˆ†æ¡¶åˆ†å¸ƒï½œä»…äº‹åç»Ÿè®¡ï½œåªè¯»å¿«ç…§ï½œç”¨äº STOP ç”»åƒå€™é€‰ï¼‰")
    print("------------------------------------------------------------")

    groups = defaultdict(list)
    for k, v in bucket_dict.items():
        n_label = k[0]
        groups[n_label].append((k, v))

    def n_sort(x):
        if isinstance(x, int):
            return (0, x)
        return (1, 10**9)

    for n_label in sorted(groups.keys(), key=n_sort):
        items = groups[n_label]
        # è¿‡æ»¤ä½æ ·æœ¬
        items = [it for it in items if it[1]["cnt"] >= CONT_MIN_COUNT]
        if not items:
            continue

        # å›ºå®šæ¡¶é¡ºåºè¾“å‡ºï¼ˆä¾¿äºäººå·¥æ¯”å¯¹ï¼‰
        m = {it[0][1]: it[1] for it in items}
        print(f"[ç¬¬{n_label}æ¬¡æŠ•æ”¾]ï¼ˆæ¬¡æ•°>= {CONT_MIN_COUNT}ï¼‰")
        for b in ordered_buckets:
            v = m.get(b)
            if not v:
                continue
            cnt = v["cnt"]
            bust = v["bust"]
            er = (bust / cnt * 100) if cnt else 0.0
            print(f"  {b}  æ¬¡æ•°={cnt}  é˜ˆå€¼å‡»ç©¿={bust}  é˜ˆå€¼å‡»ç©¿ç‡={er:.2f}%")

        # è‹¥å­˜åœ¨æœªåˆ—å…¥ ordered_buckets çš„æ¡¶ï¼ˆç†è®ºä¸åº”æœ‰ï¼‰ï¼Œè¿½åŠ è¾“å‡º
        extra = [bk for bk in m.keys() if bk not in ordered_buckets]
        if extra:
            for b in sorted(extra):
                v = m[b]
                cnt = v["cnt"]
                bust = v["bust"]
                er = (bust / cnt * 100) if cnt else 0.0
                print(f"  {b}  æ¬¡æ•°={cnt}  é˜ˆå€¼å‡»ç©¿={bust}  é˜ˆå€¼å‡»ç©¿ç‡={er:.2f}%")


def print_cont_stats(cont_stats):
    if not CONT_STATS_ENABLE:
        return
    if cont_stats is None:
        return
    if cont_stats["meta"]["boot_with_snap"] <= 0:
        return

    # å›ºå®šè‡ªè¯è¾“å‡º
    print()
    print("------------------------------------------------------------")
    print("è‡ªè¯é¡¹ï¼šMEAN_INVALID_BUGï¼ˆç›®æ ‡=0ï¼‰ =", cont_stats["meta"].get("MEAN_INVALID_BUG", 0))
    print("------------------------------------------------------------")

    _print_dist_block("æ³¨ä½å¿«ç…§ï¼šå˜åŒ–ç‡åˆ†æ¡¶ï¼ˆå‡é€Ÿ/åŠ é€Ÿ/æå€¼/æ— æ•ˆï¼‰", cont_stats["rate"], ["å‡é€Ÿ", "åŠ é€Ÿ", "æå€¼", "æ— æ•ˆ"])
    _print_dist_block("æ³¨ä½å¿«ç…§ï¼š|å‡å·®|åˆ†æ¡¶ï¼ˆ<3/â‰¥3/æ— æ•ˆï¼‰", cont_stats["mean"], ["<3", "â‰¥3", "æ— æ•ˆ"])
    _print_dist_block("æ³¨ä½å¿«ç…§ï¼š|ç‚¹å·®|åˆ†å¸ƒï¼ˆ1..9ï¼›çº é”™=0ä¸9+åˆå¹¶ï¼‰", cont_stats["diff"], [str(i) for i in range(1, 10)] + ["çº é”™"])

# ------------------------------------------------------------
# 5) å•æ‰¹æ¬¡ç­–ç•¥å…¥å£ï¼ˆå”¯ä¸€å…¥å£ï½œä¸¥æ ¼é›¶æœªæ¥ï¼‰
# è¯´æ˜ï¼š
# - è¿™é‡Œåªæä¾›â€œç©ºç­–ç•¥â€å ä½ï¼šé»˜è®¤ä¸æ¿€æ´»
# - ä»»ä½•ç­–ç•¥å¼€å‘ï¼Œåªå…è®¸ä¿®æ”¹æœ¬å‡½æ•°å†…éƒ¨
# - è‹¥ä½ éœ€è¦è¿ç»­ç»Ÿè®¡ï¼šè¯·åœ¨æ¯æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘append å¿«ç…§åˆ° snapshots
#   å¿«ç…§æ ¼å¼å»ºè®®ï¼š{"bet_no":1, "diff":diff, "rate":rate, "mean":mean}
# ------------------------------------------------------------
def _audit_forbid_idx_offset():
    # æœªæ¥æ•°é˜»æ–­ï¼šç¦æ­¢å‡ºç° idx+åç§»é‡ ç›´ç®—è¡Œå·/è¯»å–è¡Œ çš„ç‰‡æ®µ
    forbidden = [
        "idx + step_idx", "idx+step_idx",
        "idx + b_idx", "idx+b_idx",
        "records[idx +", "records[idx+",

        # ç»•è·¯å†™æ³•ï¼ˆç¦æ­¢ï¼‰ï¼šåŒºé—´è¯»å–/åŒºé—´å¾ªç¯/è¡¨æ ¼å¼ç´¢å¼•
        "records[idx:","records[idx :","records[ idx:","records[ idx :",
        "records[idx+1:","records[idx + 1:","records[idx +1:",
        "range(idx","range(idx +","range( idx",
        "iloc[",

    ]
    import inspect
    try:
        src = inspect.getsource(run_strategy_on_boot)
    except Exception:
        return  # æ— æ³•å–æºæ—¶ä¸é˜»æ–­ï¼ˆæå°‘è§ï¼‰
    hits = []
    for frag in forbidden:
        if frag in src:
            hits.append(frag)
    if hits:
        raise RuntimeError("å®‰å…¨è‡ªæ£€å¤±è´¥ï¼šæ£€æµ‹åˆ°ç¦æ­¢ç‰‡æ®µ: " + str(hits))


def _execute_trade_with_j_cursor(records, start_j, target_side, units, snapshots):
    # æ‰§è¡Œå™¨ï¼šä¸¥æ ¼ä½¿ç”¨ j æ¸¸æ ‡é€è¡Œæ¨è¿›ï¼›ç¦æ­¢ idx+åç§»é‡ ç›´ç®—
    # è§„åˆ™ï¼šæ¯æ¬¡â€œå®é™…æŠ•æ”¾å‰â€è®°å½•ä¸€æ¬¡å¿«ç…§ï¼›çŠ¶æ€T 0é€€å›ä¸æ¨è¿›æ³¨å·ï¼Œä½† j å¿…é¡»å‰è¿›
    j = start_j
    bet_n = 1
    while bet_n <= len(units) and j < len(records):
        decision_row = records[j]

        # å†³ç­–å£å¿«ç…§ï¼ˆå…è®¸è¯»æŒ‡æ ‡ï¼šdiff/rate/meanï¼‰
        snap = {
            "bet_no": bet_n,
            "idx": j,
            "diff": decision_row.get("diff"),
            "rate": decision_row.get("rate"),
            "mean": decision_row.get("mean"),
        }
        snapshots.append(snap)

        r = decision_row.get("r")
        if r == "T":
            j += 1
            continue

        u = units[bet_n - 1]
        if r == target_side:
            return True, u
        else:
            bet_n += 1
            j += 1
            continue

    return False, 0


def run_strategy_on_boot(records):
    # ç©ºç­–ç•¥å ä½ï¼šé»˜è®¤ä¸æ¿€æ´»ï¼ˆæ¯ç‰ˆå¯è·‘ï¼›ç­–ç•¥æ–¹è‡ªè¡Œæ¥å…¥ç»“æ„æ‰«æåå†æ¿€æ´»ï¼‰
    snapshots = []
    entry, win, lose, bust = 0, 0, 0, 0
    profit = 0.0

    # å¦‚éœ€æ¼”ç»ƒï¼Œå¯å°†ä¸‹é¢å¼€å…³æ”¹ä¸º 1ï¼ˆä»…ç”¨äºéªŒè¯é“¾è·¯ï¼Œä¸ä»£è¡¨ä»»ä½•ç»“æ„ï¼‰
    DEMO_ACTIVATE = 0

    for idx, row in enumerate(records):
        if not DEMO_ACTIVATE:
            continue

        rr = row.get("r")
        if idx < 9 or rr not in ("B", "P"):
            continue

        target_side = "B"
        units = [1, 2, 4, 8]

        entry += 1
        start_j = idx + 1  # æŠ•æ”¾ç‚¹ä¸‹ä¸€è¡Œ
        ok, u_win = _execute_trade_with_j_cursor(records, start_j, target_side, units, snapshots)

        if ok:
            win += 1
            profit += (u_win * 0.95 if target_side == "B" else u_win * 1.0)
        else:
            lose += 1
            bust += 1
            profit -= sum(units)

        break  # ä¸€æ¬¡æ€§æ‰«æé”æ­»ï¼šæ¯æ‰¹æ¬¡ä»… 1 æ¬¡æ‰§è¡Œ

    # bust å½’å› å›å¡«ï¼šè¿ç»­ç»Ÿè®¡åªå…è®¸è¯» snapshots
    for s in snapshots:
        if isinstance(s, dict):
            s["trade_bust"] = 1 if bust > 0 else 0

    return {"entry": entry, "win": win, "lose": lose, "bust": bust, "profit": profit, "snapshots": snapshots}
if __name__ == "__main__":
    main()