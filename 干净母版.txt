# ğŸ›¡ï¸ğŸ›¡ï¸ğŸ›¡ï¸
# -*- coding: utf-8 -*-
"""
å¹²å‡€æ¯ç‰ˆï½œæ¼”ç»ƒå¼•æ“ï¼ˆV4ï½œä¸€æ¬¡æ€§æ‰«æï½œä¸‰å£æœ¯è¯­ç»Ÿä¸€ï½œæœªæ¥æ•°å°å£ï¼‰
============================================================
ç”¨é€”ï¼šæä¾›ä¸€ä»½å¯å¤åˆ¶çš„å¹²å‡€æ¯ç‰ˆï¼Œç”¨äºä»¥åæ‰€æœ‰ç­–ç•¥å¼€å‘ä¸æ¼”ç»ƒã€‚
ç¡¬è§„åˆ™æ‘˜è¦ï¼š
- åªè¯»ä¸ç®—ï¼šç‚¹å·®/å˜åŒ–ç‡/å‡å·®åªè¯» CSV åŸå€¼ï¼Œä¸åœ¨è„šæœ¬å†…é‡ç®—
- ä¸¥æ ¼é›¶æœªæ¥ï¼šä»»æ„ç´¢å¼• idx æ—¶ï¼Œåªèƒ½ä½¿ç”¨ 0..idx è¡Œåšåˆ¤æ–­
- æœ¯è¯­é”æ­»ï¼šåªä¿ç•™ã€Œâ­ / æŠ•æ”¾ç‚¹ã€ï¼ˆç¨‹åºå†…éƒ¨è¡Œæ¨è¿›ä¸ç»“ç®—ä¸å¯¹å¤–å‘½åï¼‰
- é´çº§é—¸é—¨ï¼šä»…é™åˆ¶ä¸‹æ³¨ï¼Œå‰8å£ç¦æ­¢å®é™…è½æ³¨ï¼ˆseen_all=1..8ï¼‰ï¼Œç¬¬9å£èµ·å…è®¸ï¼›ç»“æ„æ‰«æä¸â­/æŠ•æ”¾ç‚¹æ‰«æä¸å—å½±å“
- æ‰«ææ–¹å¼ï¼šå½»åº•ä¸€æ¬¡æ€§ï¼ˆæ¯æ‰¹æ¬¡æœ€å¤š 1 æ¬¡æŠ•æ”¾ï¼‰ï¼›ç¦ç”¨æŒç»­æ‰«æä¸ 2 æ¬¡æŠ•æ”¾æœºä¼š
"""

import csv
import os
import hashlib
from collections import defaultdict

# è¡¨å¤´è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡
_HEADER_MAPPING_PRINTED = False

# ==========================
# åŠ å›ºæ¯ç‰ˆï¼šæƒé™/å¿«ç…§/é˜¶æ®µæœºï¼ˆV1ï¼‰
# ==========================
from dataclasses import dataclass

# å…¨å±€è®¡æ•°ï¼ˆè§£æè‡ªè¯ç”¨ï¼‰
MEAN_MISSING_RAW = 0
MEAN_PARSE_FAIL = 0
RATE_MISSING_RAW = 0
RATE_PARSE_FAIL = 0

# é˜¶æ®µæœºï¼ˆé”æ­»ï¼šå•å‘ï¼‰
PHASE_SCAN = "SCAN"
PHASE_DECISION = "DECISION"   # ä»…â€œâ­/æŠ•æ”¾ç‚¹â€å…è®¸è¯»æŒ‡æ ‡ã€å†™å¿«ç…§
PHASE_EXECUTE = "EXECUTE"
PHASE_SETTLE = "SETTLE"
PHASE_DONE = "DONE"

_ALLOWED_PHASE_TRANSITIONS = {
    PHASE_SCAN: {PHASE_DECISION},
    PHASE_DECISION: {PHASE_EXECUTE},
    PHASE_EXECUTE: {PHASE_SETTLE},
    PHASE_SETTLE: {PHASE_DONE},
    PHASE_DONE: set(),
}

def _phase_transition(ctx, new_phase):
    old = ctx.get("phase")
    if old not in _ALLOWED_PHASE_TRANSITIONS:
        raise RuntimeError(f"PHASE_ERROR: unknown phase {old}")
    if new_phase not in _ALLOWED_PHASE_TRANSITIONS[old]:
        raise RuntimeError(f"PHASE_ERROR: illegal transition {old} -> {new_phase}")
    ctx["phase"] = new_phase

@dataclass(frozen=True)
class Snapshot:
    # æœ€å°å¿«ç…§ï¼šåªå…è®¸æºå¸¦ä¸‰æŒ‡æ ‡ + å®šä½å­—æ®µ
    diff: int
    rate: object
    mean: object
    boot_id: str
    idx: int
    seen_all: int
    rr: str
    source: str  # "STAR_ROW" or "DROP_ROW"

    # ç¦æ­¢ dict.get / ä¸‹æ ‡ç»•è¿‡
    def get(self, *args, **kwargs):
        raise RuntimeError("METRIC_ACCESS_BLOCKED: Snapshot ä¸èƒ½ç”¨ get()ï¼Œå¿…é¡»èµ° secure_read_metric")
    def __getitem__(self, k):
        raise RuntimeError("METRIC_ACCESS_BLOCKED: Snapshot ä¸èƒ½ç”¨ []ï¼Œå¿…é¡»èµ° secure_read_metric")

@dataclass(frozen=True)
class RowLite:
    # EXECUTE/SETTLE é˜¶æ®µçš„è¡Œå¯¹è±¡ï¼šå»æŒ‡æ ‡åŒ–ï¼ˆæ ¹æºç­ç«ï¼‰
    r: str
    boot_id: str
    idx: int
    seen_all: int

def secure_read_metric(snap, key, phase, *, who, idx, boot_id, seen_all):
    # è¯»æŒ‡æ ‡æƒé™æ”¶å£ï¼šåªå…è®¸ DECISIONï¼ˆâ­/æŠ•æ”¾ç‚¹ï¼‰
    if key not in ("diff", "rate", "mean"):
        raise RuntimeError(f"METRIC_KEY_ERROR: {key}")
    if phase != PHASE_DECISION:
        raise RuntimeError("METRIC_READ_FORBIDDEN: phase!=DECISION")
    if who not in ("STAR", "DROP"):
        raise RuntimeError("METRIC_READ_FORBIDDEN: who!=STAR/DROP")
    if seen_all is None or int(seen_all) < 9:
        raise RuntimeError("METRIC_READ_FORBIDDEN: seen_all<9")
    if getattr(snap, "boot_id", None) != str(boot_id):
        raise RuntimeError("METRIC_READ_FORBIDDEN: boot_id mismatch")
    if getattr(snap, "idx", None) != int(idx):
        raise RuntimeError("METRIC_READ_FORBIDDEN: idx mismatch")
    src = getattr(snap, "source", None)
    if who == "STAR" and src != "STAR_ROW":
        raise RuntimeError("METRIC_READ_FORBIDDEN: STAR source!=STAR_ROW")
    if who == "DROP" and src != "DROP_ROW":
        raise RuntimeError("METRIC_READ_FORBIDDEN: DROP source!=DROP_ROW")
    return getattr(snap, key)

def secure_write_star_snapshot(row, phase, *, boot_id, rr, idx, seen_all, star_snapshot):
    # â­å¿«ç…§å”¯ä¸€å…¥å£ï¼ˆåªå…è®¸å†™ä¸€æ¬¡ï¼‰
    if phase != PHASE_DECISION:
        raise RuntimeError("SNAP_WRITE_FORBIDDEN: phase!=DECISION")
    if rr == "T":
        raise RuntimeError("SNAP_WRITE_FORBIDDEN: STAR rr==T")
    if seen_all is None or int(seen_all) < 9:
        raise RuntimeError("SNAP_WRITE_FORBIDDEN: STAR seen_all<9")
    if star_snapshot is not None:
        raise RuntimeError("SNAP_WRITE_FORBIDDEN: STAR snapshot duplicated")
    # åªå…è®¸ä» row åŸå§‹å­—æ®µå†™å…¥ï¼ˆåŸå€¼ï¼‰ï¼Œä¸å…è®¸å…œåº•ç¼ºå¤±->0
    if row.get("diff") is None:
        raise RuntimeError("SNAP_WRITE_FORBIDDEN: STAR diff missing")
    return Snapshot(
        diff=int(row.get("diff")),
        rate=row.get("rate"),
        mean=row.get("mean"),
        boot_id=str(boot_id),
        idx=int(idx),
        seen_all=int(seen_all),
        rr=str(rr),
        source="STAR_ROW",
    )

def secure_write_drop_snapshot(row, phase, *, boot_id, rr, idx, seen_all):
    # æŠ•æ”¾ç‚¹å¿«ç…§å…¥å£ï¼ˆæ¯æ¬¡å®é™…æŠ•æ”¾å‰éƒ½å¯å†™ä¸€æ¬¡ï¼›å«Tå¯¼è‡´çš„é‡å¤æŠ•æ”¾å‰ä¹Ÿè¦å†™ï¼‰
    if phase != PHASE_DECISION:
        raise RuntimeError("SNAP_WRITE_FORBIDDEN: phase!=DECISION")
    if rr == "T":
        raise RuntimeError("SNAP_WRITE_FORBIDDEN: DROP rr==T")
    if seen_all is None or int(seen_all) < 9:
        raise RuntimeError("SNAP_WRITE_FORBIDDEN: DROP seen_all<9")
    if row.get("diff") is None:
        raise RuntimeError("SNAP_WRITE_FORBIDDEN: DROP diff missing")
    return Snapshot(
        diff=int(row.get("diff")),
        rate=row.get("rate"),
        mean=row.get("mean"),
        boot_id=str(boot_id),
        idx=int(idx),
        seen_all=int(seen_all),
        rr=str(rr),
        source="DROP_ROW",
    )

def _assert_raises(fn, expected_substr):
    try:
        fn()
    except Exception as e:
        if expected_substr and expected_substr not in str(e):
            raise RuntimeError(f"SELFTEST_EXPECTED='{expected_substr}' GOT='{e}'")
        return
    raise RuntimeError("SELFTEST_EXPECTED_RAISE_BUT_GOT_NONE")

def run_hard_injection_selftest():
    # è‡ªæ£€ä¸‰è¯æ®ï¼šå¿…é¡»å¯é˜»æ–­
    ctx = {"phase": PHASE_SCAN}

    # A) éæ³•æŒ‡æ ‡è®¿é—®æ¨¡æ‹Ÿï¼šEXECUTE é˜¶æ®µè¯»æŒ‡æ ‡åº”é˜»æ–­
    dummy = Snapshot(diff=1, rate=None, mean=None, boot_id="BOOT", idx=0, seen_all=9, rr="B", source="STAR_ROW")
    _phase_transition(ctx, PHASE_DECISION)
    star = secure_write_star_snapshot({"diff": 1, "rate": None, "mean": None}, ctx["phase"], boot_id="BOOT", rr="B", idx=0, seen_all=9, star_snapshot=None)
    _phase_transition(ctx, PHASE_EXECUTE)
    _assert_raises(lambda: secure_read_metric(star, "diff", ctx["phase"], who="STAR", idx=0, boot_id="BOOT", seen_all=9), "phase!=DECISION")

    # B) Tè¡Œå†™å¿«ç…§åº”é˜»æ–­
    _phase_transition(ctx, PHASE_SETTLE)
    _phase_transition(ctx, PHASE_DONE)
    _assert_raises(lambda: secure_write_star_snapshot({"diff": 1, "rate": None, "mean": None}, PHASE_DECISION, boot_id="BOOT", rr="T", idx=0, seen_all=9, star_snapshot=None), "rr==T")

    # C) ç¡¬æ³¨å…¥éªŒè¯ï¼šé˜¶æ®µæœºéæ³•å›è·³åº”é˜»æ–­
    ctx2 = {"phase": PHASE_SCAN}
    _phase_transition(ctx2, PHASE_DECISION)
    _phase_transition(ctx2, PHASE_EXECUTE)
    _assert_raises(lambda: _phase_transition(ctx2, PHASE_DECISION), "illegal transition")

    print("=== æ­£åœ¨æ‰§è¡Œç¡¬æ³¨å…¥è‡ªæ£€ ===")
    print("ç¡¬æ³¨å…¥éªŒè¯=é€šè¿‡âœ…")
    print("éæ³•æŒ‡æ ‡è®¿é—®æ¨¡æ‹Ÿ=å·²é˜»æ–­âœ…")
    print("Tè¡Œå†™å¿«ç…§=å·²é˜»æ–­âœ…")
    print("=== è‡ªæ£€å®Œæˆ ===")


SCAN_MODE_LOCKED = "ä¸€æ¬¡æ€§æ‰«æ"

# é´çº§é—¸é—¨ï¼ˆé”æ­»ï¼‰ï¼šåªç¦æ­¢â€œå®é™…è½æ³¨â€å‘ç”Ÿåœ¨ seen_all=1..8ï¼›ä»ç¬¬9å£èµ·å…è®¸
# å¼€å…³è¾“å‡ºå¿…é¡»å¸¦ âœ…/â›”
BOOT_FILTER = 1  # 1=ONâœ…ï¼›0=OFFâ›”
BOOT_FILTER_ON_LABEL = "BOOT_FILTER=ONâœ…(ç¦ä¸‹æ³¨ seen_all=1..8)"
BOOT_FILTER_OFF_LABEL = "BOOT_FILTER=OFFâ›”(é´é¦–å…è®¸ä¸‹æ³¨)"

# ============================================================
# ç»“æ„é—¸é—¨ï¼ˆç‰ˆæœ¬Aï½œç»“æ„æ’æ§½åŒºï½œé”æ­»å…¥å£ï¼‰
# è¯´æ˜ï¼š
# - ä¸é”ç»“æ„å†…å®¹ï¼šç»“æ„ç”±â€œç»“æ„æ’æ§½åŒºâ€æä¾›ï¼›æ¨¡æ¿åªé”æ­»â€œå…¥å£/è‡ªè¯/æ‹¦æˆªâ€
# - STRUCT_SCAN=ONâœ…ï¼šå¯ç”¨ç»“æ„æ‰«æé—¸é—¨ï¼ˆåç»­é“¾è·¯å¿…é¡»ä½¿ç”¨è¯¥å…¥å£äº§å‡ºâ­/æŠ•æ”¾ç‚¹ï¼‰
# - STRUCT_SCAN=OFFâ›”ï¼šå…³é—­ç»“æ„é—¸é—¨ï¼ˆä»…è‡ªè¯ï¼›ä¸å¾—ç”¨äºç­–ç•¥æ‰§è¡Œï¼‰
# ============================================================
STRUCT_SCAN = 0  # 1=ONâœ…ï¼›0=OFFâ›”
STRUCT_SCAN_ON_LABEL = "STRUCT_SCAN=ONâœ…(ç»“æ„æ‰«æå¼€å¯)"
STRUCT_SCAN_OFF_LABEL = "STRUCT_SCAN=OFFâ›”(ç»“æ„æ‰«æå…³é—­-ä»…è‡ªè¯)"

def _hash8(s):
    try:
        return hashlib.sha1(str(s).encode("utf-8")).hexdigest()[:8]
    except Exception:
        return "00000000"


# [STRUCT_SLOT_BEGIN]
# ç»“æ„æ’æ§½åŒºï¼ˆå”¯ä¸€å…è®¸å‡ºç°ç»“æ„å®šä¹‰çš„åœ°æ–¹ï¼‰
# - ä»¥åæ›´æ¢ç»“æ„ï¼šåªæ›¿æ¢æœ¬æ’æ§½åŒºå†…å®¹ï¼›æ¨¡æ¿å…¶ä½™éƒ¨åˆ†ç¦æ­¢å‡ºç°ä»»ä½•ç»“æ„åˆ¤æ–­
STRUCT_SUMMARY_LINE = "ï¼ˆç»“æ„æ’æ§½ï¼šç”±ç­–ç•¥æ³¨å…¥ï¼‰"

def scan_structure(records):
    # ç»“æ„æ‰«æå”¯ä¸€å…¥å£ï¼ˆå ä½ï¼‰ï¼šé»˜è®¤å¤±è´¥ï¼ˆæ¯ç‰ˆä¸æ¿€æ´»ç»“æ„ï¼‰
    # è¿”å›å­—æ®µé”æ­»ï¼šstatus âˆˆ {STRUCT_OK, STRUCT_FAIL}; star_idx ä¸ºâ­/æŠ•æ”¾ç‚¹è¡Œå·ï¼ˆé´å†… idxï¼‰
    return {
        "status": "STRUCT_FAIL",
        "star_idx": None,
        "strong_side": None,
        "weak_side": None,
        "summary": STRUCT_SUMMARY_LINE,
    }
# [STRUCT_SLOT_END]


def _audit_structure_slot_integrity():
    # è‡ªæ£€ï¼šscan_structure ä¸ STRUCT_SUMMARY_LINE å¿…é¡»ä¸”åªèƒ½å‡ºç° 1 æ¬¡ï¼Œä¸”å¿…é¡»ä½äºç»“æ„æ’æ§½åŒºå†…
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            src = f.read()
    except Exception:
        return

    begin_mark = "# [STRUCT_SLOT_BEGIN]"
    end_mark = "# [STRUCT_SLOT_END]"

    b = src.find(begin_mark)
    e = src.find(end_mark)
    if b < 0 or e < 0 or e <= b:
        raise RuntimeError("âŒ ç¼ºå°‘ç»“æ„æ’æ§½æ ‡è®°è¡Œï¼š# [STRUCT_SLOT_BEGIN] / # [STRUCT_SLOT_END]")

    slot = src[b:e + len(end_mark)]

    # å…¨æ–‡è®¡æ•°ï¼ˆåªè®¡â€œå®šä¹‰è¡Œâ€ï¼Œé¿å…è¢«è‡ªæ£€ä»£ç é‡Œçš„å­—ç¬¦ä¸²æ±¡æŸ“ï¼‰
    import re
    if len(re.findall(r"^\s*def\s+scan_structure\s*\(", src, flags=re.M)) != 1:
        raise RuntimeError("âŒ scan_structure å¿…é¡»ä¸”åªèƒ½å‡ºç° 1 æ¬¡")
    if len(re.findall(r"^\s*STRUCT_SUMMARY_LINE\s*=", src, flags=re.M)) != 1:
        raise RuntimeError("âŒ STRUCT_SUMMARY_LINE å¿…é¡»ä¸”åªèƒ½å‡ºç° 1 æ¬¡")

    # æ’æ§½å†…å¿…é¡»åŒ…å«
    if "def scan_structure" not in slot:
        raise RuntimeError("âŒ scan_structure å¿…é¡»ä½äºç»“æ„æ’æ§½åŒºå†…")
    if "STRUCT_SUMMARY_LINE" not in slot:
        raise RuntimeError("âŒ STRUCT_SUMMARY_LINE å¿…é¡»ä½äºç»“æ„æ’æ§½åŒºå†…")

# åä¼ªé€ è‡ªæ£€ï¼šç¦åŒºå†…å‘ç”Ÿä»»ä½•â€œå®é™…è½æ³¨â€ä¸€ç¥¨å¦å†³
BET_IN_FORBIDDEN_SEEN = 0
MONITOR_ENABLE = 0  # ç›‘æµ‹å¼€å…³ï¼š0=å…³ï¼›1=å¼€ï¼ˆåŠ¨æ€ç›‘æµ‹/åŠ¨æ€æ­¢æŸï¼‰
# å¤šæ¬¡å†³ç­–ï¼ˆåŠ¨æ€ç›‘æµ‹/åŠ¨æ€æ­¢æŸï½œé”æ­»ï¼‰ï¼šåŒä¸€ç¬”äº¤æ˜“å†…ï¼Œæ¯ä¸€æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘å…è®¸åšä¸€æ¬¡â€œç»§ç»­/STOPâ€å†³å®šï¼›
# å†³ç­–æ—¶åˆ»è§†ä¸ºä¸€æ¬¡â€œæŠ•æ”¾ç‚¹â€ï¼Œåªå…è®¸è¯»å–è¯¥è¡ŒåŠå†å²æŒ‡æ ‡ï¼›ä¸¥ç¦ä½¿ç”¨è¯¥å†³ç­–å£ä¹‹åï¼ˆt+1 åŠä»¥åï¼‰çš„ä»»ä½•ä¿¡æ¯ã€‚
VERIFY_SPLIT_ENABLE = 0  # éªŒçœŸåˆ†æ‹†å¼€å…³ï¼š0=å…³ï¼›1=å¼€ï¼ˆæ–‡ä»¶åæ’åºå‰ 50%/å 50%ï¼‰


# æ³¨ä½å¿«ç…§ç»Ÿè®¡ï¼ˆL2/L3/L4 å„æ³¨ä½å¿«ç…§ï½œé”æ­»ï¼‰
# - åªåšâ€œäº‹åç»Ÿè®¡â€ï¼šä»…åŸºäºã€æŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨ã€‘åšåˆ†å¸ƒï¼›ç¦æ­¢å›è¯» recordsï¼›ç¦æ­¢â€œç›¸é‚»å¯¹æ¯”â€ç±»ç»Ÿè®¡
# - å–å€¼å£ï¼šæ¯æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘å¿«ç…§ï¼ˆå«çŠ¶æ€ T å¯¼è‡´åŒæ³¨é‡å¤æŠ•æ”¾å‰çš„æ¯ä¸€æ¬¡ï¼‰
# - è§‚æµ‹ç›®æ ‡ï¼šç”¨äº STOP ç”»åƒå€™é€‰ï¼Œä¸å¾—å‚ä¸æ¿€æ´»åˆ¤å®šï¼ˆæ¿€æ´»å±‚å¿…é¡»å¯ç‹¬ç«‹è¿è¡Œï¼‰
CONT_STATS_ENABLE = 1
CONT_N_MAX = 12          # åªå±•å¼€å‰ N æ¬¡å®é™…æŠ•æ”¾ï¼ˆå«çŠ¶æ€ T é‡å¤æŠ•æ”¾ï¼‰ï¼›å…¶ä½™åˆå¹¶åˆ° N+ 
CONT_MIN_COUNT = 500     # ä½äºè¯¥æ¬¡æ•°çš„æ ¼å­ä¸å‚ä¸è¾“å‡ºï¼Œé¿å…å™ªå£°
CONT_TOPK = 10           # æ¯ä¸ªä½æ¬¡æœ€å¤šè¾“å‡º TopKï¼ˆæ¡¶æ•°å¾ˆå°‘æ—¶ä¼šè¾“å‡ºå…¨æ¡¶ï¼‰


# ============================================================
# ç»Ÿä¸€ä»£ç æ¨¡æ¿ï¼ˆV4ï¼Œåºåˆ—é•¿åº¦å£å¾„ï½œä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§æŠ•æ”¾ï¼‰
# çº¦æŸï¼š
# 1) åªè¯»å–å½“å‰ç›®å½•ä¸‹æ‰€æœ‰ .csv
# 2) ä¸å†™æ­»ä»»ä½•ç»å¯¹è·¯å¾„
# 3) è‡ªåŠ¨è¯†åˆ«æ‰¹æ¬¡åˆ—/ç»“æœ/ç‚¹å·®/å˜åŒ–ç‡/å‡å·®
# 4) ç»“æœå¿…é¡»æ˜ å°„ä¸º B/P/T
# 5) ä¸¥æ ¼é›¶æœªæ¥ï¼šrun_strategy_on_boot å†…ä¸¥ç¦è®¿é—®æœªæ¥è¡Œ
# 6) â€œä¸‹ä¸€å£/ä¸‹ä¸€è¡Œâ€ç»Ÿä¸€å®šä¹‰ï¼šidx+1ï¼ˆä¸è·³è¿‡çŠ¶æ€ Tï¼‰
# 7) é´çº§é—¸é—¨ï¼šåªé™åˆ¶ä¸‹æ³¨å‘ç”Ÿç‚¹ï¼›ç»“æ„æ‰«æä¸â­/æŠ•æ”¾ç‚¹æ‰«æä¸å—å½±å“
#
# æ³¨æ„ï¼šæœªæ¥æ–°å¢/ä¿®æ”¹ç­–ç•¥ï¼Œåªæ”¹ run_strategy_on_boot(records) å†…éƒ¨é€»è¾‘
# ============================================================

# ============================================================
# ç»“æœæ˜ å°„è¡¨ï¼šå·²å®Œæˆ BPT å…¨é˜¶è„±æ•ï¼Œç‰©ç†åŒ¹é…å®éªŒå®¤æ ‡å‡†åŒ– CSV
# ============================================================
MAP_RESULT = {"B": "B", "P": "P", "T": "T"}



def map_result(v):
    if v is None:
        return None
    s = str(v).strip()
    if s in MAP_RESULT:
        return MAP_RESULT[s]
    s2 = s.upper()
    if s2 in MAP_RESULT:
        return MAP_RESULT[s2]
    return None

# ------------------------------------------------------------
# å·¥å…·ï¼šå®‰å…¨è¯»å– float / intï¼ˆåªè¯»ï¼Œä¸è®¡ç®—ï¼‰
# ------------------------------------------------------------
def safe_float(v, default=None):
    try:
        if v is None or v == "":
            return default
        return float(v)
    except Exception:
        return default

def safe_int(v, default=0):
    try:
        if v is None or v == "":
            return default
        return int(float(v))
    except Exception:
        return default

# ------------------------------------------------------------
# 1) æ•°æ®åŠ è½½ï¼ˆå›ºå®šï¼‰
# ------------------------------------------------------------
def load_all_boots(csv_files):
    """
    æŒ‰ Sub-Batch + é´ç»“æŸ åˆ†é´ï¼ˆé”æ­»ï¼‰ï¼š
    - æ¯æ¡è®°å½•å¿…é¡»å±äºæŸä¸ª Sub-Batch
    - é´ç»“æŸåˆ—ä»…æœ€åä¸€å£ä¸º 1ï¼Œå…¶ä½™ä¸º 0
    - åŒä¸€ Sub-Batch å†…æŒ‰åŸå§‹é¡ºåºç´¯ç§¯ï¼Œé‡åˆ° é´ç»“æŸ=1 å³å°é´
    - æ¯è¡Œæ ‡å‡†åŒ–å­—æ®µï¼šr/diff/rate/mean/seen_all/idxï¼ˆidxä¸ºé´å†…0åŸºï¼‰
    """
    boots = []
    print("æ£€æµ‹åˆ° CSV æ–‡ä»¶æ•°é‡:", len(csv_files))

    for i, fname in enumerate(csv_files, 1):
        if i % 10 == 0:
            print(f"è¿›åº¦: å·²å¤„ç† {i}/{len(csv_files)} ä¸ªæ–‡ä»¶")

        rows = []
        for enc in ("utf-8-sig", "utf-8", "gb18030", "gbk"):
            try:
                with open(fname, "r", encoding=enc) as f:
                    rows = list(csv.DictReader(f))
                break
            except Exception:
                rows = []

        if not rows:
            continue

        col_sub, col_end, col_result, col_diff, col_rate, col_mean = detect_columns(rows[0])
        _print_header_mapping_once(rows[0], (col_sub, col_end, col_result, col_diff, col_rate, col_mean))

        cur_sub = None
        cur = []
        seen_all = 0

        for rr in rows:
            sub = rr.get(col_sub)
            if sub is None or sub == "":
                continue

            # è‹¥é‡åˆ° Sub-Batch å˜åŒ–ï¼šå…ˆå°å­˜ä¸Šä¸€é´ï¼ˆè‹¥æœ‰æ®‹ç•™ï¼‰
            if cur_sub is None:
                cur_sub = sub
            elif sub != cur_sub:
                if cur:
                    boots.append(({"file": fname, "sub_batch": str(cur_sub)}, cur))
                cur_sub = sub
                cur = []
                seen_all = 0

            res = map_result(rr.get(col_result))
            if res not in ("B", "P", "T"):
                continue

            # ä¸¥æ ¼åŒºåˆ† None ä¸ 0ï¼šç¦æ­¢ç¼ºå¤±å…œåº•ä¸º 0
            raw_diff = rr.get(col_diff) if col_diff else None
            if raw_diff is None or raw_diff == "" or str(raw_diff) == "None":
                raise RuntimeError(f"DIFF_MISSING: file={fname} sub={cur_sub} row={seen_all+1}")
            try:
                diff = int(float(raw_diff))
            except Exception:
                raise RuntimeError(f"DIFF_PARSE_FAIL: file={fname} sub={cur_sub} raw='{raw_diff}'")

            def _parse_float(raw_v, *, field):
                global MEAN_MISSING_RAW, MEAN_PARSE_FAIL, RATE_MISSING_RAW, RATE_PARSE_FAIL
                if raw_v is None or raw_v == "" or str(raw_v) == "None":
                    if field == "mean":
                        MEAN_MISSING_RAW += 1
                    if field == "rate":
                        RATE_MISSING_RAW += 1
                    return None
                try:
                    return float(raw_v)
                except Exception:
                    if field == "mean":
                        MEAN_PARSE_FAIL += 1
                    if field == "rate":
                        RATE_PARSE_FAIL += 1
                    return None

            rate = _parse_float(rr.get(col_rate) if col_rate else None, field="rate")
            mean = _parse_float(rr.get(col_mean) if col_mean else None, field="mean")

            idx_in_boot = len(cur)
            seen_all += 1
            cur.append({
                "r": res,
                "diff": diff,
                "rate": rate,
                "mean": mean,
                "seen_all": seen_all,
                "idx": idx_in_boot,
                "boot_id": str(cur_sub),
            })

            end_flag = safe_int(rr.get(col_end, 0), 0) if col_end else 0
            if end_flag == 1:
                boots.append(({"file": fname, "sub_batch": str(cur_sub)}, cur))
                cur_sub = None
                cur = []
                seen_all = 0

        # æ–‡ä»¶æœ«å°¾æ®‹ç•™ï¼šè§†ä¸ºä¸åˆæ ¼åˆ†é´ï¼Œä½†ä¸ºä¿è¯å¯è·‘ï¼Œä»å°å­˜å¹¶è®©å®¡æŸ¥å±‚å¤„ç†
        if cur:
            boots.append(({"file": fname, "sub_batch": str(cur_sub)}, cur))

    print("æŒ‰ Sub-Batch + é´ç»“æŸ åˆ†é´å®Œæˆï¼Œé´æ€»æ•°:", len(boots))
    return boots


def _run_report(csv_files, title):
    # ============================================================
    # ç‰©ç†å®šä½é”šç‚¹ï¼šäº¤ä»˜éªŒæ”¶æ°´å°ï¼ˆé”æ­»ï½œå”¯ä¸€æœç´¢å®šä½ï¼‰
    # ============================================================
    print("ğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°")

    # è¿è¡Œçº§è‡ªè¯ï¼šç»“æ„é—¸é—¨ä¸ç»“æ„æ‘˜è¦ï¼ˆæ¨¡æ¿é”æ­»ï¼‰
    print("æœ¯è¯­é”æ­»ï¼šåªæ‰¿è®¤ã€Œâ­ / æŠ•æ”¾ç‚¹ã€")
    print("ç»“æ„é—¸é—¨ï¼š" + (STRUCT_SCAN_ON_LABEL if STRUCT_SCAN else STRUCT_SCAN_OFF_LABEL))
    print("ç»“æ„æ‘˜è¦ï¼š" + str(STRUCT_SUMMARY_LINE) + " | HASH=" + _hash8(STRUCT_SUMMARY_LINE))


    boots = load_all_boots(csv_files)
    total_boots = len(boots)

    insufficient9 = 0

    total_entry = 0
    total_win = 0
    total_lose = 0
    total_bust = 0
    total_profit = 0.0

    global BET_IN_FORBIDDEN_SEEN
    BET_IN_FORBIDDEN_SEEN = 0

    cont_stats = init_cont_stats() if (MONITOR_ENABLE and CONT_STATS_ENABLE) else None

    if total_boots > 0:
        print(f"\nå¼€å§‹å¤„ç† {total_boots:,} ä¸ªæ‰¹æ¬¡...")
    for i, (meta, rec) in enumerate(boots, 1):
        if total_boots >= 10 and (i % 1000 == 0 or i == total_boots):
            # å¤§æ‰¹æ¬¡æ—¶ï¼Œé™ä½æ‰“å°é¢‘ç‡ï¼›å¹²å‡€æ¯ç‰ˆä»¥â€œå¯è·‘â€ä¸ºä¸»
            pass

        cls = classify_boot_first9(rec)
        if not cls["seen9_ok"]:
            insufficient9 += 1
            # åªæ‰“å°ä¸€æ¬¡æœ€å°å­—æ®µå³å¯å¤ç°
            file_ = meta.get("file", "?")
            sub_ = meta.get("sub_batch", "?")
            raise AssertionError(f"âŒ ä¸è¶³9å£ï¼š{file_}|{sub_}|len={len(rec)}")

        out = run_strategy_on_boot(rec)

        total_entry += int(out.get("entry", 0))
        total_win += int(out.get("win", 0))
        total_lose += int(out.get("lose", 0))
        total_bust += int(out.get("bust", 0))
        total_profit += float(out.get("profit", 0.0))

        if cont_stats and out.get("snapshots"):
            update_cont_stats(cont_stats, out["snapshots"], out.get("bet_n", 0))

    # åä¼ªé€ è‡ªæ£€ï¼šç¦åŒºå†…å‘ç”Ÿä»»ä½•â€œå®é™…è½æ³¨â€ä¸€ç¥¨å¦å†³
    if BOOT_FILTER and BET_IN_FORBIDDEN_SEEN != 0:
        raise AssertionError(f"âŒ é´çº§é—¸é—¨å¤±æ•ˆï¼šç¦åŒºå†…å‘ç”Ÿå®é™…è½æ³¨ (BET_IN_FORBIDDEN_SEEN={BET_IN_FORBIDDEN_SEEN})")

    print("\n" + "=" * 60)
    print(title)
    print("=" * 60)
    print(f"TOTAL_BOOT       : {total_boots}")
    print("é´çº§å¼€å…³ï¼š" + (BOOT_FILTER_ON_LABEL if BOOT_FILTER else BOOT_FILTER_OFF_LABEL))

    if insufficient9:
        print(f"BOOT_LT9_ERROR   : {insufficient9}  (ç›®æ ‡=0)")

    print("-" * 60)
    print(f"æ¿€æ´»æ¬¡æ•°    : {total_entry}")
    print(f"åŒ¹é…æ¬¡æ•°    : {total_win}")
    print(f"ä¸åŒ¹é…æ¬¡æ•°  : {total_lose}")
    print(f"é˜ˆå€¼å‡»ç©¿æ¬¡æ•°: {total_bust}")
    print(f"ğŸ’¶ğŸ’¶ğŸ’¶ å•æ¬¡å¹³å‡å¢ç›Š: {total_profit / total_entry:.6f}" if total_entry else "ğŸ’¶ğŸ’¶ğŸ’¶ å•æ¬¡å¹³å‡å¢ç›Š: 0.000000")
    print(f"ğŸ’¶ğŸ’¶ğŸ’¶ æ€»å‡€å€¼å¢ç›Š  : {total_profit:.2f}")

    if cont_stats:
        print("\n" + "-" * 60)
        print_cont_stats(cont_stats)
    print("=" * 60 + "\n")


def main():
    # å¯åŠ¨é¦–å±ï¼ˆé”æ­»ï¼‰ï¼šç¬¬ä¸€è¡Œå¿…é¡»æ˜¯æ°´å°
    print("ğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°")
    print("ã€å¼ºåˆ¶è‡ªè¯è¾“å‡ºã€‘")
    print("ç»“æ„é—¸é—¨ï¼š" + (STRUCT_SCAN_ON_LABEL if STRUCT_SCAN else STRUCT_SCAN_OFF_LABEL))
    print("é´çº§å¼€å…³ï¼š" + (BOOT_FILTER_ON_LABEL if BOOT_FILTER else BOOT_FILTER_OFF_LABEL))

    # è‡ªæ£€å¿…é¡»åœ¨å›æµ‹å‰å®Œæˆï¼Œå¤±è´¥å³é€€å‡º
    run_hard_injection_selftest()

    _audit_structure_slot_integrity()
    _audit_forbid_idx_offset()

    csv_files = sorted([f for f in os.listdir(".") if f.lower().endswith(".csv")])

    if VERIFY_SPLIT_ENABLE and len(csv_files) >= 2:
        mid = len(csv_files) // 2
        _run_report(csv_files[:mid], "éªŒçœŸé˜¶æ®µï¼ˆå‰50%ï¼‰")
        _run_report(csv_files[mid:], "éªŒçœŸé˜¶æ®µï¼ˆå50%ï¼‰")
    else:
        _run_report(csv_files, "ä¼˜åŒ–é˜¶æ®µï¼ˆå…¨é‡ï¼‰")





# ------------------------------------------------------------
# 2) åˆ—è‡ªåŠ¨è¯†åˆ«ï¼ˆå›ºå®šï¼‰
# ------------------------------------------------------------
def _norm_key(k):
    return str(k).strip().lower() if k is not None else ""

def _first_hit(keys, candidates):
    key_norm = { _norm_key(k): k for k in keys }
    for c in candidates:
        cc = _norm_key(c)
        if cc in key_norm:
            return key_norm[cc]
    return None

def detect_columns(row0):
    """
    è¾“å…¥ï¼šrow0ï¼ˆDictReader è¯»åˆ°çš„ä¸€è¡Œï¼‰
    è¾“å‡ºï¼šSub-Batch / é´ç»“æŸ / ç»“æœ / ç‚¹å·® / å˜åŒ–ç‡ / å‡å·® åˆ—åï¼ˆé”æ­»ï¼‰
    """
    col_sub = _first_hit(row0, ["Sub-Batch", "sub-batch", "subbatch", "SubBatch", "Sub Batch", "å­æ‰¹æ¬¡", "æœ¬é´", "æœ¬é´é´å·"])
    col_end = _first_hit(row0, ["é´ç»“æŸ", "shoe_end", "ShoeEnd", "boot_end", "End", "ç»“æŸ"])
    col_result = _first_hit(row0, ["ç»“æœ", "Exhaustion", "Result", "R"])
    col_diff = _first_hit(row0, ["ç‚¹å·®", "diff", "Diff"])
    col_rate = _first_hit(row0, ["å˜åŒ–ç‡", "rate", "Rate"])
    col_mean = _first_hit(row0, ["å‡å·®", "mean", "Mean"])

    if col_sub is None:
        raise ValueError("ç¼ºå°‘å¿…è¦åˆ—ï¼šSub-Batch")
    if col_end is None:
        raise ValueError("ç¼ºå°‘å¿…è¦åˆ—ï¼šé´ç»“æŸ")
    if col_result is None:
        raise ValueError("ç¼ºå°‘å¿…è¦åˆ—ï¼šç»“æœ/Exhaustion")
    if col_diff is None:
        raise ValueError("ç¼ºå°‘å¿…è¦åˆ—ï¼šç‚¹å·®")

    return col_sub, col_end, col_result, col_diff, col_rate, col_mean

def _print_header_mapping_once(row0, cols):
    """è¡¨å¤´è¯†åˆ«è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡ï¼›ç»ä¸å½±å“ä¸»æµç¨‹ã€‚"""
    global _HEADER_MAPPING_PRINTED
    if _HEADER_MAPPING_PRINTED:
        return
    _HEADER_MAPPING_PRINTED = True

    col_sub, col_end, col_result, col_diff, col_rate, col_mean = cols

    print("=" * 50)
    print("è¡¨å¤´è¯†åˆ«ï¼ˆè‡ªè¯ï½œä¸€æ¬¡æ€§æ‰“å°ï¼‰")
    print(f"æ‰¹æ¬¡(Sub-Batch) -> {col_sub}")
    print(f"é´ç»“æŸ -> {col_end}")
    print(f"ç»“æœ -> {col_result}")
    print(f"ç‚¹å·® -> {col_diff}")
    print(f"å˜åŒ–ç‡ -> {col_rate if col_rate else '(ç¼ºå¤±)'}")
    print(f"å‡å·® -> {col_mean if col_mean else '(ç¼ºå¤±)'}")
    print(f"æ ·ä¾‹è¡Œ(åŸå§‹): {row0}")
    print("=" * 50)


def classify_boot_first9(records):
    """
    é´çº§è‡ªè¯ä»…åšå®Œæ•´æ€§æ£€æŸ¥ï¼ˆé”æ­»ï¼‰ï¼š
    - ä¸åšé´çº§å¯æ‰“åˆ¤å®šï¼ˆé´çº§ä»…é™åˆ¶ä¸‹æ³¨å‘ç”Ÿç‚¹ï¼‰
    - åªæ£€æŸ¥ï¼šseen_all>=9ï¼ˆè‹¥ä¸è¶³9å£ï¼Œç›´æ¥æŠ¥é”™å¹¶æ‰“å°æœ€å°å­—æ®µï¼‰
    """
    return {"seen9_ok": (len(records) >= 9)}


def _bucket_abs_diff_monitor(diff):
    try:
        v = abs(int(diff))
    except Exception:
        v = 0

    if v == 0 or v >= 10:
        return "çº é”™"  # |diff|=0 ä¸ 9+ åˆå¹¶è®¡æ•°
    if 1 <= v <= 9:
        return str(v)
    return "çº é”™"


def _bucket_rate_monitor(rate):
    if rate is None:
        return "æ— æ•ˆ"
    try:
        v = float(rate)
    except Exception:
        return "æ— æ•ˆ"
    if v < 0:
        return "å‡é€Ÿ"
    if v < 2:
        return "åŠ é€Ÿ"
    return "æå€¼"


def _bucket_abs_mean_monitor(mean):
    if mean is None:
        return "æ— æ•ˆ"
    try:
        v = float(mean)
    except Exception:
        return "æ— æ•ˆ"
    if abs(v) >= 3:
        return "â‰¥3"
    return "<3"


def init_cont_stats():
    return {
        "rate": defaultdict(lambda: {"cnt": 0, "bust": 0}),
        "mean": defaultdict(lambda: {"cnt": 0, "bust": 0}),
        "diff": defaultdict(lambda: {"cnt": 0, "bust": 0}),
        "meta": {"snap_total": 0, "boot_with_snap": 0, "MEAN_MISSING_RAW": 0, "MEAN_PARSE_FAIL": 0},
    }


def update_cont_stats(cont_stats, snapshots, bust_flag):
    # snapshots: list[dict]ï¼Œæ¯æ¡è‡³å°‘åŒ…å« bet_no/diff/rate/mean
    if not snapshots:
        return

    cont_stats["meta"]["boot_with_snap"] += 1
    cont_stats["meta"]["snap_total"] += len(snapshots)

    for i, s in enumerate(snapshots, 1):
        n = safe_int(s.get("bet_no", i), i)
        n_label = n if n <= CONT_N_MAX else f"{CONT_N_MAX}+"

        d_bucket = _bucket_abs_diff_monitor(s.get("diff", 0))
        r_bucket = _bucket_rate_monitor(s.get("rate", None))
        m_bucket = _bucket_abs_mean_monitor(s.get("mean", None))

        # çº é”™ï¼šmean ç¼ºå¤±ä»…è®¡æ•°ï¼ˆMEAN_MISSING_RAWï¼‰
        if s.get("mean") is None:
            cont_stats["meta"]["MEAN_MISSING_RAW"] += 1

        k_rate = (n_label, r_bucket)
        k_mean = (n_label, m_bucket)
        k_diff = (n_label, d_bucket)

        cont_stats["rate"][k_rate]["cnt"] += 1
        cont_stats["mean"][k_mean]["cnt"] += 1
        cont_stats["diff"][k_diff]["cnt"] += 1
        if bust_flag:
            cont_stats["rate"][k_rate]["bust"] += 1
            cont_stats["mean"][k_mean]["bust"] += 1
            cont_stats["diff"][k_diff]["bust"] += 1


def _print_dist_block(title, bucket_dict, ordered_buckets):
    print()
    print("------------------------------------------------------------")
    print(title)
    print("ï¼ˆæ³¨ä½å¿«ç…§åˆ†æ¡¶åˆ†å¸ƒï½œä»…äº‹åç»Ÿè®¡ï½œåªè¯»å¿«ç…§ï½œç”¨äº STOP ç”»åƒå€™é€‰ï¼‰")
    print("------------------------------------------------------------")

    groups = defaultdict(list)
    for k, v in bucket_dict.items():
        n_label = k[0]
        groups[n_label].append((k, v))

    def n_sort(x):
        if isinstance(x, int):
            return (0, x)
        return (1, 10**9)

    for n_label in sorted(groups.keys(), key=n_sort):
        items = groups[n_label]
        # è¿‡æ»¤ä½æ ·æœ¬
        items = [it for it in items if it[1]["cnt"] >= CONT_MIN_COUNT]
        if not items:
            continue

        # å›ºå®šæ¡¶é¡ºåºè¾“å‡ºï¼ˆä¾¿äºäººå·¥æ¯”å¯¹ï¼‰
        m = {it[0][1]: it[1] for it in items}
        print(f"[ç¬¬{n_label}æ¬¡æŠ•æ”¾]ï¼ˆæ¬¡æ•°>= {CONT_MIN_COUNT}ï¼‰")
        for b in ordered_buckets:
            v = m.get(b)
            if not v:
                continue
            cnt = v["cnt"]
            bust = v["bust"]
            er = (bust / cnt * 100) if cnt else 0.0
            print(f"  {b}  æ¬¡æ•°={cnt}  é˜ˆå€¼å‡»ç©¿={bust}  é˜ˆå€¼å‡»ç©¿ç‡={er:.2f}%")

        # è‹¥å­˜åœ¨æœªåˆ—å…¥ ordered_buckets çš„æ¡¶ï¼ˆç†è®ºä¸åº”æœ‰ï¼‰ï¼Œè¿½åŠ è¾“å‡º
        extra = [bk for bk in m.keys() if bk not in ordered_buckets]
        if extra:
            for b in sorted(extra):
                v = m[b]
                cnt = v["cnt"]
                bust = v["bust"]
                er = (bust / cnt * 100) if cnt else 0.0
                print(f"  {b}  æ¬¡æ•°={cnt}  é˜ˆå€¼å‡»ç©¿={bust}  é˜ˆå€¼å‡»ç©¿ç‡={er:.2f}%")


def print_cont_stats(cont_stats):
    if not CONT_STATS_ENABLE:
        return
    if cont_stats is None:
        return
    if cont_stats["meta"]["boot_with_snap"] <= 0:
        return

    # å›ºå®šè‡ªè¯è¾“å‡º
    print()
    print("------------------------------------------------------------")
    print("è‡ªè¯é¡¹ï¼šMEAN_MISSING_RAWï¼ˆä»…ç»Ÿè®¡ï¼‰ =", cont_stats["meta"].get("MEAN_MISSING_RAW", 0))
    print("è‡ªè¯é¡¹ï¼šMEAN_PARSE_FAILï¼ˆç›®æ ‡=0ï¼‰ =", cont_stats["meta"].get("MEAN_PARSE_FAIL", 0))
    print("------------------------------------------------------------")

    _print_dist_block("æ³¨ä½å¿«ç…§ï¼šå˜åŒ–ç‡åˆ†æ¡¶ï¼ˆå‡é€Ÿ/åŠ é€Ÿ/æå€¼/æ— æ•ˆï¼‰", cont_stats["rate"], ["å‡é€Ÿ", "åŠ é€Ÿ", "æå€¼", "æ— æ•ˆ"])
    _print_dist_block("æ³¨ä½å¿«ç…§ï¼š|å‡å·®|åˆ†æ¡¶ï¼ˆ<3/â‰¥3/æ— æ•ˆï¼‰", cont_stats["mean"], ["<3", "â‰¥3", "æ— æ•ˆ"])
    _print_dist_block("æ³¨ä½å¿«ç…§ï¼š|ç‚¹å·®|åˆ†å¸ƒï¼ˆ1..9ï¼›çº é”™=0ä¸9+åˆå¹¶ï¼‰", cont_stats["diff"], [str(i) for i in range(1, 10)] + ["çº é”™"])

# ------------------------------------------------------------
# 5) å•æ‰¹æ¬¡ç­–ç•¥å…¥å£ï¼ˆå”¯ä¸€å…¥å£ï½œä¸¥æ ¼é›¶æœªæ¥ï¼‰
# è¯´æ˜ï¼š
# - è¿™é‡Œåªæä¾›â€œç©ºç­–ç•¥â€å ä½ï¼šé»˜è®¤ä¸æ¿€æ´»
# - ä»»ä½•ç­–ç•¥å¼€å‘ï¼Œåªå…è®¸ä¿®æ”¹æœ¬å‡½æ•°å†…éƒ¨
# - è‹¥ä½ éœ€è¦è¿ç»­ç»Ÿè®¡ï¼šè¯·åœ¨æ¯æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘append å¿«ç…§åˆ° snapshots
#   å¿«ç…§æ ¼å¼å»ºè®®ï¼š{"bet_no":1, "diff":diff, "rate":rate, "mean":mean}
# ------------------------------------------------------------
def _audit_forbid_idx_offset():
    # æœªæ¥æ•°é˜»æ–­ï¼šç¦æ­¢å‡ºç° idx+åç§»é‡ ç›´ç®—è¡Œå·/è¯»å–è¡Œ çš„ç‰‡æ®µ
    forbidden = [
        # idx ç›´æ¥åç§»
        "idx" + " + step_idx", "idx" + "+step_idx",
        "idx" + " + b_idx", "idx" + "+b_idx",

        # ç›´æ¥ç”¨ idx åç§»è¯» records
        "records[" + "idx" + " +", "records[" + "idx" + "+",
        "records[" + " idx" + " :", "records[" + "idx" + " :",

        # åˆ‡ç‰‡/åŒºé—´è¯»å–ï¼ˆå¸¸è§ç»•è·¯ï¼‰
        "records[" + "idx" + "+1:", "records[" + "idx" + " + 1:",
        "records[" + "idx" + " +1:",

        # range åŒºé—´å¾ªç¯ï¼ˆç»•è·¯ï¼‰
        "range(" + "idx", "range(" + "idx" + " +", "range(" + " idx",

        # è¡¨æ ¼å¼ç´¢å¼•
        "iloc[",
    ]

    import inspect
    audit_src = inspect.getsource(run_strategy_on_boot)

    for f in forbidden:
        if f in audit_src:
            raise RuntimeError(f"âŒ ç¦æ­¢ç‰‡æ®µ: {f}")


def _execute_trade_with_j_cursor(records, start_j, target_side, units, snapshots):
    # æ‰§è¡Œå™¨ï¼šä¸¥æ ¼ä½¿ç”¨ j æ¸¸æ ‡é€è¡Œæ¨è¿›ï¼›ç¦æ­¢ idx+åç§»é‡ ç›´ç®—
    # è§„åˆ™ï¼šæ¯æ¬¡â€œå®é™…æŠ•æ”¾å‰â€è®°å½•ä¸€æ¬¡å¿«ç…§ï¼›çŠ¶æ€T 0é€€å›ä¸æ¨è¿›æ³¨å·ï¼Œä½† j å¿…é¡»å‰è¿›
    j = start_j
    bet_n = 1
    while bet_n <= len(units) and j < len(records):
        decision_row = records[j]

        # é´çº§é—¸é—¨ï¼ˆé”æ­»ï¼‰ï¼šç¦åŒºå†…ç¦æ­¢ä»»ä½•â€œå®é™…è½æ³¨â€ï¼ˆå« T é‡å¤æŠ•æ”¾ï¼‰
        seen_here = decision_row.get("seen_all")
        if BOOT_FILTER and isinstance(seen_here, int) and seen_here <= 8:
            global BET_IN_FORBIDDEN_SEEN
            BET_IN_FORBIDDEN_SEEN += 1
            raise RuntimeError(f"âŒ ç¦åŒºè½æ³¨ï¼šseen_all={seen_here}|idx={decision_row.get('idx', j)}")

        # å†³ç­–å£å¿«ç…§ï¼ˆå…è®¸è¯»æŒ‡æ ‡ï¼šdiff/rate/meanï¼‰
        snap = {
            "bet_no": bet_n,
            "idx": decision_row.get("idx", j),
            "seen_all": decision_row.get("seen_all"),
            "r": decision_row.get("r"),
            "diff": decision_row.get("diff"),
            "rate": decision_row.get("rate"),
            "mean": decision_row.get("mean"),
        }
        snapshots.append(snap)

        r = decision_row.get("r")
        if r == "T":
            j += 1
            continue

        u = units[bet_n - 1]
        if r == target_side:
            return True, u
        else:
            bet_n += 1
            j += 1
            continue

    return False, 0


def run_strategy_on_boot(records):
    # ç©ºç­–ç•¥å ä½ï¼šé»˜è®¤ä¸æ¿€æ´»ï¼ˆæ¯ç‰ˆå¯è·‘ï¼›ç­–ç•¥æ–¹è‡ªè¡Œæ¥å…¥ç»“æ„æ‰«æåå†æ¿€æ´»ï¼‰
    snapshots = []
    entry, win, lose, bust = 0, 0, 0, 0
    profit = 0.0

    # å¦‚éœ€æ¼”ç»ƒï¼Œå¯å°†ä¸‹é¢å¼€å…³æ”¹ä¸º 1ï¼ˆä»…ç”¨äºéªŒè¯é“¾è·¯ï¼Œä¸ä»£è¡¨ä»»ä½•ç»“æ„ï¼‰
    DEMO_ACTIVATE = 0

    for idx, row in enumerate(records):
        if not DEMO_ACTIVATE:
            continue

        rr = row.get("r")
        if idx < 9 or rr not in ("B", "P"):
            continue

        target_side = "B"
        units = [1, 2, 4, 8]

        entry += 1
        start_j = idx
        start_j += 1  # æŠ•æ”¾ç‚¹ä¸‹ä¸€è¡Œ
        ok, u_win = _execute_trade_with_j_cursor(records, start_j, target_side, units, snapshots)

        if ok:
            win += 1
            profit += (u_win * 0.95 if target_side == "B" else u_win * 1.0)
        else:
            lose += 1
            bust += 1
            profit -= sum(units)

        break  # ä¸€æ¬¡æ€§æ‰«æé”æ­»ï¼šæ¯æ‰¹æ¬¡ä»… 1 æ¬¡æ‰§è¡Œ

    # bust å½’å› å›å¡«ï¼šè¿ç»­ç»Ÿè®¡åªå…è®¸è¯» snapshots
    for s in snapshots:
        if isinstance(s, dict):
            s["trade_bust"] = 1 if bust > 0 else 0

    return {"entry": entry, "win": win, "lose": lose, "bust": bust, "profit": profit, "snapshots": snapshots}
if __name__ == "__main__":
    main()