ğŸ›¡ï¸ğŸ›¡ï¸ğŸ›¡ï¸
# -*- coding: utf-8 -*-
"""
å¹²å‡€æ¯ç‰ˆï½œæ¼”ç»ƒå¼•æ“ï¼ˆV4ï½œåºåˆ—é•¿åº¦å£å¾„ï½œè‡ªåœï½œä¸€æ¬¡æ€§æ‰«æï½œä¸‰å£æœ¯è¯­ç»Ÿä¸€ï½œæœªæ¥æ•°å°å£ï¼‰
============================================================
ç”¨é€”ï¼šæä¾›ä¸€ä»½å¯å¤åˆ¶çš„å¹²å‡€æ¯ç‰ˆï¼Œç”¨äºä»¥åæ‰€æœ‰ç­–ç•¥å¼€å‘ä¸æ¼”ç»ƒã€‚
ç¡¬è§„åˆ™æ‘˜è¦ï¼š
- åªè¯»ä¸ç®—ï¼šç‚¹å·®/å˜åŒ–ç‡/å‡å·®åªè¯» CSV åŸå€¼ï¼Œä¸åœ¨è„šæœ¬å†…é‡ç®—
- ä¸¥æ ¼é›¶æœªæ¥ï¼šä»»æ„ç´¢å¼• idx æ—¶ï¼Œåªèƒ½ä½¿ç”¨ 0..idx è¡Œåšåˆ¤æ–­
- æœ¯è¯­é”æ­»ï¼šåªä¿ç•™ã€Œâ­ / æŠ•æ”¾ç‚¹ã€ï¼ˆç¨‹åºå†…éƒ¨è¡Œæ¨è¿›ä¸ç»“ç®—ä¸å¯¹å¤–å‘½åï¼‰
- å‰ 9 å£æ•´æ‰¹æ¬¡ç¦ç”¨ï¼šåªçœ‹å‰ 9 å£ï¼›åŒæ–¹æœ€å¤§åºåˆ—é•¿åº¦éƒ½ >=3 -> æ•´æ‰¹æ¬¡ç¦ç”¨
- è‡ªåœï¼šæ‰«æä»æ‰¹æ¬¡é¦–å¼€å§‹ï¼›ä¸€æ—¦ä¸¤è¾¹éƒ½æ›¾å‡ºç°åºåˆ—é•¿åº¦ >=3 -> ç«‹å³ç»“æŸæœ¬æ‰¹æ¬¡æ‰«æ
- æ‰«ææ–¹å¼ï¼šå½»åº•ä¸€æ¬¡æ€§ï¼ˆæ¯æ‰¹æ¬¡æœ€å¤š 1 æ¬¡æŠ•æ”¾ï¼‰ï¼›ç¦ç”¨æŒç»­æ‰«æä¸ 2 æ¬¡æŠ•æ”¾æœºä¼š
"""

import csv
import os
from collections import defaultdict

SCAN_MODE_LOCKED = "ä¸€æ¬¡æ€§æ‰«æ"
MONITOR_ENABLE = 0  # ç›‘æµ‹å¼€å…³ï¼š0=å…³ï¼›1=å¼€ï¼ˆåŠ¨æ€ç›‘æµ‹/åŠ¨æ€æ­¢æŸï¼‰
# å¤šæ¬¡å†³ç­–ï¼ˆåŠ¨æ€ç›‘æµ‹/åŠ¨æ€æ­¢æŸï½œé”æ­»ï¼‰ï¼šåŒä¸€ç¬”äº¤æ˜“å†…ï¼Œæ¯ä¸€æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘å…è®¸åšä¸€æ¬¡â€œç»§ç»­/STOPâ€å†³å®šï¼›
# å†³ç­–æ—¶åˆ»è§†ä¸ºä¸€æ¬¡â€œæŠ•æ”¾ç‚¹â€ï¼Œåªå…è®¸è¯»å–è¯¥è¡ŒåŠå†å²æŒ‡æ ‡ï¼›ä¸¥ç¦ä½¿ç”¨è¯¥å†³ç­–å£ä¹‹åï¼ˆt+1 åŠä»¥åï¼‰çš„ä»»ä½•ä¿¡æ¯ã€‚
VERIFY_SPLIT_ENABLE = 0  # éªŒçœŸåˆ†æ‹†å¼€å…³ï¼š0=å…³ï¼›1=å¼€ï¼ˆæ–‡ä»¶åæ’åºå‰ 50%/å 50%ï¼‰


# è¿ç»­ç»Ÿè®¡ï¼ˆäºŒæŒ‡æ ‡äºŒè¿å˜åŒ–ï½œé”æ­»ï¼‰
# - åªåšâ€œäº‹åç»Ÿè®¡â€ï¼šåªèƒ½åŸºäºã€æŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨ã€‘åšåˆ†å¸ƒ/è½¬ç§»ï¼›ç¦æ­¢å›è¯» records åšäºŒè¿å¯¹æ¯”
# - å†³ç­–å£åŸºå‡†ï¼šSTOP/ç»§ç»­ çš„å†³ç­–åªèƒ½ä½¿ç”¨â€œå½“å‰æŠ•æ”¾å‰å¿«ç…§ + å†å²å¿«ç…§â€ï¼›ä¸¥ç¦è¯»å–ä¸‹ä¸€æ¬¡å¿«ç…§å†³å®šè¿™ä¸€æ³¨
# - è§‚æµ‹ç›®æ ‡ï¼šç”¨äº STOP å€™é€‰ï¼Œä¸å¾—å‚ä¸æ¿€æ´»åˆ¤å®šï¼ˆæ¿€æ´»å±‚å¿…é¡»å¯ç‹¬ç«‹è¿è¡Œï¼‰
CONT_STATS_ENABLE = 1
CONT_N_MAX = 12          # åªå±•å¼€å‰ N æ¬¡å®é™…æŠ•æ”¾ï¼ˆå«çŠ¶æ€ T é‡å¤æŠ•æ”¾ï¼‰ï¼›å…¶ä½™åˆå¹¶åˆ° N+ 
CONT_MIN_COUNT = 500     # ä½äºè¯¥æ¬¡æ•°çš„æ ¼å­ä¸å‚ä¸ Top æ¦œï¼Œé¿å…å™ªå£°
CONT_TOPK = 10           # æ¯ä¸ªä½æ¬¡æœ€å¤šè¾“å‡º TopK æ¡è½¬ç§»


# ============================================================
# ç»Ÿä¸€ä»£ç æ¨¡æ¿ï¼ˆV4ï¼Œåºåˆ—é•¿åº¦å£å¾„ï½œä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§æŠ•æ”¾ï¼‰
# çº¦æŸï¼š
# 1) åªè¯»å–å½“å‰ç›®å½•ä¸‹æ‰€æœ‰ .csv
# 2) ä¸å†™æ­»ä»»ä½•ç»å¯¹è·¯å¾„
# 3) è‡ªåŠ¨è¯†åˆ«æ‰¹æ¬¡åˆ—/ç»“æœ/ç‚¹å·®/å˜åŒ–ç‡/å‡å·®
# 4) ç»“æœå¿…é¡»æ˜ å°„ä¸º B/P/T
# 5) ä¸¥æ ¼é›¶æœªæ¥ï¼šrun_strategy_on_boot å†…ä¸¥ç¦è®¿é—®æœªæ¥è¡Œ
# 6) â€œä¸‹ä¸€å£/ä¸‹ä¸€è¡Œâ€ç»Ÿä¸€å®šä¹‰ï¼šidx+1ï¼ˆä¸è·³è¿‡çŠ¶æ€ Tï¼‰
# 7) å•è¾¹/åŒè¾¹ï¼šå‰ 9 å£åˆ†ç±»ï¼›å•è¾¹å¼±ç´¯è®¡ >=3 è½¬åŒè¾¹ï¼›äº¤æ˜“æ¬¡æ•°é™åˆ¶è§æ¨¡æ¿æ–‡æ¡£
#
# æ³¨æ„ï¼šæœªæ¥æ–°å¢/ä¿®æ”¹ç­–ç•¥ï¼Œåªæ”¹ run_strategy_on_boot(records) å†…éƒ¨é€»è¾‘
# ============================================================

# ============================================================
# ç»“æœæ˜ å°„è¡¨ï¼šå·²å®Œæˆ BPT å…¨é˜¶è„±æ•ï¼Œç‰©ç†åŒ¹é…å®éªŒå®¤æ ‡å‡†åŒ– CSV
# ============================================================
MAP_RESULT = {"B": "B", "P": "P", "T": "T"}

# ------------------------------------------------------------
# å·¥å…·ï¼šå®‰å…¨è¯»å– float / intï¼ˆåªè¯»ï¼Œä¸è®¡ç®—ï¼‰
# ------------------------------------------------------------
def safe_float(v, default=None):
    try:
        if v is None or v == "":
            return default
        return float(v)
    except Exception:
        return default

def safe_int(v, default=0):
    try:
        if v is None or v == "":
            return default
        return int(float(v))
    except Exception:
        return default

# ------------------------------------------------------------
# 1) æ•°æ®åŠ è½½ï¼ˆå›ºå®šï¼‰
# ------------------------------------------------------------
def load_all_boots(csv_files):
    boots = defaultdict(list)
    print("æ£€æµ‹åˆ° CSV æ–‡ä»¶æ•°é‡:", len(csv_files))

    for i, fname in enumerate(csv_files, 1):
        if i % 10 == 0:
            print(f"è¿›åº¦: å·²å¤„ç† {i}/{len(csv_files)} ä¸ªæ–‡ä»¶")

        rows = []
        for enc in ("utf-8", "utf-8-sig", "gbk", "gb18030"):
            try:
                with open(fname, "r", encoding=enc) as f:
                    rows = list(csv.DictReader(f))
                break
            except Exception:
                rows = []

        if not rows:
            continue

        col_shoe, col_result, col_diff, col_rate, col_mean = detect_columns(rows[0])

        for r in rows:
            shoe = r.get(col_shoe)
            if shoe is None:
                continue

            res = map_result(r.get(col_result))
            if res not in ("B", "P", "T"):
                continue

            diff = safe_int(r.get(col_diff, 0), 0)
            rate = safe_float(r.get(col_rate), None) if col_rate else None
            mean = safe_float(r.get(col_mean), None) if col_mean else None

            boots[shoe].append({"r": res, "diff": diff, "rate": rate, "mean": mean})

    print("æŒ‰æ‰¹æ¬¡åˆ†ç»„å®Œæˆï¼Œæ‰¹æ¬¡æ€»æ•°:", len(boots))
    return boots


def _run_report(csv_files, title):
    # ============================================================
    # ç‰©ç†å®šä½é”šç‚¹ï¼šäº¤ä»˜éªŒæ”¶æ°´å°ï¼ˆé”æ­»ï½œå”¯ä¸€æœç´¢å®šä½ï¼‰
    # ============================================================
    print("ğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°") 
    
    boots = load_all_boots(csv_files) # åŸæœ‰ä»£ç èµ·ç‚¹ 
    # ... åç»­é€»è¾‘ä¿æŒä¸å˜
    boots = load_all_boots(csv_files)

    total_boots = len(boots)
    playable = 0
    skipped = 0
    insufficient9 = 0
    unplayable = 0

    total_entry = 0
    total_win = 0
    total_lose = 0
    total_bust = 0
    total_profit = 0.0

    cont_stats = init_cont_stats() if (MONITOR_ENABLE and CONT_STATS_ENABLE) else None


    for _, rec in boots.items():
        info = classify_boot_first9(rec)
        if not info["seen9_ok"]:
            insufficient9 += 1
            continue
        if not info["playable"]:
            unplayable += 1
            continue
        playable += 1

        out = run_strategy_on_boot(rec)

        if cont_stats is not None:
            update_cont_stats(cont_stats, out.get('snapshots', []), int(out.get('bust', 0)) > 0)

        total_entry += int(out.get("entry", 0))
        total_win += int(out.get("win", 0))
        total_lose += int(out.get("lose", 0))
        total_bust += int(out.get("bust", 0))
        total_profit += float(out.get("profit", 0.0))

    total_seen = insufficient9 + unplayable + playable
    skipped = insufficient9 + unplayable

    print() 
    print("============================================================")
    print(title)
    print("============================================================")
    print("æŠ•æ”¾ç‚¹: â­")
    print(f"ç›‘æµ‹å¼€å…³  : {'å¼€' if MONITOR_ENABLE else 'å…³'}")
    print(f"æ‰«ææ–¹å¼  : {SCAN_MODE_LOCKED}")
    print("------------------------------------------------------------")
    print("æ€»æ‰¹æ¬¡æ•°    :", total_seen)
    print("å¯å‚ä¸æ‰¹æ¬¡æ•°:", playable)
    print("è·³è¿‡æ‰¹æ¬¡æ•°  :", skipped)
    print("------------------------------------------------------------")
    print("æ¿€æ´»æ¬¡æ•°    :", total_entry)
    print("åŒ¹é…æ¬¡æ•°    :", total_win)
    print("ä¸åŒ¹é…æ¬¡æ•°  :", total_lose)
    print("é˜ˆå€¼å‡»ç©¿æ¬¡æ•°:", total_bust)
    if total_entry > 0:
        match_rate = total_win / total_entry * 100
        exhaustion_rate = total_bust / total_entry * 100
        print(f"åŒ¹é…ç‡      : {match_rate:.2f}%")
        print(f"é˜ˆå€¼å‡»ç©¿ç‡  : {exhaustion_rate:.2f}%")
        print(f"å•æ¬¡å¹³å‡å¢ç›Š: {total_profit / total_entry:.4f}")
    print(f"æ€»å‡€å€¼å¢ç›Š  : {total_profit:.2f}")

    if cont_stats is not None:
        print_cont_stats(cont_stats)



def main():
    csv_files = sorted([f for f in os.listdir(".") if f.lower().endswith(".csv")])
    if VERIFY_SPLIT_ENABLE and len(csv_files) >= 2:
        mid = len(csv_files) // 2
        _run_report(csv_files[:mid], "éªŒçœŸé˜¶æ®µï¼ˆå‰50%ï¼‰")
        _run_report(csv_files[mid:], "éªŒçœŸé˜¶æ®µï¼ˆå50%ï¼‰")
    else:
        _run_report(csv_files, "ä¼˜åŒ–é˜¶æ®µï¼ˆå…¨é‡ï¼‰")





# ------------------------------------------------------------
# 2) åˆ—è‡ªåŠ¨è¯†åˆ«ï¼ˆå›ºå®šï¼‰
# ------------------------------------------------------------
def detect_columns(sample_row):
    keys = list(sample_row.keys())
    def pick(cands):
        # 1:1 ç‰©ç†åŒ¹é… 
        for c in cands:
            if c in sample_row: return c
        # æ¨¡ç³ŠåŒ¹é… 
        for k in keys:
            for c in cands:
                if c.lower() in k.lower(): return k
        return None

# --- é”å®šç‰©ç†è¡¨å¤´ï¼ˆä»¥å£å¾„æ¨¡æ¿ä¸ºå”¯ä¸€çœŸæºï¼‰ ---
col_shoe   = pick(["Batch", "æ‰¹æ¬¡", "å…¨å±€æ‰¹æ¬¡å·", "shoe", "é´å·", "é´"])
col_result = pick(["Exhaustion", "ç»“æœ", "Result", "r", "åŒ¹é…é¡¹", "res"])
col_diff   = pick(["ç‚¹å·®", "diff"])
col_rate   = pick(["å˜åŒ–ç‡", "rate"])
col_mean   = pick(["å‡å·®", "mean"])

    # ç‰©ç†ç´¢å¼•å…œåº•é€»è¾‘ [cite: 63]
    if col_shoe is None: col_shoe = keys[0]
    if col_result is None: col_result = keys[5] # å¯¹åº”æ‚¨ CSV çš„ç¬¬ 6 åˆ—
    
    return col_shoe, col_result, col_diff, col_rate, col_mean
# ------------------------------------------------------------
# 3) æ‰¹æ¬¡çº§è¿‡æ»¤ï¼ˆå‰ 9 å£ï½œåºåˆ—é•¿åº¦å£å¾„ï½œé”æ­»ï¼‰
# è§„åˆ™ï¼šåªçœ‹å‰ 9 å£ï¼ˆB/P/T éƒ½è®¡å£æ•°ï¼‰ï¼›è®¡ç®—å‰ 9 å£å†…ï¼ŒB ä¸ P çš„â€œæœ€å¤§åºåˆ—é•¿åº¦â€ï¼ˆT ä¸è®¡å…¥ä¸”ä¸æ‰“æ–­ï¼‰
# è‹¥ B æœ€å¤§åºåˆ—é•¿åº¦ >=3 ä¸” P æœ€å¤§åºåˆ—é•¿åº¦ >=3 -> ä¸å¯æ‰“æ‰¹æ¬¡
# ------------------------------------------------------------
def classify_boot_first9(records):
    seen = 0
    max_len = {"B": 0, "P": 0}
    cur_side = None
    cur_len = 0

    for row in records:
        if seen >= 9:
            break
        r = row.get("r")
        if r not in ("B", "P", "T"):
            continue
        seen += 1

        if r == "T":
            # çŠ¶æ€ T ä½ç§»é›¶åå·®ä¸”ä¸æ‰“æ–­åºåˆ—é•¿åº¦
            continue

        if cur_side is None:
            cur_side = r
            cur_len = 1
        elif r == cur_side:
            cur_len += 1
        else:
            max_len[cur_side] = max(max_len[cur_side], cur_len)
            cur_side = r
            cur_len = 1

        max_len[cur_side] = max(max_len[cur_side], cur_len)

    seen9_ok = (seen >= 9)
    playable = True
    if seen9_ok and (max_len["B"] >= 3 and max_len["P"] >= 3):
        playable = False

    return {
        "seen9_ok": seen9_ok,
        "playable": playable,
        "max_len_B": max_len["B"],
        "max_len_P": max_len["P"],
    }



# ------------------------------------------------------------
# 4) è¿ç»­ç»Ÿè®¡ï¼ˆäºŒæŒ‡æ ‡äºŒè¿å˜åŒ–ï½œäº‹åç»Ÿè®¡æ¨¡å—ï¼‰
# - çŠ¶æ€1ï¼š(|ç‚¹å·®|æ¡¶, å˜åŒ–ç‡ç›‘æµ‹æ¡¶)
# - çŠ¶æ€2ï¼š(|ç‚¹å·®|æ¡¶, å‡å·®æ¡¶)
# æ³¨ï¼šåªè¯»å¿«ç…§ï¼Œä¸å›è¯» recordsï¼›å¿«ç…§æ¥è‡ªâ€œæ¯æ¬¡å®é™…æŠ•æ”¾å‰â€
# ------------------------------------------------------------
def _bucket_abs_diff(diff):
    try:
        v = abs(int(diff))
    except Exception:
        v = 0
    if v < 0:
        v = 0
    if v > 9:
        v = 9
    return v

def _bucket_rate_monitor(rate):
    # ç›‘æµ‹é˜ˆå€¼ï¼š<0 / [0,2) / >=2 / æ— æ•ˆ
    if rate is None:
        return "Ræ— æ•ˆ"
    try:
        v = float(rate)
    except Exception:
        return "Ræ— æ•ˆ"
    if v < 0:
        return "R<0"
    if v < 2:
        return "R[0,2)"
    return "R>=2"

def _bucket_mean_monitor(mean):
    # å‡å·®æ¡¶ï¼šmean=0 å•åˆ—ï¼›|mean|<3ï¼›|mean|>=3ï¼›æ— æ•ˆ
    if mean is None:
        return "Mæ— æ•ˆ"
    try:
        v = float(mean)
    except Exception:
        return "Mæ— æ•ˆ"
    if v == 0:
        return "M0"
    if abs(v) >= 3:
        return "M>=3"
    return "M<3"

def init_cont_stats():
    return {
        "rate": defaultdict(lambda: {"cnt": 0, "bust": 0}),
        "mean": defaultdict(lambda: {"cnt": 0, "bust": 0}),
        "meta": {"snap_total": 0, "boot_with_snap": 0},
    }

def update_cont_stats(cont_stats, snapshots, bust_flag):
    # snapshots: list[dict]ï¼Œæ¯æ¡è‡³å°‘åŒ…å« bet_no/diff/rate/mean
    if not snapshots or len(snapshots) < 2:
        return
    # åªæŒ‰å‡ºç°é¡ºåºå¤„ç†ï¼›è‹¥ç¼º bet_no ä¹Ÿä¸å½±å“äºŒè¿
    cont_stats["meta"]["boot_with_snap"] += 1
    cont_stats["meta"]["snap_total"] += len(snapshots)

    # é™åˆ¶å±•å¼€é•¿åº¦ï¼šå‰ Nï¼Œè¶…è¿‡çš„å½’å…¥ N+ï¼ˆä»…ç”¨äºè¾“å‡ºæ—¶èšåˆï¼›ç»Ÿè®¡ä»æŒ‰åŸåºåˆ—è®¡ï¼‰
    for i in range(1, len(snapshots)):
        prev = snapshots[i - 1]
        cur = snapshots[i]

        n = safe_int(cur.get("bet_no", i + 1), i + 1)
        n_label = n if n <= CONT_N_MAX else f"{CONT_N_MAX}+"

        prev_state_rate = (_bucket_abs_diff(prev.get("diff", 0)), _bucket_rate_monitor(prev.get("rate")))
        cur_state_rate = (_bucket_abs_diff(cur.get("diff", 0)), _bucket_rate_monitor(cur.get("rate")))
        key_rate = (n_label, prev_state_rate, cur_state_rate)

        prev_state_mean = (_bucket_abs_diff(prev.get("diff", 0)), _bucket_mean_monitor(prev.get("mean")))
        cur_state_mean = (_bucket_abs_diff(cur.get("diff", 0)), _bucket_mean_monitor(cur.get("mean")))
        key_mean = (n_label, prev_state_mean, cur_state_mean)

        cont_stats["rate"][key_rate]["cnt"] += 1
        cont_stats["mean"][key_mean]["cnt"] += 1
        if bust_flag:
            cont_stats["rate"][key_rate]["bust"] += 1
            cont_stats["mean"][key_mean]["bust"] += 1

def _print_cont_block_one(title, bucket_dict):
    print()
    print("------------------------------------------------------------")
    print(title)
    print("ï¼ˆäºŒæŒ‡æ ‡äºŒè¿å˜åŒ–ï½œä»…äº‹åç»Ÿè®¡ï½œåªè¯»å¿«ç…§ï½œç”¨äº STOP å€™é€‰ï¼‰")
    print("------------------------------------------------------------")

    # æŒ‰æŠ•æ”¾ä½åˆ†ç»„è¾“å‡º TopK
    # key: (n_label, prev_state, cur_state)
    groups = defaultdict(list)
    for k, v in bucket_dict.items():
        n_label = k[0]
        groups[n_label].append((k, v))

    # æ’åºæŠ•æ”¾ä½ï¼šæ•°å­—åœ¨å‰ï¼ŒN+ åœ¨å
    def n_sort(x):
        if isinstance(x, int):
            return (0, x)
        return (1, 10**9)

    for n_label in sorted(groups.keys(), key=n_sort):
        items = groups[n_label]
        # è¿‡æ»¤ä½æ ·æœ¬
        items = [it for it in items if it[1]["cnt"] >= CONT_MIN_COUNT]
        if not items:
            continue
        # æŒ‰é˜ˆå€¼å‡»ç©¿ç‡é™åºï¼Œå…¶æ¬¡æŒ‰æ¬¡æ•°é™åº
        items.sort(key=lambda it: ((it[1]["bust"] / it[1]["cnt"]) if it[1]["cnt"] else 0, it[1]["cnt"]), reverse=True)
        print(f"[ç¬¬{n_label}æ¬¡æŠ•æ”¾] Top{CONT_TOPK}ï¼ˆæ¬¡æ•°>= {CONT_MIN_COUNT}ï¼‰")
        for k, v in items[:CONT_TOPK]:
            _, prev_state, cur_state = k
            cnt = v["cnt"]
            bust = v["bust"]
            er = (bust / cnt * 100) if cnt else 0.0
            pd, pr = prev_state
            cd, cr = cur_state
            print(f"  ({pd},{pr})->({cd},{cr})  æ¬¡æ•°={cnt}  é˜ˆå€¼å‡»ç©¿={bust}  é˜ˆå€¼å‡»ç©¿ç‡={er:.2f}%")

def print_cont_stats(cont_stats):
    if not CONT_STATS_ENABLE:
        return
    if cont_stats is None:
        return
    if cont_stats["meta"]["boot_with_snap"] <= 0:
        return

    _print_cont_block_one("äºŒæŒ‡æ ‡äºŒè¿å˜åŒ–ï¼š(|ç‚¹å·®|æ¡¶, å˜åŒ–ç‡ç›‘æµ‹æ¡¶)", cont_stats["rate"])
    _print_cont_block_one("äºŒæŒ‡æ ‡äºŒè¿å˜åŒ–ï¼š(|ç‚¹å·®|æ¡¶, å‡å·®æ¡¶)", cont_stats["mean"])



# ------------------------------------------------------------
# 5) å•æ‰¹æ¬¡ç­–ç•¥å…¥å£ï¼ˆå”¯ä¸€å…¥å£ï½œä¸¥æ ¼é›¶æœªæ¥ï¼‰
# è¯´æ˜ï¼š
# - è¿™é‡Œåªæä¾›â€œç©ºç­–ç•¥â€å ä½ï¼šé»˜è®¤ä¸æ¿€æ´»
# - ä»»ä½•ç­–ç•¥å¼€å‘ï¼Œåªå…è®¸ä¿®æ”¹æœ¬å‡½æ•°å†…éƒ¨
# - è‹¥ä½ éœ€è¦è¿ç»­ç»Ÿè®¡ï¼šè¯·åœ¨æ¯æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘append å¿«ç…§åˆ° snapshots
#   å¿«ç…§æ ¼å¼å»ºè®®ï¼š{"bet_no":1, "diff":diff, "rate":rate, "mean":mean}
# ------------------------------------------------------------
def run_strategy_on_boot(records):
    # 1. ç‰©ç†æ§½ä½åˆå§‹åŒ–
    snapshots = []
    entry, win, lose, bust = 0, 0, 0, 0
    profit = 0.0

    for idx, r in enumerate(records):
        # --- Aå±‚ï¼šç»“æ„æ¿€æ´» (DNAæ£€æµ‹) ---
        # å¼ºåˆ¶é”æ­»ï¼šæ¿€æ´»å¿…é¡»åœ¨è¾…è½´é•¿åº¦ Lw = 1 çš„æ—¶åˆ»
        if not (current_w_len == 1 and dna_match):
            continue

        # --- Bå±‚ï¼šç¥è°•å®¡è®¡ (Oracle Audit) ---
        # æ¢æµ‹ç‚¹ï¼šW1 å¤„å…¨é‡è®°å½•ï¼Œä¸è®¾ç‰©ç†è¿‡æ»¤
        is_oracle_pass = True 

        if is_oracle_pass:
            # --- Cå±‚ï¼šæ‰§è¡Œä¸ 1248 åŠ¨æ€å½’å›  ---
            entry += 1
            units = [1, 2, 4, 8]
            is_settled = False

            for b_idx, u in enumerate(units):
                # ç‰©ç†æ­¥è¿›ï¼šé€è¡Œè¯»å–ç»“æœï¼Œä¸¥ç¦åˆ‡ç‰‡ 
                curr_row = records[idx + b_idx]
                
                # å½’å› å¿«ç…§ï¼šè®°å½•å½“å‰å±‚çº§ï¼Œé”å®š idx ä¸º W1 è¡Œå·
                snap = {'bet_no': b_idx + 1, 'idx': idx, 'mean': curr_row['mean']}
                snapshots.append(snap)

                # åŠ¨æ€ç»“ç®—ï¼šå‘ç°åŒ¹é…ç«‹å³ Match å¹¶ç‰©ç†æ–­æµ
                if curr_row['r'] == target:
                    win += 1
                    profit += (u * 0.95)
                    is_settled = True
                    break 

            if not is_settled:
                lose += 1
                bust += 1 # 1248 å…¨è¾“å³ä¸ºé˜ˆå€¼å‡»ç©¿
                profit -= sum(units)
            
            break # ä¸€æ¬¡æ€§æ‰«æé”æ­»ï¼šæ¯æ‰¹æ¬¡ä»… 1 æ¬¡æ‰§è¡Œ
            
    return {"entry": entry, "win": win, "lose": lose, "bust": bust, "profit": profit, "snapshots": snapshots}    


if __name__ == "__main__":
    main()