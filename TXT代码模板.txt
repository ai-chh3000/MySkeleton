# ã€ç‰ˆæœ¬æ°´å°ï¼ˆäº¤ä»˜éªŒæ”¶ç”¨ï½œé”æ­»ï¼‰ã€‘
# æ°´å°ï¼šğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°
# -*- coding: utf-8 -*-
import csv
import os
import inspect
import hashlib
import re
import sys


# ==========================
# å®‰å…¨ç¡¬é—¸é—¨ï¼ˆæ¨¡æ¿åŠ å›ºï½œé”æ­»ï¼‰
# ==========================
WATERMARK_TEXT = "ğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°"

# æŒ‡æ ‡é”®ï¼ˆé”æ­»ï¼‰
METRIC_KEYS = {"diff", "rate", "mean", "rate_raw", "mean_raw"}

# ==========================
# ç»Ÿä¸€è¿è§„å‡ºå£ï¼ˆè¡¥ä¸Aï½œé”æ­»ï¼‰
# ==========================
class GuardViolation(RuntimeError):
    """é—¨ç¦/å®¡è®¡è¿è§„ï¼šç»Ÿä¸€å‡ºå£ï¼Œç¦æ­¢ tracebackã€‚"""
    def __init__(self, *, code, rule_id, phase, msg, evidence, exit_code=2):
        super().__init__(msg)
        self.code = str(code)
        self.rule_id = int(rule_id) if rule_id is not None else 0
        self.phase = str(phase)
        self.msg = str(msg)
        self.evidence = str(evidence)
        self.exit_code = int(exit_code)

def _raise_guard(*, code, rule_id, phase, msg, evidence, exit_code=2):
    raise GuardViolation(code=code, rule_id=rule_id, phase=phase, msg=msg, evidence=evidence, exit_code=exit_code)

def _as_guard_from_exception(e):
    """æŠŠæœªçŸ¥å¼‚å¸¸æ˜ å°„ä¸ºå¯å®¡è®¡å•å±é”™è¯¯ï¼ˆä¸æ”¾æ¾å®¡è®¡å¼ºåº¦ï¼‰ã€‚"""
    etxt = f"{type(e).__name__}: {e}"
    if isinstance(e, RuntimeError):
        s = str(e)
        if "BET_IN_FORBIDDEN_SEEN" in s:
            return GuardViolation(code="BET_IN_FORBIDDEN_SEEN", rule_id=10, phase="EXECUTE", msg=s, evidence=s, exit_code=2)
        if "IDX_OFFSET_FORBIDDEN" in s:
            return GuardViolation(code="IDX_OFFSET_FORBIDDEN", rule_id=13, phase="SCAN", msg=s, evidence=s, exit_code=2)
        if "SELF_AUDIT_FAIL" in s:
            return GuardViolation(code="SELF_AUDIT_FAIL", rule_id=11, phase="DONE", msg=s, evidence=s, exit_code=3)
    return GuardViolation(code="UNHANDLED", rule_id=0, phase="UNKNOWN", msg=etxt, evidence=etxt, exit_code=2)


def _print_watermark_once():
    global _WATERMARK_PRINTED
    if globals().get("_WATERMARK_PRINTED", False):
        return
    print(WATERMARK_TEXT)
    _WATERMARK_PRINTED = True

def _print_force_proof_block():
    global _PROOF_BLOCK_PRINTED
    if globals().get("_PROOF_BLOCK_PRINTED", False):
        return
    print("ã€å¼ºåˆ¶è‡ªè¯è¾“å‡ºã€‘")
    print(f"ç»“æ„é—¸é—¨ï¼š{STRUCT_SCAN_TEXT}")
    print(f"é´çº§å¼€å…³ï¼š{BOOT_FILTER_TEXT}")
    try:
        denom = int(globals().get("_LAST_ENTRY_FOR_PROOF", 0) or 0)
        pct = (BET_IN_FORBIDDEN_SEEN / denom * 100.0) if denom > 0 else 0.0
    except Exception:
        pct = 0.0
    print(f"BET_IN_FORBIDDEN_SEEN = {BET_IN_FORBIDDEN_SEEN} ({pct:.2f}%)")
    print(f"PPBB_IDENTITY_CHECKED = {PPBB_CHECKED} | PPBB_MISMATCH = {PPBB_MISMATCH}")
    # è§£æè®¡æ•°ï¼ˆè¡¥ä¸Bï¼‰
    try:
        print(f"RATE_PARSE_FAIL_INPUT = {RATE_PARSE_FAIL_INPUT} | RATE_MISSING_RAW_INPUT = {RATE_MISSING_RAW_INPUT}")
        print(f"MEAN_PARSE_FAIL_INPUT = {MEAN_PARSE_FAIL_INPUT} | MEAN_MISSING_RAW_INPUT = {MEAN_MISSING_RAW_INPUT}")
    except Exception:
        pass
    if denom > 0:
        _PROOF_BLOCK_PRINTED = True

def _print_single_screen_error(gv: 'GuardViolation'):
    # ä»»ä½•å¼‚å¸¸ä¹Ÿè¦æ»¡è¶³ï¼šæ°´å° + å¼ºåˆ¶è‡ªè¯å—ï¼ˆè‹¥å·²æ‰“å°åˆ™ä¼šè‡ªåŠ¨å»é‡ï¼‰
    try:
        _print_watermark_once()
    except Exception:
        pass
    try:
        _print_force_proof_block()
    except Exception:
        pass
    try:
        _flush_audit_log("FAIL")
    except Exception:
        pass
    print(f"âŒâŒâŒ è§¦å‘æ¡ç›®={gv.rule_id} | code={gv.code} | phase={gv.phase} | evidence={gv.evidence}")


class MetricGuardRow(dict):
    """EXECUTE/SETTLE é˜¶æ®µï¼šrow å·²å»æŒ‡æ ‡åŒ–ï¼›ä»»ä½•è¯»å–æŒ‡æ ‡é”®ä¸€å¾‹ raiseã€‚"""
    def get(self, k, default=None):
        if k in METRIC_KEYS:
            raise RuntimeError(f"ILLEGAL_METRIC_ACCESS_IN_EXECUTE: {k}")
        return super().get(k, default)

    def __getitem__(self, k):
        if k in METRIC_KEYS:
            raise RuntimeError(f"ILLEGAL_METRIC_ACCESS_IN_EXECUTE: {k}")
        return super().__getitem__(k)

class Snapshot:
    """STAR_ROW æœ€å°ä¸å¯å˜å¿«ç…§ï¼šç¦æ­¢ç›´è¯»æŒ‡æ ‡ï¼ˆå¿…é¡»èµ° secure_read_metricï¼‰ã€‚"""
    __slots__ = ("_metrics", "_boot_id", "_idx", "_seen_all", "_rr", "_source")

    def __init__(self, metrics: dict, *, boot_id, idx, seen_all, rr, source="STAR_ROW"):
        self._metrics = dict(metrics)
        self._boot_id = boot_id
        self._idx = int(idx)
        self._seen_all = int(seen_all)
        self._rr = rr
        self._source = source

    # ---- å…ƒä¿¡æ¯ï¼ˆå…è®¸ç›´è¯»ï¼‰----
    @property
    def boot_id(self): return self._boot_id

    @property
    def idx(self): return self._idx

    @property
    def seen_all(self): return self._seen_all

    @property
    def rr(self): return self._rr

    @property
    def source(self): return self._source

    # ---- ç¦æ­¢ dict é£æ ¼ä¸å±æ€§ç›´è¯»æŒ‡æ ‡ ----
    def get(self, *args, **kwargs):
        raise RuntimeError("SNAPSHOT_DIRECT_GET_FORBIDDEN: use secure_read_metric")

    def __getitem__(self, k):
        raise RuntimeError("SNAPSHOT_DIRECT_ITEM_FORBIDDEN: use secure_read_metric")

    def __getattribute__(self, name):
        if name in METRIC_KEYS:
            raise RuntimeError(f"SNAPSHOT_DIRECT_ATTR_FORBIDDEN: {name}")
        return object.__getattribute__(self, name)

def phase_transition(phase, to_phase):
    order = {"SCAN": 0, "DECISION": 1, "EXECUTE": 2, "SETTLE": 3, "DONE": 4, "REPORT": 9}
    if phase not in order or to_phase not in order:
        raise RuntimeError("PHASE_INVALID")
    if order[to_phase] < order[phase]:
        raise RuntimeError(f"PHASE_BACKJUMP: {phase}->{to_phase}")
    return to_phase


def advance_one_row(cursor, records, *, phase, boot_id):
    """æ¨è¿›å”¯ä¸€å…¥å£ï¼ˆé”æ­»ï¼‰ã€‚

    ç›®çš„ï¼šå¯¹å¤–åªæš´éœ²â€œé€è¡Œæ¨è¿›â€ï¼Œç¦æ­¢ä»»ä½• idx+åç§»/éšæœºè·³è½¬è¯»å–æœªæ¥è¡Œã€‚
    - cursor: å½“å‰æ¸¸æ ‡ï¼ˆintï¼‰ï¼ŒæŒ‡å‘å½“å‰è¡Œ
    - records: å½“å‰æ‰¹æ¬¡çš„è¡Œåˆ—è¡¨
    è¿”å›ï¼š(new_cursor, row)ï¼›è‹¥è¶Šç•Œè¿”å› (None, None)

    è¯´æ˜ï¼šå‡½æ•°å†…éƒ¨ä½¿ç”¨ +1 å±äºâ€œå°è£…å†…å®ç°â€ï¼Œå¯¹å¤–ä¸æš´éœ²åç§»é‡èƒ½åŠ›ã€‚
    """
    if cursor is None:
        return None, None
    try:
        c = int(cursor)
    except Exception:
        raise RuntimeError(f"ADVANCE_CURSOR_INVALID: boot_id={boot_id} cursor={cursor}")
    nxt = c + 1
    if nxt < 0 or nxt >= len(records):
        return None, None
    return nxt, records[nxt]

def secure_read_metric(snap, key, phase, *, who, idx, boot_id, seen_all):
    """è¯»æŒ‡æ ‡å”¯ä¸€å…¥å£ï¼ˆé”æ­»ï¼‰ã€‚

    å¥‘çº¦ï¼šsecure_read_metric(snap, key, phase, *, who, idx, boot_id, seen_all)
      - key âˆˆ {diff, rate, mean, rate_raw, mean_raw}
      - å…è®¸ï¼š
          (A) phase==DECISION ä¸” who==STAR ä¸” seen_all>=9 ä¸” snap.source==STAR_ROW
          (B) phase==REPORT ä¸” who==REPORT ä¸” snap.source==STAR_ROWï¼ˆä»…ç”¨äºæ±‡æ€»è¾“å‡ºï¼Œä¸å‚ä¸å†³ç­–ï¼‰
      - å…¶ä»–ï¼šraise
    """
    if key not in METRIC_KEYS:
        raise RuntimeError("METRIC_NAME_INVALID")

    # ä»…å…è®¸ STAR_ROW å¿«ç…§
    try:
        if getattr(snap, "source", None) != "STAR_ROW":
            raise RuntimeError("SNAPSHOT_SOURCE_INVALID")
    except Exception:
        raise RuntimeError("SNAPSHOT_SOURCE_INVALID")

    ok_decision = (phase == "DECISION" and who == "STAR")
    ok_report = (phase == "REPORT" and who == "REPORT")
    if not (ok_decision or ok_report):
        raise RuntimeError(f"ILLEGAL_METRIC_ACCESS: phase={phase} who={who} metric={key}")

    # seen_all >= 9ï¼ˆå†³ç­–ä¸æŠ¥å‘Šå‡è¦æ±‚ï¼‰
    try:
        if int(seen_all) < 9:
            raise RuntimeError("SNAPSHOT_SEEN_LT9")
    except Exception:
        raise RuntimeError("SNAPSHOT_SEEN_PARSE_FAIL")

    # ä¸€è‡´æ€§ï¼ˆå°½é‡åšï¼Œä¸å¯è§£æåˆ™ä¸é˜»æ–­ï¼‰
    try:
        if int(getattr(snap, "idx")) != int(idx):
            raise RuntimeError("SNAPSHOT_IDX_MISMATCH")
    except Exception:
        pass
    try:
        if int(getattr(snap, "seen_all")) != int(seen_all):
            raise RuntimeError("SNAPSHOT_SEEN_MISMATCH")
    except Exception:
        pass
    try:
        if str(getattr(snap, "boot_id")) != str(boot_id):
            raise RuntimeError("SNAPSHOT_BOOT_MISMATCH")
    except Exception:
        pass

    # å–å€¼ï¼ˆç”¨ object.__getattribute__ ç»•è¿‡ __getattribute__ é™åˆ¶ï¼‰
    metrics = object.__getattribute__(snap, "_metrics")
    return metrics.get(key)

def secure_write_star_snapshot(row, phase, *, seen_all, rr, boot_id, star_idx, star_snapshot_is_none):
    """å†™å¿«ç…§å”¯ä¸€å…¥å£ï¼ˆé”æ­»ï¼‰ã€‚"""
    if phase != "DECISION":
        raise RuntimeError("STAR_SNAPSHOT_PHASE_NOT_DECISION")
    if not star_snapshot_is_none:
        raise RuntimeError("STAR_SNAPSHOT_DUPLICATE")
    if rr == "T":
        raise RuntimeError("STAR_SNAPSHOT_ON_T")
    try:
        if int(seen_all) < 9:
            raise RuntimeError("STAR_SNAPSHOT_SEEN_LT9")
    except Exception:
        raise RuntimeError("STAR_SNAPSHOT_SEEN_PARSE_FAIL")

    # åªåœ¨ DECISION/STAR è¯»æŒ‡æ ‡
    tmp_snap = Snapshot({"diff": row.get("diff"), "rate": row.get("rate"), "mean": row.get("mean"),
                         "rate_raw": row.get("rate_raw"), "mean_raw": row.get("mean_raw")},
                        boot_id=boot_id, idx=star_idx, seen_all=seen_all, rr=rr, source="STAR_ROW")
    d = secure_read_metric(tmp_snap, "diff", phase, who="STAR", idx=star_idx, boot_id=boot_id, seen_all=seen_all)
    try:
        if int(float(d)) == 0:
            raise RuntimeError("STAR_SNAPSHOT_DIFF_ZERO")
    except Exception:
        raise RuntimeError("STAR_SNAPSHOT_DIFF_PARSE_FAIL")

    return tmp_snap

def write_star_snapshot(phase, star_row, star_idx):
    """å…¼å®¹å…¥å£ï¼šå†…éƒ¨è½¬å‘åˆ° secure_write_star_snapshotï¼ˆç¦æ­¢å…¶ä»–å†™æ³•ï¼‰ã€‚"""
    rr = star_row.get("r")
    seen_all = star_row.get("seen_all")
    boot_id = star_row.get("shoe_id")
    return secure_write_star_snapshot(
        star_row, phase,
        seen_all=seen_all, rr=rr, boot_id=boot_id, star_idx=star_idx,
        star_snapshot_is_none=True
    )

def _to_row_lite(row):
    """å»æŒ‡æ ‡åŒ–ï¼šè¿›å…¥ EXECUTE/SETTLE çš„ row åªä¿ç•™å¿…è¦å­—æ®µã€‚"""
    keep = {
        "r": row.get("r"),
        "shoe_id": row.get("shoe_id"),
        "idx": row.get("idx"),
        "seen_all": row.get("seen_all"),
        "file": row.get("file"),
        "sub_batch": row.get("sub_batch"),
    }
    return MetricGuardRow(keep)

def guard_future_rows(records, start_j):
    """ä» start_j å¼€å§‹æŠŠåç»­è¡Œæ›¿æ¢ä¸º RowLite(MetricGuardRow)ï¼Œä»æ ¹æºå»æŒ‡æ ‡ã€‚"""
    for k in range(start_j, len(records)):
        r = records[k]
        if isinstance(r, MetricGuardRow):
            continue
        records[k] = _to_row_lite(r)

# ==========================
# å…¨å±€å¼€å…³ï¼ˆå¿…é¡»æ˜¾å¼å®šä¹‰ï½œé¿å… NameErrorï¼‰
# ==========================
# ç›‘æµ‹å¼€å…³ï¼š0=å…³ï¼Œ1=å¼€ï¼ˆé»˜è®¤å…³ï¼›ä»…å½±å“â€œç›‘æµ‹/é›·è¾¾â€è¾“å‡ºï¼Œä¸å¾—å½±å“é›¶æœªæ¥ä¸ä¸‹æ³¨è·¯å¾„ï¼‰
MONITOR_ENABLE = 0

# éªŒè¯åˆ†æ‹†å¼€å…³ï¼š0=å…³ï¼Œ1=å¼€ï¼ˆé»˜è®¤å…³ï¼›è‹¥å¼€å¯ï¼Œå¿…é¡»ä»æ»¡è¶³é›¶æœªæ¥ä¸ä¸€æ¬¡æ€§æ‰«æçº¦æŸï¼‰
VERIFY_SPLIT_ENABLE = 0




# è¡¨å¤´è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡
_HEADER_MAPPING_PRINTED = False

# PP/BB æ’ç­‰å¼è‡ªè¯è®¡æ•°ï¼ˆé”æ­»ï¼‰
ENFORCE_PPBB_SEMANTICS = 1  # 1=å¼ºåˆ¶æŠ½æ£€ç‚¹å·®æ’ç­‰å¼ä¸ç»“æœæ˜ å°„ï¼ˆPP=é—²ç‚¹/BB=åº„ç‚¹ï¼‰
PPBB_CHECKED = 0
PPBB_MISMATCH = 0
PPBB_FIRST_EVIDENCE = None

# ==========================
# æ­£å€¼è§¦å‘è‡ªå®¡é—¸é—¨ï¼ˆæ—¶é—´ç®¡ç†å±€ï½œé”æ­»ï¼‰
# ==========================
# å¼€å…³ï¼š1=å¯ç”¨ï¼Œ0=å…³é—­
POSITIVE_AUDIT_ENABLE = 1

# è§¦å‘é—¨æ§›ï¼ˆäºŒé€‰ä¸€æˆ–åŒæ—¶å¯ç”¨ï¼›é»˜è®¤ä»… Total>0ï¼‰
POSITIVE_AUDIT_TRIGGER_TOTAL = 1   # Total_Profit > 0
POSITIVE_AUDIT_TRIGGER_AVG = 0     # Avg_Profit > 0

# å½±å­é‡ç®—ï¼ˆå¯é€‰ï½œé»˜è®¤å…³ï¼›ä»…ç”¨äºè‡ªè¯ä¸€è‡´æ€§ï¼Œä¸æ”¹ç­–ç•¥é€»è¾‘ï¼‰
POSITIVE_AUDIT_SHADOW_RECHECK = 0

# è¿è¡Œæ€è‡ªè¯æ ‡è®°ï¼ˆé”æ­»ï¼‰
_WATERMARK_PRINTED = False
_PROOF_BLOCK_PRINTED = False
_SELFTEST_PASSED = False
_SOURCE_HASHES_PRINTED = False


# è¾“å‡ºé™é»˜å¼€å…³ï¼š1=é™é»˜ï¼ˆä»…ä¿ç•™ä¸»æŠ¥å‘Š+å¼ºåˆ¶è‡ªè¯ï¼›ä¸æ‰“å°è¡¨å¤´è‡ªè¯/L1åˆ†å¸ƒ/è¿ç»­ç»Ÿè®¡ï¼‰ï¼Œ0=è¯¦ç»†
SILENT_MODE = 1

# å®¡æŸ¥è·‘å¼€å…³ï¼ˆæ—¶é—´ç®¡ç†å±€ï½œé”æ­»ï¼‰
# è§„åˆ™ï¼šå½“ AUDIT_RUN=1 æ—¶ï¼Œå¿…é¡»æ— æ¡ä»¶è¾“å‡ºâ€œå®¡æŸ¥è·‘å¿…å‡ºå—â€ï¼ˆå« L1 ä¸‰å—é”æ­»æ ‡é¢˜ï¼‰ï¼Œä¸å— SILENT_MODE å½±å“ã€‚
AUDIT_RUN = 0  # 0=æ™®é€šè·‘ï¼›1=å®¡æŸ¥è·‘ï¼ˆå®¡æŸ¥è·‘å¿…å‡ºï¼‰

# ============================================================
# å®¡è®¡æ—¥å¿—ç¼“å†²ï¼ˆé»˜è®¤é™é»˜ï½œä»…å¤±è´¥/æŠ¥é”™è¾“å‡ºï½œé”æ­»ï¼‰
# - ç›®çš„ï¼šé¿å…å“ˆå¸Œ/loc/å®¡è®¡æ˜ç»†å ç”¨æ‰“å°é¢æ¿
# - è¡Œä¸ºï¼šæ­£å¸¸âœ…é€šè¿‡ä¸æ‰“å°ï¼›é‡åˆ°âŒâŒâŒæˆ–å¼‚å¸¸æ—¶ä¸€æ¬¡æ€§åå‡ºç¼“å†²åŒº
# ============================================================
AUDIT_FAIL_ONLY = 1  # 1=ä»…å¤±è´¥è¾“å‡ºâœ…ï¼›0=æ€»æ˜¯è¾“å‡ºï¼ˆè°ƒè¯•ç”¨ï¼‰
_AUDIT_LOG_BUF = []

def _audit_log(line: str):
    try:
        _AUID = AUDIT_FAIL_ONLY
    except Exception:
        _AUID = 1
    # å§‹ç»ˆè®°å½•ï¼›æ˜¯å¦æ‰“å°ç”± flush å†³å®š
    _AUDIT_LOG_BUF.append(str(line))

def _flush_audit_log(tag: str = ""):
    global _AUDIT_LOG_BUF
    if not _AUDIT_LOG_BUF:
        return
    # ä»…åœ¨å¤±è´¥è·¯å¾„è°ƒç”¨æœ¬å‡½æ•°ï¼›å› æ­¤ä¸å†é¢å¤–åˆ¤æ–­é€šè¿‡/å¤±è´¥
    head = "ã€å®¡è®¡æ—¥å¿—ï¼ˆä»…å¤±è´¥è¾“å‡ºï¼‰ã€‘"
    if tag:
        head += f" {tag}"
    print(head)
    for x in _AUDIT_LOG_BUF:
        print(x)
    _AUDIT_LOG_BUF = []

# é´çº§å¼€å…³ï¼ˆé”æ­»ï¼‰ï¼šä»…é™åˆ¶â€œå®é™…è½æ³¨â€æ˜¯å¦å…è®¸å‘ç”Ÿåœ¨å‰8å£ï¼ˆseen_all=1..8ï¼‰
# BOOT_FILTER=ONâœ…ï¼šç¦ä¸‹æ³¨ seen_all=1..8ï¼›ç¬¬9å£èµ·å…è®¸
# BOOT_FILTER=OFFâ›”ï¼šé´é¦–å…è®¸ä¸‹æ³¨
BOOT_FILTER = 1  # 1=ONâœ…ï¼Œ0=OFFâ›”
BOOT_FILTER_TEXT = "BOOT_FILTER=ONâœ…(ç¦ä¸‹æ³¨ seen_all=1..8)" if BOOT_FILTER else "BOOT_FILTER=OFFâ›”(é´é¦–å…è®¸ä¸‹æ³¨)"
BET_IN_FORBIDDEN_SEEN = 0  # å®é™…è½æ³¨ç‚¹è½åœ¨ seen_all=1..8 çš„è®¡æ•°ï¼ˆå‘ç°å³ raiseï¼‰
# ============================================================
# ç»“æ„æ‰«æå¼€å…³ï¼ˆç»“æ„é—¸é—¨ï½œé”æ­»ï¼‰
# ============================================================
STRUCT_SCAN = 1  # 1=ONâœ…ï¼Œ0=OFFâ›”ï¼ˆä»…è‡ªè¯ç”¨ï¼ŒOFFæ—¶ç¦æ­¢ä»»ä½•ç­–ç•¥æ‰§è¡Œï¼‰
STRUCT_SCAN_TEXT = "STRUCT_SCAN=ONâœ…(ç»“æ„æ‰«æå¼€å¯)" if STRUCT_SCAN else "STRUCT_SCAN=OFFâ›”(ç»“æ„æ‰«æå…³é—­-ä»…è‡ªè¯)"
# ============================================================
# ç»“æ„æ’æ§½åŒºï¼ˆç‰ˆæœ¬Aï½œå”¯ä¸€å…è®¸å‡ºç°ç»“æ„é€»è¾‘çš„åŒºåŸŸï½œé”æ­»ï¼‰
# - åç»­æ›´æ¢ç»“æ„ï¼šåªå…è®¸æ›¿æ¢ã€Œç»“æ„æ’æ§½åŒºå¼€å§‹/ç»“æŸã€ä¸¤è¡Œä¹‹é—´çš„å†…å®¹
# - å…¶ä½™ä»»ä½•ä½ç½®å‡ºç°ç»“æ„åˆ¤æ–­/ç»“æ„å‡½æ•°è§†ä¸ºæ±¡æŸ“ï¼ˆè‡ªæ£€ä¼šæ‹¦æˆªï¼‰
# ============================================================
# [STRUCT_SLOT_BEGIN]
STRUCT_SUMMARY_LINE = "ç»“æ„æ‘˜è¦ï¼šSâ‰¥3â†’W1-2â†’Sâ­ï¼ˆæ‰“Sï¼‰"
def scan_structure(records):
    """ç»“æ„æ‰«æï¼ˆç¤ºä¾‹ï¼šQ1ç»“æ„ï¼‰
    ç»“æ„ï¼šä¸»å¯¼è½´ç´¯è®¡â‰¥3 â†’ è¾…è½´ç´¯è®¡1~2 â†’ ä¸»å¯¼è½´â­ï¼ˆâ­å£=æŠ•æ”¾ç‚¹ï¼‰
    å£å¾„è¦ç‚¹ï¼š
    - ä»…BPå‚ä¸ç´¯è®¡ï¼›T/ç‚¹å·®0ä¸æ‰“æ–­ã€ä¸å‚ä¸ç´¯è®¡ï¼›ä¸”ç¦æ­¢è·¨æ®µç´¯è®¡
    - â­å¿…é¡»æ»¡è¶³ï¼šç»“æœä¸ºB/P ä¸” ç‚¹å·®é0ï¼ˆå¦åˆ™STRUCT_ERRORï¼‰
    - BOOT_FILTER=ONâœ…æ—¶ï¼šè‹¥â­è½åœ¨seen_all=1..8ï¼Œç¦æ­¢æŠ•æ”¾ï¼Œä½†å¿…é¡»ç»§ç»­æ‰«æç›´åˆ°å‡ºç°å¯æŠ•æ”¾â­æˆ–STRUCT_FAIL
    è¿”å›ï¼š
      ("STRUCT_OK", star_idx, strong_side, info_dict)
      ("STRUCT_FAIL", None, None, info_dict)
    """
    info = {
        "forbidden_star_cnt": 0,
        "forbidden_star_first_seen": None,
        "fail_reason": None,  # MAIN_LT3 / WEAK_GT2 / NO_CANDIDATE / ONLY_FORBIDDEN
    }

    if not records:
        info["fail_reason"] = "NO_CANDIDATE"
        return "STRUCT_FAIL", None, None, info

    strong = None
    weak = None

    run_side = None
    run_len = 0

    state = "FIND_S"   # FIND_S / WAIT_W / IN_W
    w_len = 0

    def _is_bp_valid(rec):
        rr = rec.get("r")
        if rr not in ("B", "P"):
            return False
        d = rec.get("diff")
        if d is None:
            return False
        try:
            if int(d) == 0:
                return False
        except Exception:
            return False
        return True

    for rec in records:
        if not _is_bp_valid(rec):
            continue

        rr = rec.get("r")

        if run_side is None:
            run_side = rr
            run_len = 1
        elif rr == run_side:
            run_len += 1
        else:
            run_side = rr
            run_len = 1

        if state == "FIND_S":
            if run_len >= 3:
                strong = run_side
                weak = "P" if strong == "B" else "B"
                state = "WAIT_W"
                w_len = 0
            continue

        if state == "WAIT_W":
            if rr == weak:
                state = "IN_W"
                w_len = 1
            continue

        if state == "IN_W":
            if rr == weak:
                w_len += 1
                if w_len >= 3:
                    info["fail_reason"] = "WEAK_GT2"
                    return "STRUCT_FAIL", None, None, info
                continue

            star_idx = rec.get("idx")
            star_seen = rec.get("seen_all")

            # â­åˆæ³•æ€§ï¼šå¿…é¡»ä¸ºBPä¸”ç‚¹å·®é0ï¼ˆå¦åˆ™STRUCT_ERRORï¼‰
            if rec.get("r") not in ("B", "P"):
                print("âŒâŒâŒ STRUCT_ERRORï¼šâ­è½åœ¨T | æ–‡ä»¶|Sub-Batch|idx|seen|r|diff =", _CTX_FILE, _CTX_SUBBATCH, star_idx, star_seen, rec.get("r"), rec.get("diff"))
                raise RuntimeError("STRUCT_ERRORï¼šâ­è½åœ¨T")
            try:
                if int(rec.get("diff")) == 0:
                    print("âŒâŒâŒ STRUCT_ERRORï¼šâ­ç‚¹å·®=0 | æ–‡ä»¶|Sub-Batch|idx|seen|r|diff =", _CTX_FILE, _CTX_SUBBATCH, star_idx, star_seen, rec.get("r"), rec.get("diff"))
                    raise RuntimeError("STRUCT_ERRORï¼šâ­ç‚¹å·®=0")
            except Exception:
                print("âŒâŒâŒ STRUCT_ERRORï¼šâ­ç‚¹å·®æ— æ³•è§£æ | æ–‡ä»¶|Sub-Batch|idx|seen|r|diff =", _CTX_FILE, _CTX_SUBBATCH, star_idx, star_seen, rec.get("r"), rec.get("diff"))
                raise RuntimeError("STRUCT_ERRORï¼šâ­ç‚¹å·®æ— æ³•è§£æ")

            if BOOT_FILTER and (star_seen is not None):
                try:
                    if 1 <= int(star_seen) <= 8:
                        info["forbidden_star_cnt"] += 1
                        if info["forbidden_star_first_seen"] is None:
                            info["forbidden_star_first_seen"] = int(star_seen)

                        # ç¦æŠ•æ”¾ï¼šç»§ç»­æ‰«æä¸‹ä¸€ä¸ªâ­
                        state = "WAIT_W"
                        w_len = 0
                        run_side = strong
                        run_len = 1
                        continue
                except Exception:
                    pass

            return "STRUCT_OK", int(star_idx), strong, info

    if strong is None:
        info["fail_reason"] = "MAIN_LT3"
    else:
        if info["forbidden_star_cnt"] > 0:
            info["fail_reason"] = "ONLY_FORBIDDEN"
        else:
            info["fail_reason"] = "NO_CANDIDATE"
    return "STRUCT_FAIL", None, None, info
# [STRUCT_SLOT_END]
STRUCT_DEF_HASH = hashlib.md5(STRUCT_SUMMARY_LINE.encode("utf-8")).hexdigest()[:8]
_STRUCT_SUMMARY_PRINTED = False


# ==========================
# æ‰“å°æ ¼å¼å·¥å…·ï¼ˆé”æ­»ï¼‰
# ==========================
def _pct(n, d, nd=2):
    if d <= 0:
        return "0%"
    return f"{(n * 100.0 / d):.{nd}f}%"

def _cnt_pct(n, d, nd=2):
    return f"{n} ({_pct(n, d, nd)})"

# å¼€å…³æ‰“å°ç¡¬é”ï¼ˆé”æ­»ï¼‰ï¼šè¡¨å¤´+å¼ºåˆ¶è‡ªè¯ å‡å¿…é¡»æ‰“å°
_PRINTED_SWITCHES_HEADER = False
_PRINTED_SWITCHES_PROOF = False

def _print_switches_block(where: str):
    """ç¡¬é”ï¼šå¿…é¡»æ‰“å° BOOT_FILTER ä¸ STRUCT_SCANï¼›å¹¶æ‰“æ ‡è®°ä¾›æ–­è¨€ã€‚"""
    global _PRINTED_SWITCHES_HEADER, _PRINTED_SWITCHES_PROOF
    print(f"ç»“æ„é—¸é—¨ï¼š{STRUCT_SCAN_TEXT}")
    print(f"é´çº§å¼€å…³ï¼š{_boot_filter_label()}")
    if where == "HEADER":
        _PRINTED_SWITCHES_HEADER = True
    elif where == "PROOF":
        _PRINTED_SWITCHES_PROOF = True
    else:
        # æœªçŸ¥ä½ç½®ä»ä¸å…è®¸é™é»˜æ”¾è¿‡
        raise RuntimeError("âŒ _print_switches_block(where) where éæ³•")
# ä¸Šä¸‹æ–‡ï¼ˆç”¨äºæœ€å°æº¯æºæ‰“å°ï¼‰
_CTX_FILE = ""
_CTX_SUBBATCH = ""


def _audit_forbid_idx_offset():
    """
    å®‰å…¨è‡ªæ£€ï¼ˆé”æ­»ï½œæ‰§è¡Œ/ç»“ç®—æ®µï¼‰ï¼š
    - ç¦æ­¢ï¼šä»¥ idx ä¸ºåŸºå‡†ç›´æ¥æ¨å¯¼â€œæœªæ¥è¡Œå·â€ï¼ˆä¾‹å¦‚ï¼šidx ä¸åç§»é‡æ‹¼æ¥å¾—åˆ°æŸè¡Œï¼‰
    - ç¦æ­¢ï¼šåœ¨æ‰§è¡Œ/ç»“ç®—æ®µå›è¯» diff/rate/mean ä½œä¸ºåˆ¤æ–­ä¾æ®
    è¯´æ˜ï¼šåªå®¡è®¡ run_strategy_on_boot() å†…â€œç»“ç®—å¼€å§‹é”šç‚¹â€ä¹‹åçš„ä»£ç ï¼Œé¿å…è¯¯ä¼¤â€œæŠ•æ”¾å‰å¿«ç…§â€ã€‚
    """
    print("=== å®‰å…¨è‡ªæ£€å¼€å§‹ ===")

    # 1) æŠ½å–ç­–ç•¥æºç ï¼ˆæ— æ³•è¯»å–åˆ™ç›´æ¥åˆ¤å®šä¸é€šè¿‡ï¼‰
    try:
        src = inspect.getsource(run_strategy_on_boot)
    except Exception:
        raise RuntimeError("SELF_TEST_FAIL: CANNOT_READ_SOURCE_RUN_STRATEGY")

    # 2) åªå®¡è®¡â€œæ‰§è¡Œ/ç»“ç®—æ®µâ€ï¼šä»é”šç‚¹å¼€å§‹å¾€å
    anchor = "# 3) EXECUTE"
    pos = src.find(anchor)
    audit_src = src[pos:] if pos >= 0 else src

    # 3) ç¦æ­¢ç‰‡æ®µï¼ˆæ‰§è¡Œ/ç»“ç®—æ®µï¼‰
    # æ³¨æ„ï¼šä¸ºäº†é¿å…â€œè‡ªæ£€å­—ç¬¦ä¸²æœ¬èº«â€è§¦å‘æ›´ä¸Šå±‚çš„æºç é›·è¾¾ï¼Œæœ¬å¤„ç”¨æ‹¼æ¥ç”Ÿæˆæ¨¡å¼ä¸²ã€‚
    a = "idx"
    sp = " +"
    lbr = "records["
    forbidden = [
        # æœªæ¥è¡Œå·ç›´ç®—ï¼ˆç¦æ­¢ï¼‰
        a + sp + " step_idx", a + "+step_idx",
        # ç¦æ­¢ star_idx åç§»ç›´ç®—
        "star_idx + 1", "star_idx+1", "star_idx +", "star_idx+",
        # ç¦æ­¢ EXECUTE/SETTLE ç›´è¯»æŒ‡æ ‡
        '.get("diff")', '.get("rate")', '.get("mean")', '["diff"]', '["rate"]', '["mean"]',

        a + sp + " b_idx", a + "+b_idx",
        lbr + a + sp, lbr + a + "+",

        # ç»“ç®—/æ‰§è¡Œé˜¶æ®µå°†æ¸¸æ ‡æŒ‡å‘ç»“ç®—è¡Œå¹¶å›è¯»æŒ‡æ ‡ï¼ˆç¦æ­¢ï¼‰
        "settle_idx", "last_bet_idx",
        "records[settle_idx]", "records[last_bet_idx]",
        "records [settle_idx]", "records [last_bet_idx]",

        # ç»•è·¯å†™æ³•ï¼ˆç¦æ­¢ï¼‰ï¼šåŒºé—´è¯»å–/åŒºé—´å¾ªç¯/è¡¨æ ¼å¼ç´¢å¼•
        lbr + a + ":", lbr + a + " :", "records[ " + a + ":", "records[ " + a + " :",
        lbr + a + "+1:", lbr + a + sp + " 1:", lbr + a + "+1:",
        "range(" + a, "range(" + a + sp, "range( " + a,
        "iloc[",
    ]

    hit = [s for s in forbidden if s in audit_src]

    if hit:
        print("âŒâŒâŒ ä¸é€šè¿‡: æ‰§è¡Œ/ç»“ç®—æ®µæ£€æµ‹åˆ°ç¦æ­¢ç‰‡æ®µ:", ",".join(hit))
        lines = audit_src.splitlines()
        shown = 0
        for i, line in enumerate(lines, 1):
            if any(h in line for h in hit):
                print(f"  HIT|Line {i}|{line.strip()}")
                shown += 1
                if shown >= 6:
                    break
        print("=== å®‰å…¨è‡ªæ£€å®Œæˆ ===")
        raise RuntimeError("æ‰§è¡Œ/ç»“ç®—æ®µå­˜åœ¨ç¦æ­¢ç‰‡æ®µ")

    print("âœ… å®‰å…¨è‡ªæ£€é€šè¿‡ï¼šæ‰§è¡Œ/ç»“ç®—æ®µæœªæ£€æµ‹åˆ°ç¦æ­¢ç‰‡æ®µã€‚")
    print("=== å®‰å…¨è‡ªæ£€å®Œæˆ ===")

def _audit_structure_slot_integrity():
    """
    ç»“æ„æ’æ§½å®Œæ•´æ€§è‡ªæ£€ï¼ˆé”æ­»ï¼‰ï¼š
    - ç»“æ„æ’æ§½æ ‡è®°è¡Œå¿…é¡»ä¸”åªèƒ½å„å‡ºç° 1 æ¬¡ï¼š# [STRUCT_SLOT_BEGIN] / # [STRUCT_SLOT_END]
    - å¿…é¡»ä¸”åªèƒ½æœ‰ 1 ä¸ª def scan_structure(records):ï¼Œä¸”ä½äºæ’æ§½åŒºå†…
    - STRUCT_SUMMARY_LINE åªèƒ½åœ¨æ’æ§½åŒºå†…å®šä¹‰ä¸€æ¬¡
    """
    try:
        src = open(__file__, 'r', encoding='utf-8').read()
    except Exception:
        # æŸäº›ç¯å¢ƒä¸‹ __file__ ä¸å¯ç”¨æ—¶ï¼Œæ”¾è¡Œï¼›ä½†è¿™ä¼šé™ä½å®¡æŸ¥å¼ºåº¦
        return

    begin_ms = list(re.finditer(r'(?m)^[ \t]*#\s*\[STRUCT_SLOT_BEGIN\]\s*$', src))
    end_ms = list(re.finditer(r'(?m)^[ \t]*#\s*\[STRUCT_SLOT_END\]\s*$', src))
    if len(begin_ms) != 1 or len(end_ms) != 1:
        raise RuntimeError('âŒ ç»“æ„æ’æ§½æ ‡è®°è¡Œå¿…é¡»ä¸”åªèƒ½å„å‡ºç° 1 æ¬¡ï¼š# [STRUCT_SLOT_BEGIN] / # [STRUCT_SLOT_END]')

    b = begin_ms[0].end()
    e = end_ms[0].start()
    if e <= b:
        raise RuntimeError('âŒ ç»“æ„æ’æ§½æ ‡è®°é¡ºåºé”™è¯¯ï¼šBEGIN å¿…é¡»åœ¨ END ä¹‹å‰')

    slot = src[b:e]

    # 1) scan_structureï¼šå…¨æ–‡ä»¶åªèƒ½å®šä¹‰ 1 æ¬¡ï¼Œä¸”å¿…é¡»ä½äºæ’æ§½åŒºå†…
    all_defs = list(re.finditer(r'(?m)^[ \t]*def\s+scan_structure\s*\(', src))
    slot_defs = list(re.finditer(r'(?m)^[ \t]*def\s+scan_structure\s*\(', slot))
    if len(all_defs) != 1 or len(slot_defs) != 1:
        raise RuntimeError('âŒ scan_structure å¿…é¡»ä¸”åªèƒ½å®šä¹‰ 1 æ¬¡ï¼Œå¹¶ä¸”å¿…é¡»ä½äºç»“æ„æ’æ§½åŒºå†…')

    # 2) STRUCT_SUMMARY_LINEï¼šåªèƒ½åœ¨æ’æ§½åŒºå†…å®šä¹‰ä¸€æ¬¡
    all_sum = list(re.finditer(r'(?m)^[ \t]*STRUCT_SUMMARY_LINE\s*=', src))
    slot_sum = list(re.finditer(r'(?m)^[ \t]*STRUCT_SUMMARY_LINE\s*=', slot))
    if len(all_sum) != 1 or len(slot_sum) != 1:
        raise RuntimeError('âŒ STRUCT_SUMMARY_LINE å¿…é¡»ä¸”åªèƒ½å®šä¹‰ 1 æ¬¡ï¼Œå¹¶ä¸”å¿…é¡»ä½äºç»“æ„æ’æ§½åŒºå†…')
def _boot_filter_label():
    return "BOOT_FILTER=ONâœ…(ç¦ä¸‹æ³¨ seen_all=1..8)" if BOOT_FILTER else "BOOT_FILTER=OFFâ›”(é´é¦–å…è®¸ä¸‹æ³¨)"


# ==========================
# æ®µé•¿ä¸è‡ªåœï¼ˆé”æ­»ï½œä»æ‰¹æ¬¡é¦–å¼€å§‹ï¼‰  # [cite: 12]
# ==========================
def _is_bp(r):
    return r in ("B", "P")  # [cite: 12]

def _update_run(run_side, run_len, r):
    # çŠ¶æ€ T ä½ç§»é›¶åå·®ï¼šrun_side/run_len ä¸å˜  # [cite: 13]
    if r == "T":
        return run_side, run_len  # [cite: 13]
    if not _is_bp(r):
        return run_side, run_len  # [cite: 13]
    if run_side is None or r != run_side:
        return r, 1  # [cite: 13]
    return run_side, run_len + 1  # [cite: 13]

def _compute_max_runs_first9(records):
    # åªçœ‹å‰ 9 å£ï¼ˆseen_all=1..9ï¼ŒçŠ¶æ€ B/P/T éƒ½ç®—ä½ç§»å£æ•°ï¼‰  # [cite: 14]
    seen_all = 0  # [cite: 14]
    run_side = None  # [cite: 14]
    run_len = 0  # [cite: 14]
    max_run = {"B": 0, "P": 0}  # [cite: 14]
    for rec in records:
        seen_all += 1  # [cite: 14]
        run_side, run_len = _update_run(run_side, run_len, rec["r"])  # [cite: 14]
        if run_side in ("B","P"):
            if run_len > max_run[run_side]:
                max_run[run_side] = run_len  # [cite: 14]
        if seen_all >= 9:
            break  # [cite: 14]
    return max_run["B"], max_run["P"], seen_all  # [cite: 14]

def _self_stop_tracker_init():
    return {"run_side": None, "run_len": 0, "seen_b3": False, "seen_p3": False}  # [cite: 14]

def _self_stop_tracker_step(st, r):
    st["run_side"], st["run_len"] = _update_run(st["run_side"], st["run_len"], r)  # [cite: 15]
    if st["run_side"] == "B" and st["run_len"] >= 3:
        st["seen_b3"] = True  # [cite: 15]
    if st["run_side"] == "P" and st["run_len"] >= 3:
        st["seen_p3"] = True  # [cite: 15]
    return st  # [cite: 15]

def _should_self_stop(st):
    # ä¸¤è¾¹éƒ½æ›¾å‡ºç°æ®µé•¿â‰¥3 â†’ è‡ªåœ  # [cite: 15]
    return st["seen_b3"] and st["seen_p3"]  # [cite: 15]
from collections import defaultdict

# ==========================
# è¿æ®µç»Ÿè®¡ï¼ˆåŒæŒ‡æ ‡ç›¸é‚»æ€ï½œé”æ­»ï¼‰  # [cite: 15]
# ==========================
# ç›®æ ‡ï¼šåœ¨â€œå•æŒ‡æ ‡æ— è§„å¾‹â€çš„å‰æä¸‹ï¼Œåªè§‚å¯Ÿâ€œåŒæŒ‡æ ‡ç›¸é‚»æ€â€çš„åˆ†å¸ƒï¼Œç”¨äº STOP å€™é€‰ç­›é€‰ï¼›  # [cite: 15]
# çº¦æŸï¼šè¿ç»­ç»Ÿè®¡åªèƒ½åŸºäºâ€œæŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨â€åšäº‹åæ±‡æ€»ï¼›å†³ç­–é€»è¾‘ä»å¿…é¡»æ»¡è¶³â€œå†³ç­–å£åŸºå‡†ï¼ˆé›¶æœªæ¥ï¼‰â€ã€‚  # [cite: 15]
#
# å¿«ç…§å£å¾„ï¼ˆé”æ­»ï½œå£å¾„ Bï¼‰ï¼šæ¯æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘è®°å½•ä¸€æ¬¡å¿«ç…§ï¼ˆå«çŠ¶æ€ T åçš„é‡å¤æŠ•æ”¾ï¼‰ï¼Œå¿«ç…§æ¥è‡ªâ€œæŠ•æ”¾ç‚¹å½“è¡Œâ€åŸå§‹æŒ‡æ ‡ã€‚  # [cite: 15]
# è¿ç»­é•¿åº¦ï¼ˆé”æ­»ï¼‰ï¼šç›¸é‚»æ€ï¼ˆä¸Šä¸€æ¬¡â†’è¿™ä¸€æ¬¡ï¼‰ã€‚  # [cite: 15]
#
# å¿«ç…§å­—æ®µï¼ˆå»ºè®®ç­–ç•¥è¿”å› snapshots åˆ—è¡¨ï¼Œæ¯æ¡è‡³å°‘åŒ…å«ï¼‰ï¼š  # [cite: 15]
#   - bet_n: ç¬¬å‡ æ¬¡å®é™…æŠ•æ”¾ï¼ˆä» 1 å¼€å§‹ï¼›å«çŠ¶æ€ T é‡å¤æŠ•æ”¾ä¼šå¯¼è‡´ bet_n > 4ï¼‰  # [cite: 15]
#   - diff: ç‚¹å·®ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - rate: å˜åŒ–ç‡ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - mean: å‡å·®ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - trade_bust: æœ¬ç¬”äº¤æ˜“æœ€ç»ˆæ˜¯å¦é˜ˆå€¼å‡»ç©¿ï¼ˆ0/1ï¼Œç”¨äºè®¡ç®—â€œåç»­é˜ˆå€¼å‡»ç©¿ç‡â€ï¼‰  # [cite: 15]
#
# è¾“å‡ºï¼ˆé”æ­»ï½œAI å‹å¥½ï¼‰ï¼š  # [cite: 15]
#   A) (|ç‚¹å·®|æ¡¶, rate ç›‘æµ‹æ¡¶) çš„ç›¸é‚»æ€åˆ‡æ¢æ¦œï¼šS_{t-1}â†’S_tï¼ˆTopKï¼‰  # [cite: 15]
#   B) (|ç‚¹å·®|æ¡¶, mean æ¡¶) çš„ç›¸é‚»æ€åˆ‡æ¢æ¦œï¼šS_{t-1}â†’S_tï¼ˆTopKï¼‰  # [cite: 15]
#   æ¯æ¡åˆ‡æ¢è¾“å‡ºï¼šå‡ºç°æ¬¡æ•°ã€åç»­é˜ˆå€¼å‡»ç©¿æ•°ã€åç»­é˜ˆå€¼å‡»ç©¿ç‡ï¼ˆexhaustion / å‡ºç°æ¬¡æ•°ï¼‰  # [cite: 15]
#   é»˜è®¤åªè¾“å‡ºâ€œæ ·æœ¬é‡ >= é˜ˆå€¼â€çš„åˆ‡æ¢ï¼Œé¿å…å™ªå£°ã€‚  # [cite: 15]
CONT_STATS_ENABLE = 0  # [cite: 15]
CONT_MAX_BET_N = 12  # [cite: 15]
CONT_MIN_SAMPLES = 500  # [cite: 15]
CONT_TOPK = 20  # [cite: 15]


def _abs_diff_bucket(diff):
    """L2/L3/L4 æ³¨ä½å¿«ç…§ï¼šä¸»åˆ†å¸ƒ |diff|=1..9ï¼›çº é”™è®¡æ•°ï¼š|diff|=0 ä¸ 9+ åˆå¹¶ï¼ˆä¸è¿›å…¥1..9ï¼‰ã€‚"""
    try:
        d = abs(int(diff))
    except Exception:
        d = 0
    if 1 <= d <= 9:
        return str(d)  # "1".."9"
    return "çº é”™(0/9+)"


# å˜åŒ–ç‡ï¼šæ¿€æ´»é˜ˆå€¼ï¼ˆä¸‰æ¡£ï½œé”æ­»ï¼‰  # [cite: 17]
def _rate_entry_bucket(rate):
    if rate is None:
        return "æ— æ•ˆ"  # [cite: 17]
    try:
        r = float(rate)  # [cite: 17]
    except Exception:
        return "æ— æ•ˆ"  # [cite: 17]
    if r <= -3:
        return "<=-3"  # [cite: 17]
    if -3 < r <= -2:
        return "(-3,-2]"  # [cite: 17]
    if -2 < r < 0:
        return "(-2,0)"  # [cite: 17]
    return "å…¶ä»–"  # [cite: 17]

# å˜åŒ–ç‡ï¼šç›‘æµ‹é˜ˆå€¼ï¼ˆä¸‰æ¡£ï½œé”æ­»ï¼‰  # [cite: 18]

def _rate_monitor_bucket(rate):
    """L2/L3/L4 æ³¨ä½å¿«ç…§å˜åŒ–ç‡åˆ†æ¡¶ï¼ˆä¸­æ–‡æ¡¶åé”æ­»ï¼‰ã€‚"""
    if rate is None:
        return "æ— æ•ˆ"
    try:
        r = float(rate)
    except Exception:
        return "æ— æ•ˆ"
    if r < 0:
        return "å‡é€Ÿ"
    if 0 <= r < 2:
        return "åŠ é€Ÿ"
    return "æå€¼"


# å‡å·®ï¼šç›‘æµ‹åˆ†æ¡¶ï¼ˆä¸¤ç±» + 0 å•åˆ—ï½œé”æ­»ï¼‰  # [cite: 19]

def _mean_bucket(mean):
    """L2/L3/L4 æ³¨ä½å¿«ç…§å‡å·®ç»å¯¹å€¼åˆ†æ¡¶ï¼ˆ<3 / â‰¥3ï¼›æ— æ•ˆå•åˆ—ç”¨äºçº é”™è®¡æ•°ï¼‰ã€‚"""
    if mean is None:
        return "æ— æ•ˆ"
    try:
        m = abs(float(mean))
    except Exception:
        return "æ— æ•ˆ"
    if m < 3:
        return "<3"
    return "â‰¥3"

def _l1_abs_diff_bucket(diff):
    """L1 æŠ•æ”¾ç‚¹ç‚¹å·®åˆ†å¸ƒï¼š|diff|=0..9 + 9+ï¼ˆ9+å•åˆ—ï¼‰ã€‚"""
    try:
        d = abs(int(diff))
    except Exception:
        d = 0
    if d >= 10:
        return "9+"
    return str(d)  # "0".."9"

def _l1_rate_bucket(rate):
    """L1 æŠ•æ”¾ç‚¹å˜åŒ–ç‡åˆ†æ¡¶ï¼ˆä¸­æ–‡æ¡¶åé”æ­»ï¼‰ã€‚"""
    if rate is None:
        return "æ— æ•ˆ"
    try:
        r = float(rate)
    except Exception:
        return "æ— æ•ˆ"
    if r > -2:
        return "å‰å°"
    if -3 < r <= -2:
        return "å‰å¤§"
    return "æå€¼"

def _l1_mean_bucket(diff, mean):
    """L1 æŠ•æ”¾ç‚¹å‡å·®åˆ†æ¡¶ï¼šæœ‰æ•ˆåŒå‘/æœ‰æ•ˆåå‘/ä¸­è½´ï¼›meanæ— æ•ˆè¿”å›(None, True)"""
    if mean is None:
        return None, True
    try:
        m = float(mean)
    except Exception:
        return None, True
    try:
        d = float(diff)
    except Exception:
        d = 0.0

    # diff=0 å¼ºåˆ¶ä¸­è½´
    if d == 0:
        return "ä¸­è½´", False

    # mean=0 / |mean|<1 å½’ä¸­è½´
    if abs(m) < 1:
        return "ä¸­è½´", False

    # |mean|>=1ï¼šæŒ‰ç¬¦å·åˆ¤åŒå‘/åå‘
    same = (m > 0 and d > 0) or (m < 0 and d < 0)
    return ("æœ‰æ•ˆåŒå‘" if same else "æœ‰æ•ˆåå‘"), False



def _init_cont_agg():
    return {
        "pair_rate": {},         # key: (bet_n, prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_mean": {},         # key: (bet_n, prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_rate_overall": {}, # key: (prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_mean_overall": {}, # key: (prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "max_bet_n_seen": 0,  # [cite: 21]
    }

def _agg_add(d, key, bust_flag):
    if key not in d:
        d[key] = [0, 0]  # [cite: 22]
    d[key][0] += 1  # [cite: 22]
    d[key][1] += int(1 if bust_flag else 0)  # [cite: 22]

def _cont_consume_snapshots(agg, snapshots):
    # snapshots: list of dicts with bet_n,diff,rate,mean,trade_exhaustion  # [cite: 23]
    if not snapshots:
        return  # [cite: 23]
    snaps = [x for x in snapshots if isinstance(x, dict) and "bet_n" in x]  # [cite: 23]
    snaps.sort(key=lambda x: int(x.get("bet_n", 0)))  # [cite: 23]
    if len(snaps) < 2:
        return  # [cite: 23]

    bust_flag = int(snaps[-1].get("trade_bust", 0))  # [cite: 23]
    for i in range(1, len(snaps)):
        a = snaps[i-1]  # [cite: 23]
        b = snaps[i]  # [cite: 23]
        try:
            bn = int(b.get("bet_n", 0))  # [cite: 23]
        except Exception:
            bn = 0  # [cite: 23]
        if bn > agg["max_bet_n_seen"]:
            agg["max_bet_n_seen"] = bn  # [cite: 23]

        prev_rate = (_abs_diff_bucket(a.get("diff", 0)), _rate_monitor_bucket(a.get("rate")))  # [cite: 24]
        curr_rate = (_abs_diff_bucket(b.get("diff", 0)), _rate_monitor_bucket(b.get("rate")))  # [cite: 24]
        prev_mean = (_abs_diff_bucket(a.get("diff", 0)), _mean_bucket(a.get("mean")))  # [cite: 24]
        curr_mean = (_abs_diff_bucket(b.get("diff", 0)), _mean_bucket(b.get("mean")))  # [cite: 24]

        _agg_add(agg["pair_rate"], (bn, prev_rate, curr_rate), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_mean"], (bn, prev_mean, curr_mean), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_rate_overall"], (prev_rate, curr_rate), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_mean_overall"], (prev_mean, curr_mean), bust_flag)  # [cite: 24]

def _print_top_transitions(title, d, min_samples, topk):
    rows = []  # [cite: 25]
    for k, (cnt, bust) in d.items():
        if cnt < min_samples:
            continue  # [cite: 25]
        br = bust / cnt if cnt else 0.0  # [cite: 25]
        rows.append((br, cnt, bust, k))  # [cite: 25]
    rows.sort(reverse=True, key=lambda x: (x[0], x[1]))  # [cite: 25]
    print(title)  # [cite: 25]
    if not rows:
        print("ï¼ˆæ— è¾“å‡ºï¼šæ ·æœ¬é‡ä¸è¶³ï¼‰")  # [cite: 25]
        return  # [cite: 25]
    for i, (br, cnt, bust, k) in enumerate(rows[:topk], 1):
        print(f"{i:02d}. {k} | æ¬¡æ•°={cnt} | é˜ˆå€¼å‡»ç©¿={bust} | é˜ˆå€¼å‡»ç©¿ç‡={br:.4f}")  # [cite: 26]


# ============================================================
# ç»Ÿä¸€ä»£ç æ¨¡æ¿ï¼ˆV4ï¼Œåºåˆ—é•¿åº¦å£å¾„ï½œä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“ï¼‰
# çº¦æŸï¼š
# 1) åªè¯»å–å½“å‰ç›®å½•ä¸‹æ‰€æœ‰ .csv
# 2) ä¸å†™æ­»ä»»ä½•ç»å¯¹è·¯å¾„
# 3) è‡ªåŠ¨è¯†åˆ«æ‰¹æ¬¡åˆ—/ç»“æœ/ç‚¹å·®/å˜åŒ–ç‡/å‡å·®
# 4) ç»“æœå¿…é¡»æ˜ å°„ä¸º B/P/T
# 5) ä¸¥æ ¼é›¶æœªæ¥ï¼šrun_strategy_on_boot å†…ä¸¥ç¦è®¿é—®æœªæ¥è¡Œ
# 6) â€œä¸‹ä¸€å£/ä¸‹ä¸€è¡Œâ€ç»Ÿä¸€å®šä¹‰ï¼šç´§éšæŠ•æ”¾ç‚¹çš„ä¸‹ä¸€è¡Œï¼ˆä¸è·³è¿‡çŠ¶æ€ T ä½ç§»é›¶åå·®ï¼‰
# 7) å•è¾¹/åŒè¾¹ï¼šå‰ 9 å£åˆ†ç±»ï¼›å•è¾¹å¼±ç´¯è®¡ >=3 è½¬åŒè¾¹ï¼›äº¤æ˜“æ¬¡æ•°é™åˆ¶è§æ¨¡æ¿æ–‡æ¡£
#
# æ³¨æ„ï¼šæœªæ¥æ–°å¢/ä¿®æ”¹ç­–ç•¥ï¼Œåªæ”¹ run_strategy_on_boot(records) å†…éƒ¨é€»è¾‘
# ============================================================

# ============================================================
# ç»“æœæ˜ å°„è¡¨ï¼šå·²å®Œæˆ BPT å…¨é˜¶è„±æ•ï¼Œç‰©ç†åŒ¹é…å®éªŒå®¤æ ‡å‡†åŒ– CSV
# ============================================================
MAP_RESULT = {"B": "B", "P": "P", "T": "T"}

def map_result(v):
    if v is None:
        return None
    s = str(v).strip()
    if s in MAP_RESULT:
        return MAP_RESULT[s]
    s2 = s.upper()
    if s2 in MAP_RESULT:
        return MAP_RESULT[s2]
    return None

# ------------------------------------------------------------
# å·¥å…·ï¼šå®‰å…¨è¯»å– float / intï¼ˆåªè¯»ï¼Œä¸è®¡ç®—ï¼‰
# ------------------------------------------------------------
RATE_MISSING_RAW_INPUT = 0
RATE_PARSE_FAIL_INPUT = 0
MEAN_MISSING_RAW_INPUT = 0
MEAN_PARSE_FAIL_INPUT = 0
def safe_float(v, default=None, *, kind="GEN"):
    """å®‰å…¨è§£æ floatï¼šæ°¸ä¸å´©æºƒï¼›ç¼ºå¤±/ä¸å¯è§£æ -> Noneï¼Œå¹¶è®¡æ•°ï¼ˆè¡¥ä¸Bï½œé”æ­»ï¼‰"""
    global RATE_MISSING_RAW_INPUT, RATE_PARSE_FAIL_INPUT, MEAN_MISSING_RAW_INPUT, MEAN_PARSE_FAIL_INPUT
    if _is_raw_missing(v):
        if kind == "RATE":
            RATE_MISSING_RAW_INPUT += 1
        elif kind == "MEAN":
            MEAN_MISSING_RAW_INPUT += 1
        return default
    try:
        return float(v)
    except Exception:
        if kind == "RATE":
            RATE_PARSE_FAIL_INPUT += 1
        elif kind == "MEAN":
            MEAN_PARSE_FAIL_INPUT += 1
        return default

def _is_raw_missing(x):
    if x is None:
        return True
    s = str(x).strip().lower()
    return (s == "" or s == "none" or s == "nan")

def safe_int(v, default=0):
    try:
        if v is None or v == "":
            return default
        return int(float(v))
    except Exception:
        return default

# ------------------------------------------------------------
# 1) æ•°æ®åŠ è½½ï¼ˆå›ºå®šï¼‰
# ------------------------------------------------------------
# ------------------------------------------------------------
# 0) åˆ—è¯†åˆ«ä¸æ˜ å°„ï¼ˆå›ºå®šï½œåªè¯»ï¼‰
# ------------------------------------------------------------
def _norm_key(k):
    return str(k).strip().lower() if k is not None else ""

def _first_hit(keys, candidates):
    key_norm = { _norm_key(k): k for k in keys }
    for c in candidates:
        cc = _norm_key(c)
        if cc in key_norm:
            return key_norm[cc]
    return None

def detect_columns(row0):
    """
    è¾“å…¥ï¼šrow0ï¼ˆDictReader è¯»åˆ°çš„ä¸€è¡Œ dictï¼‰
    è¾“å‡ºï¼šcol_batch, col_end, col_result, col_diff, col_rate, col_mean

    é´è¾¹ç•Œå£å¾„ï¼ˆé”æ­»ï¼‰ï¼š
    - æ‰¹æ¬¡/é´å·ï¼šSub-Batch
    - é´ç»“æŸï¼šé´ç»“æŸï¼ˆä»…æœ€åä¸€å£ä¸º1ï¼Œå…¶ä½™ä¸º0ï¼›è‹¥ç¼ºå¤±/ä¸ä¸€è‡´åˆ™æŠ¥é”™ï¼‰
    """
    keys = list(row0.keys()) if isinstance(row0, dict) else []

    # Sub-Batchï¼ˆé´å·/æ‰¹æ¬¡å·ï¼‰
    col_batch = _first_hit(keys, ["Sub-Batch", "sub-batch", "sub_batch", "subbatch", "æ‰¹æ¬¡", "æ‰¹æ¬¡å·", "batch", "Batch"])
    # é´ç»“æŸ
    col_end = _first_hit(keys, ["é´ç»“æŸ", "shoe_end", "shoe end", "end", "End", "ç»“æŸ", "boot_end", "BootEnd"])

    # ç»“æœåˆ—ï¼šå¸¸è§ Exhaustionï¼ˆå€¼ä¸ºB/P/Tï¼‰
    col_result = _first_hit(keys, ["Exhaustion", "exhaustion", "ç»“æœ", "result", "Result", "Outcome", "outcome"])

    # ç‚¹å·®/å˜åŒ–ç‡/å‡å·®ï¼ˆæ”¯æŒ 2/M3ï¼‰
    col_diff = _first_hit(keys, ["ç‚¹å·®", "diff", "Diff", "spread", "Spread", "delta", "Delta"])
    col_rate = _first_hit(keys, ["å˜åŒ–ç‡", "rate", "Rate", "roc", "ROC", "r", "R", "2"])
    col_mean = _first_hit(keys, ["å‡å·®", "mean", "Mean", "avg", "Avg", "average", "Average", "M3", "m3"])

    return col_batch, col_end, col_result, col_diff, col_rate, col_mean



# ==========================
# å…³é”®å‡½æ•°æºç å“ˆå¸Œï¼ˆsha256ï½œé”æ­»ï¼‰
# ==========================
def _print_source_hashes():
    """
    æ‰“å°å…³é”®å‡½æ•°æºç  sha256ï¼ˆé”æ­»ï¼‰ï¼š
    - ä»»æ„å‡½æ•°ç¼ºå¤±/æºç ä¸å¯å¾—/è¢«åŒ…è£¹/è¿è¡Œæ€æ›¿æ¢é£é™©ï¼šç›´æ¥ raise
    - æºç ä¸­å‡ºç° exec/eval/compile ç­‰é«˜å±å­—æ ·ï¼šç›´æ¥ raise
    """
    global _SOURCE_HASHES_PRINTED
    targets = [
        "secure_read_metric",
        "secure_write_star_snapshot",
        "write_star_snapshot",
        "phase_transition",
        "advance_one_row",
        "run_strategy_on_boot",
        "load_all_boots",
        "_run_report",
        "_audit_forbid_idx_offset",
        "_audit_structure_slot_integrity",
    ]

    _audit_log("ã€SOURCE_HASHESã€‘")
    for name in targets:
        fn = globals().get(name)
        if not callable(fn):
            raise RuntimeError(f"SELF_AUDIT_FAIL: MISSING_FUNC:{name}")

        code = getattr(fn, "__code__", None)
        if code is None:
            raise RuntimeError(f"SELF_AUDIT_FAIL: NO_CODEOBJ:{name}")

        try:
            fn_file = os.path.abspath(code.co_filename)
            this_file = os.path.abspath(__file__)
            if fn_file != this_file:
                raise RuntimeError(f"SELF_AUDIT_FAIL: FUNC_FILE_MISMATCH:{name}:{fn_file}")
        except Exception as e:
            raise RuntimeError(f"SELF_AUDIT_FAIL: FUNC_FILE_CHECK_ERROR:{name}:{e}")

        try:
            s = inspect.getsource(fn)
        except Exception as e:
            raise RuntimeError(f"SELF_AUDIT_FAIL: GETSOURCE_FAIL:{name}:{e}")

        # é«˜å±å…³é”®å­—ï¼ˆç¦æ­¢ï¼‰
        bad_tokens = ["exec(", "eval(", "compile(", "types.FunctionType", "__import__(", "importlib"]
        for t in bad_tokens:
            if t in s:
                raise RuntimeError(f"SELF_AUDIT_FAIL: BAD_TOKEN:{name}:{t}")

        h = hashlib.sha256(s.encode("utf-8")).hexdigest()
        loc = len(s.splitlines())
        _audit_log(f"{name} : {h} : loc={loc}")

    _SOURCE_HASHES_PRINTED = True


# ==========================
# æ­£å€¼è§¦å‘è‡ªå®¡é—¸é—¨ï¼ˆæ—¶é—´ç®¡ç†å±€ï½œé”æ­»ï¼‰
# ==========================
def SELF_AUDIT_GATE(final_metrics):
    """
    è§¦å‘æ¡ä»¶ï¼šTotal>0 æˆ– Avg>0ï¼ˆç”±å¼€å…³æ§åˆ¶ï¼‰
    å¤±è´¥ç­–ç•¥ï¼šä»»ä½•ä¸€æ¡ä¸æ»¡è¶³ï¼Œæ‰“å°æœ€å°è¯æ®å raise ç»ˆæ­¢ï¼ˆç¦æ­¢åé”™ï¼‰
    """
    def _fail(item_no, evidence):
        print("=== æ­£å€¼è§¦å‘è‡ªå®¡ ===")
        print(f"Trigger: Total={final_metrics.get('total_profit')} | Avg={final_metrics.get('avg_profit')}")
        print("SELF_AUDIT=FAILâŒ")
        print(f"è§¦å‘çš„æœ€å°åˆæ ¼çº¿æ¡ç›®ç¼–å·={item_no}")
        print(f"å‘½ä¸­æœ€å°è¯æ®ç‰‡æ®µæ‘˜è¦ï¼š{evidence}")
        _raise_guard(code="SELF_AUDIT_FAIL", rule_id=item_no, phase="DONE", msg=f"SELF_AUDIT_FAIL item={item_no}", evidence=reason, exit_code=3)

    # B) äº¤ä»˜å¯å®¡è¾“å‡ºé”æ­»ï¼ˆé¦–å±è¦ç´ æ˜¯å¦å·²æ‰“å°ï¼‰
    if not _WATERMARK_PRINTED:
        _fail(1, "é¦–å±æ°´å°æœªæ‰“å°ï¼šWATERMARK_TEXT")
    if not _PROOF_BLOCK_PRINTED:
        _fail(2, "ç¼ºå¤±ã€å¼ºåˆ¶è‡ªè¯è¾“å‡ºã€‘å—ï¼šPROOF_BLOCK_PRINTED=0")
    if not _SELFTEST_PASSED:
        _fail(3, "ç¡¬æ³¨å…¥è‡ªæ£€æœªé€šè¿‡ï¼šSELFTEST_PASSED=0")
    if not _SOURCE_HASHES_PRINTED:
        _fail(4, "ç¼ºå¤±ã€SOURCE_HASHESã€‘å“ˆå¸Œæ¸…å•ï¼šSOURCE_HASHES_PRINTED=0")

    # C) é´çº§ç¦åŒºä¸‹æ³¨ï¼ˆå¿…é¡»ä¸º 0ï¼‰
    if final_metrics.get("bet_in_forbidden_seen", 0) != 0:
        _fail(5, f"BET_IN_FORBIDDEN_SEEN={final_metrics.get('bet_in_forbidden_seen')}")

    # A) è¡¨å¤´/è¯­ä¹‰é”æ­»ï¼ˆPP/BB æ’ç­‰å¼å¿…é¡» 0 å¤±é…ï¼‰
    if final_metrics.get("ppbb_mismatch", 0) != 0:
        _fail(6, f"PPBB_MISMATCH={final_metrics.get('ppbb_mismatch')} | EVIDENCE={final_metrics.get('ppbb_first_evidence')}")

    # C) æ ¸å¿ƒè®¡æ•°é—­ç¯
    entry = int(final_metrics.get("entry", 0) or 0)
    match = int(final_metrics.get("match", 0) or 0)
    mismatch = int(final_metrics.get("mismatch", 0) or 0)
    brk = int(final_metrics.get("break", 0) or 0)
    stop = int(final_metrics.get("stop", 0) or 0)
    zero = int(final_metrics.get("zero", 0) or 0)
    if entry != (match + mismatch + brk + stop + zero):
        _fail(7, f"æ’ç­‰å¼é—­ç¯å¤±è´¥ï¼šEntry={entry} != Match({match})+Mismatch({mismatch})+Break({brk})+Stop({stop})+Zero({zero})")

    # PASS
    print("=== æ­£å€¼è§¦å‘è‡ªå®¡ ===")
    trig = []
    if final_metrics.get("trigger_total"): trig.append("Total>0")
    if final_metrics.get("trigger_avg"): trig.append("Avg>0")
    print("Trigger:", " or ".join(trig) if trig else "N/A")
    print("SELF_AUDIT=PASSâœ…")


def _print_header_mapping_once(row0, cols):
    """è¡¨å¤´è¯†åˆ«è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡ï¼›ç»ä¸å½±å“ä¸»æµç¨‹ã€‚"""
    global _HEADER_MAPPING_PRINTED
    if _HEADER_MAPPING_PRINTED:
        return
    _HEADER_MAPPING_PRINTED = True
    # é™é»˜æ¨¡å¼ï¼šä¸æ‰“å°ï¼Œä½†ä»å®Œæˆè¡¨å¤´è¯†åˆ«ä¸åç»­æµç¨‹
    if SILENT_MODE:
        return

    try:
        sample_row = row0 if isinstance(row0, dict) else {}

        col_batch, col_end, col_result, col_diff, col_rate, col_mean = cols

        print("==================================================")
        print("è¡¨å¤´è¯†åˆ«ï¼ˆè‡ªè¯ï½œä¸€æ¬¡æ€§æ‰“å°ï¼‰")
        print("æ‰¹æ¬¡(Sub-Batch) ->", col_batch)
        print("é´ç»“æŸ ->", col_end)
        print("ç»“æœ ->", col_result)
        print("ç‚¹å·® ->", col_diff)
        print("å˜åŒ–ç‡ ->", col_rate)
        print("å‡å·® ->", col_mean)

        # æ ·ä¾‹è¡Œï¼šåªå±•ç¤ºå‰12ä¸ªé”®
        d = {}
        show_keys = list(sample_row.keys())[:12]
        for k in show_keys:
            d[k] = sample_row.get(k)
        print("æ ·ä¾‹è¡Œ(åŸå§‹):", d)
        print("==================================================")
    except Exception as e:
        print("âš  è¡¨å¤´è‡ªè¯æ‰“å°å¤±è´¥ï¼ˆä¸å½±å“è¿è¡Œï¼‰:", str(e))


def boot_filter(records):
    # é´çº§å®Œæ•´æ€§ï¼šä¸å­˜åœ¨ä¸è¶³ 9 å£çš„é´ï¼›è‹¥å‘ç°åˆ™æŠ¥é”™å¹¶è¾“å‡ºè¯´æ˜ï¼ˆé”æ­»ï¼‰
    if records is None or len(records) < 9:
        # è¯æ®åªéœ€æ‰“å°ä¸€æ¬¡ï¼šæ–‡ä»¶|Sub-Batch|idxï¼ˆè‹¥ç¼ºå¤±åˆ™å°½é‡è¾“å‡ºå·²æœ‰ä¿¡æ¯ï¼‰
        f = None
        sb = None
        last_idx = None
        try:
            if records:
                f = records[0].get("file")
                sb = records[0].get("sub_batch")
                last_idx = records[-1].get("idx")
        except Exception:
            pass
        print("âŒâŒâŒ é´çº§å®Œæ•´æ€§å¤±è´¥ï¼šä¸è¶³9å£ | æ–‡ä»¶|Sub-Batch|idx =", f, sb, last_idx)
        raise RuntimeError("é´çº§å®Œæ•´æ€§å¤±è´¥ï¼šä¸è¶³9å£")
    return True



# ------------------------------------------------------------
# 3) å•æ‰¹æ¬¡ç­–ç•¥å…¥å£ï¼ˆåªå…è®¸æ”¹è¿™é‡Œï¼‰
# ------------------------------------------------------------
def run_strategy_on_boot(records):
    """å•é´æ‰§è¡Œï¼šç»“æ„->â­(DECISION)->æ‰§è¡Œæ¨è¿›(EXECUTE/SETTLE)ã€‚

    äºŒæ¬¡åŠ å›ºï¼ˆé”æ­»ï¼‰è¦ç‚¹ï¼š
      - æŒ‡æ ‡åªå…è®¸åœ¨ DECISION/STAR å†™å¿«ç…§ä¸è¯»å–ï¼ˆsecure_write_star_snapshot / secure_read_metricï¼‰
      - è¿›å…¥ EXECUTE/SETTLE åï¼Œrecords å…¨éƒ¨å»æŒ‡æ ‡åŒ–ï¼ˆguard_future_rows ä» 0 å¼€å§‹ï¼‰
      - ç¦æ­¢ star_idx + 1 ç­‰â€œidx+åç§»â€ç›´ç®—ï¼šåªèƒ½ç”¨ advance_one_row è‡ªç„¶æ¨è¿›
    """
    if not records or not STRUCT_SCAN:
        return None

    phase = "SCAN"
    decision_used = False

    # 1) ç»“æ„æ‰«æ
    st, star_idx, strong_side, struct_info = scan_structure(records)
    if st != "STRUCT_OK":
        return None

    entry = 1
    match = 0
    mismatch = 0
    stop = 0
    exhaustion = 0
    profit = 0.0

    # 2) DECISIONï¼šä»…â­è¡Œå†™å¿«ç…§
    phase = phase_transition(phase, "DECISION")
    decision_used = True
    star_row = records[star_idx]
    star_seen = star_row.get("seen_all")
    star_rr = star_row.get("r")
    star_boot_id = star_row.get("shoe_id")

    star_snap = secure_write_star_snapshot(
        star_row, phase,
        seen_all=star_seen, rr=star_rr, boot_id=star_boot_id, star_idx=star_idx,
        star_snapshot_is_none=True
    )

    # 3) EXECUTEï¼šå»æŒ‡æ ‡åŒ–ï¼ˆæ ¹æºç­ç«ï¼‰
    phase = phase_transition(phase, "EXECUTE")
    guard_future_rows(records, 0)

    # æ¨è¿›å™¨ï¼ˆå”¯ä¸€å…è®¸çš„â€œä¸‹ä¸€è¡Œâ€æ–¹å¼ï¼‰
    def advance_one_row(j):
        jj = j + 1
        if jj >= len(records):
            return None
        return jj

    # 4) æ‰§è¡Œ 1-2-4-8
    target_side = strong_side
    units = [1, 2, 4, 8]
    bet_n = 1
    j = star_idx
    j = advance_one_row(j)

    is_settled = False
    trade_bust = 0
    snapshots = []

    while bet_n <= 4 and j is not None:
        row = records[j]
        rr = row.get("r")
        if rr == "T":
            j = advance_one_row(j)
            continue

        # é´çº§é—¸é—¨ï¼šå®é™…è½æ³¨ç‚¹ä¸å¾—è½åœ¨ seen_all=1..8ï¼ˆéTæ‰ç®—â€œå®é™…è½æ³¨ç‚¹â€ï¼‰
        if BOOT_FILTER:
            try:
                sa = int(row.get("seen_all"))
                if 1 <= sa <= 8:
                    global BET_IN_FORBIDDEN_SEEN
                    BET_IN_FORBIDDEN_SEEN += 1
                    _raise_guard(code="BET_IN_FORBIDDEN_SEEN", rule_id=10, phase="EXECUTE", msg="ç¦åŒºä¸‹æ³¨", evidence=f"file={row.get('file')}|idx={row.get('idx')}|seen_all={row.get('seen_all')}")
            except RuntimeError:
                raise
            except Exception:
                pass

        # ä»…ä¿ç•™å…ƒä¿¡æ¯ï¼ˆä¸å«æŒ‡æ ‡ï¼‰
        snapshots.append({
            "bet_n": bet_n,
            "r": rr,
            "idx": row.get("idx"),
            "seen_all": row.get("seen_all"),
            "shoe_id": row.get("shoe_id"),
        })

        u = units[bet_n - 1]
        if rr == target_side:
            # èµ¢
            profit += (u * 0.95 if target_side == "B" else u * 1.0)
            match += 1
            is_settled = True
            break
        else:
            # è¾“
            profit -= u
            bet_n += 1
            j = advance_one_row(j)
            continue

    if not is_settled:
        mismatch += 1
        exhaustion += 1
        trade_bust = 1

    phase = phase_transition(phase, "DONE")

    return {
        "entry": entry,
        "match": match,
        "mismatch": mismatch,
        "break": exhaustion,
        "stop": stop,
        "profit": profit,
        "trade_bust": trade_bust,
        "star_snap": star_snap,
        "snapshots": snapshots,
        "struct_status": st,
        "struct_strong": strong_side,
        "struct_star_idx": star_idx,
        "struct_fail_reason": struct_info.get("fail_reason"),
        "struct_forbidden_star_cnt": struct_info.get("forbidden_star_cnt", 0),
        "struct_forbidden_star_first_seen": struct_info.get("forbidden_star_first_seen"),
        "decision_used": 1 if decision_used else 0,
    }



def _find_existing_col(row0: dict, candidates):
    """åœ¨è¡¨å¤´é‡ŒæŒ‰å€™é€‰åæ‰¾åˆ—ï¼ˆå¤§å°å†™ä¸æ•æ„Ÿï¼‰ã€‚æ‰¾ä¸åˆ°è¿”å› Noneã€‚"""
    if not isinstance(row0, dict):
        return None
    # ç›´æ¥åŒ¹é…
    for c in candidates:
        if c in row0:
            return c
    # å°å†™åŒ¹é…
    lower_map = {str(k).lower(): k for k in row0.keys()}
    for c in candidates:
        k = lower_map.get(str(c).lower())
        if k is not None:
            return k
    return None


def _to_int_strict(v):
    if v is None:
        raise RuntimeError("PPBB_PARSE_FAIL(None)")
    s = str(v).strip()
    if s == "" or s.lower() == "none":
        raise RuntimeError("PPBB_PARSE_FAIL(Empty/None)")
    # å…è®¸ "3.0" è¿™ç±»
    return int(float(s))


def _ppbb_identity_sample_check(rows, col_result, col_diff, fname):
    """ç‚¹å·®æ’ç­‰å¼ + ç»“æœæ˜ å°„æŠ½æ£€ï¼ˆé”æ­»è¯­ä¹‰ï¼šPP=é—²ç‚¹ï¼ŒBB=åº„ç‚¹ï¼‰ã€‚

    æŠ½æ£€ï¼š
      - ç‚¹å·® == (BB - PP)
      - éTï¼šBB>PP -> Bï¼›PP>BB -> Pï¼›Tï¼šBB==PP
    ä»»æ„ä¸ä¸€è‡´ï¼šraise å¹¶æ‰“å°æœ€å°è¯æ®ã€‚
    """
    global PPBB_CHECKED, PPBB_MISMATCH, PPBB_FIRST_EVIDENCE
    if not ENFORCE_PPBB_SEMANTICS:
        return

    if not rows:
        return

    row0 = rows[0] if isinstance(rows[0], dict) else {}
    col_bb = _find_existing_col(row0, ["BB", "åº„ç‚¹", "BANKER", "BPoint"])
    col_pp = _find_existing_col(row0, ["PP", "é—²ç‚¹", "PLAYER", "PPoint"])

    if col_bb is None or col_pp is None:
        raise RuntimeError(f"âŒâŒâŒ è¡¨å¤´ç¼ºå¤±ï¼šå¿…é¡»å­˜åœ¨ BB/PPï¼ˆåº„ç‚¹/é—²ç‚¹ï¼‰| æ–‡ä»¶={fname}")

    if col_result is None or col_diff is None:
        # ç»“æœ/ç‚¹å·®åˆ—ç¼ºå¤±ä¼šè¢«ä¸Šæ¸¸å¼ºåˆ¶æ‹¦æˆªï¼›è¿™é‡Œä¸é‡å¤
        return

    sample_n = min(len(rows), 200)
    for i in range(sample_n):
        r = rows[i]
        if not isinstance(r, dict):
            continue

        rr = (r.get(col_result) or "").strip()
        if rr not in ("B", "P", "T"):
            continue

        try:
            bb = _to_int_strict(r.get(col_bb))
            pp = _to_int_strict(r.get(col_pp))
            diff_val = _to_int_strict(r.get(col_diff))
        except Exception as e:
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"PARSE_FAIL | file={fname} | row={i+2} | err={e}"
            print(f"âŒâŒâŒ ç‚¹å·®æ’ç­‰å¼æŠ½æ£€å¤±è´¥ï¼šæ— æ³•è§£æ | æ–‡ä»¶={fname} | è¡Œ={i+2}")
            print(f"  BB={r.get(col_bb)} | PP={r.get(col_pp)} | ç‚¹å·®={r.get(col_diff)} | ç»“æœ={rr}")
            raise

        # 1) ç‚¹å·®æ’ç­‰å¼
        if diff_val != (bb - pp):
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"DIFF_MISMATCH | file={fname} | row={i+2} | BB={bb} PP={pp} diff={diff_val}"
            print(f"âŒâŒâŒ ç‚¹å·®æ’ç­‰å¼ä¸ä¸€è‡´ | æ–‡ä»¶={fname} | è¡Œ={i+2}")
            print(f"  BB={bb} | PP={pp} | ç‚¹å·®={diff_val} | (BB-PP)={bb-pp} | ç»“æœ={rr}")
            raise RuntimeError("PPBB_DIFF_IDENTITY_FAIL")

        # 2) ç»“æœæ˜ å°„ä¸€è‡´æ€§
        if rr == "B" and not (bb > pp):
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"RES_MISMATCH_B | file={fname} | row={i+2} | BB={bb} PP={pp}"
            print(f"âŒâŒâŒ ç»“æœæ˜ å°„ä¸ä¸€è‡´(B) | æ–‡ä»¶={fname} | è¡Œ={i+2}")
            print(f"  BB={bb} | PP={pp} | ç»“æœ={rr}")
            raise RuntimeError("PPBB_RESULT_IDENTITY_FAIL")
        if rr == "P" and not (pp > bb):
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"RES_MISMATCH_P | file={fname} | row={i+2} | BB={bb} PP={pp}"
            print(f"âŒâŒâŒ ç»“æœæ˜ å°„ä¸ä¸€è‡´(P) | æ–‡ä»¶={fname} | è¡Œ={i+2}")
            print(f"  BB={bb} | PP={pp} | ç»“æœ={rr}")
            raise RuntimeError("PPBB_RESULT_IDENTITY_FAIL")
        if rr == "T" and not (bb == pp):
            PPBB_MISMATCH += 1
            if PPBB_FIRST_EVIDENCE is None:
                PPBB_FIRST_EVIDENCE = f"RES_MISMATCH_T | file={fname} | row={i+2} | BB={bb} PP={pp}"
            print(f"âŒâŒâŒ ç»“æœæ˜ å°„ä¸ä¸€è‡´(T) | æ–‡ä»¶={fname} | è¡Œ={i+2}")
            print(f"  BB={bb} | PP={pp} | ç»“æœ={rr}")
            raise RuntimeError("PPBB_RESULT_IDENTITY_FAIL")

    PPBB_CHECKED += sample_n


def load_all_boots(csv_files):
    # boots: list of (meta, records)
    boots = []  # æ¯ä¸ªå…ƒç´ ï¼š({"file":..., "sub_batch":...}, [records...])

    print("æ£€æµ‹åˆ° CSV æ–‡ä»¶æ•°é‡:", len(csv_files))

    for i, fname in enumerate(csv_files, 1):
        if i % 10 == 0:
            print(f"è¿›åº¦: å·²å¤„ç† {i}/{len(csv_files)} ä¸ªæ–‡ä»¶")

        rows = []
        for enc in ("utf-8", "utf-8-sig", "gbk", "gb18030"):
            try:
                with open(fname, "r", encoding=enc) as f:
                    rows = list(csv.DictReader(f))
                break
            except Exception:
                rows = []

        if not rows:
            continue

        col_batch, col_end, col_result, col_diff, col_rate, col_mean = detect_columns(rows[0])
        _print_header_mapping_once(rows[0], (col_batch, col_end, col_result, col_diff, col_rate, col_mean))
        _ppbb_identity_sample_check(rows, col_result, col_diff, fname)

        if col_batch is None or col_end is None:
            print("âŒâŒâŒ è¡¨å¤´ç¼ºå¤±ï¼šå¿…é¡»åŒæ—¶å­˜åœ¨ Sub-Batch ä¸ é´ç»“æŸ | æ–‡ä»¶ =", fname)
            raise RuntimeError("è¡¨å¤´ç¼ºå¤±ï¼šSub-Batch / é´ç»“æŸ")

        current_batch = None
        current_records = []
        seen_all = 0
        end_seen = 0

        def _finalize_boot():
            nonlocal current_batch, current_records, seen_all, end_seen
            if current_batch is None:
                return
            if not current_records:
                return

            # é´ç»“æŸä¸€è‡´æ€§ï¼šä»…æœ€åä¸€å£ä¸º1ï¼Œå…¶ä½™ä¸º0ï¼ˆé”æ­»ï¼‰
            if end_seen != 1:
                print("âŒâŒâŒ é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šé´ç»“æŸ=1æ¬¡æ•°!=1 | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch, (current_records[-1].get("idx") if current_records else None))
                raise RuntimeError("é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šé´ç»“æŸ=1æ¬¡æ•°!=1")
            if safe_int(current_records[-1].get("shoe_end"), 0) != 1:
                print("âŒâŒâŒ é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæœ€åä¸€å£é´ç»“æŸ!=1 | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch, current_records[-1].get("idx"))
                raise RuntimeError("é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæœ€åä¸€å£é´ç»“æŸ!=1")

            boots.append(({"file": fname, "sub_batch": current_batch}, current_records))

            # reset
            current_batch = None
            current_records = []
            seen_all = 0
            end_seen = 0

        for row_i, r in enumerate(rows):
            batch = r.get(col_batch)

            # å­æ‰¹æ¬¡å¯åŠ¨
            if current_batch is None:
                current_batch = batch

            # Sub-Batch å˜æ›´å¿…é¡»ä¸é´ç»“æŸå¯¹é½ï¼ˆé”æ­»ï¼‰ï¼šæœªé‡åˆ°é´ç»“æŸ=1 ä¸å…è®¸å˜æ›´
            if batch != current_batch:
                print("âŒâŒâŒ é´è¾¹ç•Œå¤±è´¥ï¼šSub-Batch åœ¨é´ç»“æŸå‰å‘ç”Ÿå˜æ›´ | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch, (current_records[-1].get("idx") if current_records else None))
                raise RuntimeError("é´è¾¹ç•Œå¤±è´¥ï¼šSub-Batch å˜æ›´æœªå¯¹é½é´ç»“æŸ")

            res_raw = r.get(col_result)
            res = map_result(res_raw)
            if res not in ("B", "P", "T"):
                # æ— æ³•æ˜ å°„çš„ä¸å…¥åº“ï¼ˆé”æ­»ï¼‰
                continue

            diff = safe_int(r.get(col_diff, 0), 0)
            rate_raw = (r.get(col_rate) if col_rate else None)
            mean_raw = (r.get(col_mean) if col_mean else None)
            rate = safe_float(rate_raw, None, kind="RATE") if col_rate else None
            mean = safe_float(mean_raw, None, kind="MEAN") if col_mean else None
            shoe_end = safe_int(r.get(col_end, 0), 0)

            seen_all += 1
            rec = {
                "idx": seen_all - 1,
                "seen_all": seen_all,
                "r": res,
                "diff": diff,
                "rate": rate,
                "mean": mean,
            "rate_raw": rate_raw,
            "mean_raw": mean_raw,
                "file": fname,
                "sub_batch": current_batch,
                "shoe_end": shoe_end,
            }
            current_records.append(rec)

            if shoe_end == 1:
                end_seen += 1
                _finalize_boot()

        # æ–‡ä»¶ç»“æŸï¼šè‹¥ä»æœ‰æœªå°å£çš„é´ â†’ æŠ¥é”™
        if current_batch is not None:
            if current_records:
                print("âŒâŒâŒ é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæ–‡ä»¶ç»“æŸä»æœªé‡åˆ°é´ç»“æŸ=1 | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch, current_records[-1].get("idx"))
                raise RuntimeError("é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæ–‡ä»¶ç»“æŸæœªå°å£")

    print("æŒ‰ Sub-Batch + é´ç»“æŸ åˆ†é´å®Œæˆï¼Œé´æ€»æ•°:", len(boots))
    return boots

def _run_report(csv_files, title):
    boots = load_all_boots(csv_files)
    total_boots = len(boots)

    playable_boots = 0
    skipped_boots = 0

    total_entry = 0
    total_match = 0
    total_mismatch = 0
    total_exhaustion = 0
    total_profit = 0.0

    # ------------------------------------------------------------
    # L1 é”æ­»æ ‡é¢˜ç»Ÿè®¡ï¼ˆæŠ•æ”¾ç‚¹å½“è¡Œï¼‰
    # ------------------------------------------------------------
    l1_diff_dist = defaultdict(int)  # key: '0'..'9','9+'
    l1_rate_dist = defaultdict(int)  # key: å‰å°/å‰å¤§/æå€¼/æ— æ•ˆ
    l1_mean_dist = defaultdict(int)  # key: æœ‰æ•ˆåŒå‘/æœ‰æ•ˆåå‘/ä¸­è½´
    STAR_ON_T = 0
    STAR_DIFF0_AND_R_IN_BP = 0
    MEAN_MISSING_RAW = 0  # æ•°æ®ç¼ºå¤±-ä»…ç»Ÿè®¡
    MEAN_PARSE_FAIL = 0     # è§£æå¤±è´¥-ç›®æ ‡=0
    MEAN_INVALID_BUG = 0  # (ç›®æ ‡=0) ç‚¹å·®=0å´è¢«åˆ¤ä¸ºå‡å·®æ— æ•ˆ
    STRUCT_SCAN_CALLS = 0
    STRUCT_OK = 0
    STRUCT_FAIL = 0
    MISS_MAIN_LT3 = 0
    MISS_WEAK_GT2 = 0
    MISS_NO_CANDIDATE = 0
    MISS_ONLY_FORBIDDEN = 0



    cont_agg = _init_cont_agg() if CONT_STATS_ENABLE else None

    # ------------------------------------------------------------
    # æ‰¹æ¬¡å¤„ç†è¿›åº¦è¾“å‡ºï¼ˆåªæ‰“å°ï½œä¸å‚ä¸ä»»ä½•åˆ¤æ–­ï¼‰
    # ------------------------------------------------------------
    def _print_batch_progress(done, total, bar_width=20, force_newline=False):
        if total <= 0:
            return
        if done < 0:
            done = 0
        if done > total:
            done = total
        ratio = done / total
        filled = int(ratio * bar_width)
        if filled < 0:
            filled = 0
        if filled > bar_width:
            filled = bar_width
        bar = ("=" * filled) + (" " * (bar_width - filled))
        pct = ratio * 100.0
        line = f"è¿›åº¦: [{bar}] {pct:.1f}% ({done:,}/{total:,} æ‰¹æ¬¡)"
        if force_newline:
            print(line)
        else:
            print("\r" + line, end="", flush=True)

    if total_boots > 0:
        print()
        print(f"å¼€å§‹å¤„ç† {total_boots:,} ä¸ªæ‰¹æ¬¡...")

    step = max(1, total_boots // 200) if total_boots > 0 else 1

    for n, (meta, rec) in enumerate(boots, 1):
        if total_boots > 0 and (n == 1 or n == total_boots or (n % step == 0)):
            _print_batch_progress(n, total_boots)
        boot_filter(rec)  # é´çº§å®Œæ•´æ€§æ ¡éªŒï¼ˆä¸è¶³9å£ç›´æ¥æŠ¥é”™ï¼‰

        global _CTX_FILE, _CTX_SUBBATCH
        _CTX_FILE = meta.get('file', '')
        _CTX_SUBBATCH = meta.get('sub_batch', '')
        out = run_strategy_on_boot(rec)

        # ç»“æ„/æŠ•æ”¾ç‚¹ä¸æ»¡è¶³åˆ™ä¸å…¥åœºï¼ˆout=Noneï¼‰ï¼Œå¿…é¡»è·³è¿‡ï¼Œé¿å…ç©ºæŒ‡é’ˆ
        if out is None:
            skipped_boots += 1
            continue

        playable_boots += 1

        # L1 æŠ•æ”¾ç‚¹å½“è¡Œç»Ÿè®¡ï¼šä»…ä½¿ç”¨ star_snapï¼ˆå–å€¼å£é”æ­»ï¼‰
        star = out.get("star_snap")
        if isinstance(star, Snapshot):
            sr = star.rr
            sd = secure_read_metric(star, "diff", "REPORT", who="REPORT", idx=star.idx, boot_id=star.boot_id, seen_all=star.seen_all)
            srate = secure_read_metric(star, "rate", "REPORT", who="REPORT", idx=star.idx, boot_id=star.boot_id, seen_all=star.seen_all)
            smean = secure_read_metric(star, "mean", "REPORT", who="REPORT", idx=star.idx, boot_id=star.boot_id, seen_all=star.seen_all)

            if sr == "T":
                STAR_ON_T += 1
            elif sr in ("B", "P"):
                if safe_int(sd, 0) == 0:
                    STAR_DIFF0_AND_R_IN_BP += 1

                l1_diff_dist[_l1_abs_diff_bucket(sd)] += 1
                l1_rate_dist[_l1_rate_bucket(srate)] += 1

                # L1å‡å·®åˆ†æ¡¶ï¼šåŒºåˆ†ç¼ºå¤±/è§£æå¤±è´¥ï¼ˆè§£æå¤±è´¥ç›®æ ‡=0ï¼‰
                mean_raw = secure_read_metric(star, "mean_raw", "REPORT", who="REPORT", idx=star.idx, boot_id=star.boot_id, seen_all=star.seen_all)
                mean_val = smean

                if _is_raw_missing(mean_raw):
                    if mean_val is None:
                        MEAN_MISSING_RAW += 1
                        mb = None
                    else:
                        mb, _ = _l1_mean_bucket(sd, mean_val)
                else:
                    if mean_val is None:
                        MEAN_PARSE_FAIL += 1
                        mb = None
                    else:
                        mb, _ = _l1_mean_bucket(sd, mean_val)

                if mb is not None:
                    l1_mean_dist[mb] += 1

        # ç»“æ„æ‰«æè‡ªè¯ç»Ÿè®¡
        if STRUCT_SCAN:
            STRUCT_SCAN_CALLS += 1
            if out.get("struct_status") == "STRUCT_OK":
                STRUCT_OK += 1
            elif out.get("struct_status") == "STRUCT_FAIL":
                STRUCT_FAIL += 1
                fr = out.get("struct_fail_reason")
                if fr == "MAIN_LT3":
                    MISS_MAIN_LT3 += 1
                elif fr == "WEAK_GT2":
                    MISS_WEAK_GT2 += 1
                elif fr == "NO_CANDIDATE":
                    MISS_NO_CANDIDATE += 1
                elif fr == "ONLY_FORBIDDEN":
                    MISS_ONLY_FORBIDDEN += 1

        total_entry += int(out.get("entry", 0))
        total_match += int(out.get("match", 0))
        total_mismatch += int(out.get("mismatch", 0))
        total_exhaustion += int(out.get("exhaustion", 0))
        total_profit += float(out.get("profit", 0.0))

        if (cont_agg is not None) and (not SILENT_MODE):
            _cont_consume_snapshots(cont_agg, out.get("snapshots") or [])

    if total_boots > 0:
        print()  # ç»“æŸè¿›åº¦è¡Œ

    print()
    print("============================================================")
    print("ğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°")
    print("============================================================")
    print(title)
    print("============================================================")
    print("æ‰«ææ–¹å¼ï¼šä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“")
    print("æ®µé•¿å£å¾„ï¼šç¦æ­¢è·¨æ®µç´¯è®¡")
    print("æœ¯è¯­é”æ­»ï¼šåªæ‰¿è®¤ã€Œâ­ / æŠ•æ”¾ç‚¹ã€")
    _print_switches_block("HEADER")
    print(f"{STRUCT_SUMMARY_LINE} | HASH={STRUCT_DEF_HASH}")
    global _STRUCT_SUMMARY_PRINTED
    _STRUCT_SUMMARY_PRINTED = True
    print(f"ç›‘æµ‹å¼€å…³ï¼š{'å¼€' if MONITOR_ENABLE else 'å…³'}")
    print("é˜ˆå€¼å‡»ç©¿å½’å› ï¼šè·¯å¾„å¿«ç…§ï¼ˆæ¯æ¬¡å®é™…æŠ•æ”¾å‰éƒ½å¿«ç…§ï¼›å«çŠ¶æ€ T åçš„é‡å¤æŠ•æ”¾ï¼›å½’å› åªç”¨å¿«ç…§ï¼‰")
    print("------------------------------------------------------------")
    print("TOTAL_BOOT       :", total_boots)
    print("------------------------------------------------------------")
    print("æ€»æ‰¹æ¬¡æ•°    :", total_boots)
    print("å¯å‚ä¸æ‰¹æ¬¡æ•°:", playable_boots)
    print("è·³è¿‡æ‰¹æ¬¡æ•°  :", skipped_boots)
    print("------------------------------------------------------------")
    entry_pct = (total_entry / total_boots * 100.0) if total_boots > 0 else 0.0
    print(f"æ¿€æ´»æ¬¡æ•°    : {total_entry} ({entry_pct:.2f}%)")
    match_pct = (total_match / total_entry * 100.0) if total_entry > 0 else 0.0
    mismatch_pct = (total_mismatch / total_entry * 100.0) if total_entry > 0 else 0.0
    print(f"åŒ¹é…æ¬¡æ•°    : {total_match} ({match_pct:.2f}%)")
    print(f"ä¸åŒ¹é…æ¬¡æ•°  : {total_mismatch} ({mismatch_pct:.2f}%)")

    # ==========================
    # æ­£å€¼è§¦å‘è‡ªå®¡ï¼ˆæ—¶é—´ç®¡ç†å±€ï½œé”æ­»ï½œåœ¨æœ€ç»ˆæ±‡æ€»æ‰“å°ä¹‹å‰ï¼‰
    # ==========================
    avg_profit = (total_profit / total_entry) if total_entry else 0.0
    trigger_total = bool(POSITIVE_AUDIT_TRIGGER_TOTAL and total_profit > 0)
    trigger_avg = bool(POSITIVE_AUDIT_TRIGGER_AVG and avg_profit > 0)

    # Stop/Zeroï¼ˆæœ¬æ¨¡æ¿å½“å‰æœªå¯ç”¨ï¼Œé”æ­»ä¸º 0ï¼Œä½†ä»å‚ä¸é—­ç¯ä¸è‡ªå®¡ï¼‰
    total_stop = 0
    total_zero = 0

    # æ’ç­‰å¼é—­ç¯ï¼ˆé”æ­»ï¼‰
    closure_diff = int(total_entry) - int(total_match + total_mismatch + total_exhaustion + total_stop + total_zero)

    final_metrics = {
        "total_profit": total_profit,
        "avg_profit": avg_profit,
        "entry": total_entry,
        "match": total_match,
        "mismatch": total_mismatch,
        "break": total_exhaustion,
        "stop": total_stop,
        "zero": total_zero,
        "bet_in_forbidden_seen": BET_IN_FORBIDDEN_SEEN,
        "ppbb_mismatch": PPBB_MISMATCH,
        "ppbb_first_evidence": PPBB_FIRST_EVIDENCE,
        "trigger_total": trigger_total,
        "trigger_avg": trigger_avg,
        "closure_diff": closure_diff,
    }

    if POSITIVE_AUDIT_ENABLE and (trigger_total or trigger_avg):
        SELF_AUDIT_GATE(final_metrics)

    exhaust_pct = (total_exhaustion / total_entry * 100.0) if total_entry > 0 else 0.0
    print(f"é˜ˆå€¼å‡»ç©¿æ¬¡æ•°: {total_exhaustion} ({exhaust_pct:.2f}%)")

    print("è‡ªåœæ¬¡æ•°:", total_stop)
    print("é›¶å€¼æ¬¡æ•°:", total_zero)
    print(f"æ’ç­‰å¼é—­ç¯: Entry == Match + Mismatch + Break + Stop + Zero | Diff={closure_diff}")
    if closure_diff != 0:
        raise RuntimeError("âŒâŒâŒ æ’ç­‰å¼é—­ç¯å¤±è´¥ï¼ˆEntry ä¸ç»ˆæ€è®¡æ•°ä¸ä¸€è‡´ï¼‰")

    if total_entry > 0:
        match_rate = total_match / total_entry * 100.0
        exhaustion_rate = total_exhaustion / total_entry * 100.0
        print(f"åŒ¹é…ç‡      : {match_rate:.4f}%")
        print(f"é˜ˆå€¼å‡»ç©¿ç‡  : {exhaustion_rate:.4f}%")
        print(f"ğŸ’¶ğŸ’¶ğŸ’¶ å•æ¬¡å¹³å‡å¢ç›Š: {total_profit / total_entry:.6f}")
    print("ğŸ’¶ğŸ’¶ğŸ’¶ æ€»å‡€å€¼å¢ç›Š  :", round(total_profit, 2))

    if (AUDIT_RUN == 1) or (not SILENT_MODE):
        print()
        print("------------------------------------------------------------")
        print("[é”æ­»æ ‡é¢˜] L1ç‚¹å·®åˆ†å¸ƒï¼ˆæŠ•æ”¾ç‚¹ï½œ|ç‚¹å·®|=0..9 + 9+ï¼‰:")
        for k in [str(i) for i in range(0, 10)] + ["9+"]:
            if k in l1_diff_dist:
                print(f"  {k}: {l1_diff_dist[k]}")
        print("------------------------------------------------------------")
        print("[é”æ­»æ ‡é¢˜] L1å˜åŒ–ç‡åˆ†æ¡¶ï¼ˆæŠ•æ”¾ç‚¹ï½œå‰å°/å‰å¤§/æå€¼/æ— æ•ˆï¼‰:")
        for k in ["å‰å°", "å‰å¤§", "æå€¼", "æ— æ•ˆ"]:
            if k in l1_rate_dist:
                print(f"  {k}: {l1_rate_dist[k]}")
        print("------------------------------------------------------------")
        print("[é”æ­»æ ‡é¢˜] L1å‡å·®åˆ†æ¡¶ï¼ˆæŠ•æ”¾ç‚¹ï½œæœ‰æ•ˆåŒå‘/æœ‰æ•ˆåå‘/ä¸­è½´ï¼‰:")
        for k in ["æœ‰æ•ˆåŒå‘", "æœ‰æ•ˆåå‘", "ä¸­è½´"]:
            if k in l1_mean_dist:
                print(f"  {k}: {l1_mean_dist[k]}")

    print("------------------------------------------------------------")
    print("è‡ªè¯é¡¹ï¼ˆæ¯æ¬¡è·‘å¿…å‡ºï¼‰:")
    print("  å¼€å…³è‡ªè¯ï¼ˆè¡¨å¤´+è‡ªè¯å„1æ¬¡ï¼Œç¼ºå¤±å³ä½œåºŸï¼‰:")
    _print_switches_block("PROOF")
    print("  STAR_ON_T:", STAR_ON_T)
    print("  STAR_DIFF0_AND_R_IN_BP:", STAR_DIFF0_AND_R_IN_BP)
    print("  MEAN_MISSING_RAW:", MEAN_MISSING_RAW)
    print("  MEAN_PARSE_FAIL:", MEAN_PARSE_FAIL)
    print("  MEAN_INVALID_BUG(ç›®æ ‡=0):", MEAN_INVALID_BUG)
    print("  PPBB_IDENTITY_CHECKED:", PPBB_CHECKED, "| PPBB_MISMATCH:", PPBB_MISMATCH)
    if PPBB_FIRST_EVIDENCE is not None:
        print("  PPBB_FIRST_EVIDENCE:", PPBB_FIRST_EVIDENCE)


    if cont_agg is not None:
        print()
        print("------------------------------------------------------------")
        print("è¿æ®µç»Ÿè®¡ï¼ˆåŒæŒ‡æ ‡ç›¸é‚»æ€ï½œäº‹åæ±‡æ€»ï¼‰")
        print("è¯´æ˜ï¼šä»…åŸºäºæŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨ï¼ˆå«çŠ¶æ€ T é‡å¤æŠ•æ”¾ï¼‰ï¼›æ ·æœ¬é‡ä¸è¶³ä¸è¾“å‡ºã€‚")
        print("é˜ˆå€¼ï¼šmin_samples=%dï½œTopK=%d" % (CONT_MIN_SAMPLES, CONT_TOPK))

        _print_top_transitions(
            "A) (|ç‚¹å·®|,rate ç›‘æµ‹æ¡¶) Overall Top",
            cont_agg["pair_rate_overall"],
            CONT_MIN_SAMPLES,
            CONT_TOPK,
        )
        _print_top_transitions(
            "B) (|ç‚¹å·®|,mean æ¡¶) Overall Top",
            cont_agg["pair_mean_overall"],
            CONT_MIN_SAMPLES,
            CONT_TOPK,
        )

        max_bn = min(int(cont_agg.get("max_bet_n_seen", 0) or 0), CONT_MAX_BET_N)
        for bn in range(2, max_bn + 1):
            tmp_rate = {}
            tmp_mean = {}
            for (bn2, a, b), v in cont_agg["pair_rate"].items():
                if bn2 == bn:
                    tmp_rate[(a, b)] = v
            for (bn2, a, b), v in cont_agg["pair_mean"].items():
                if bn2 == bn:
                    tmp_mean[(a, b)] = v

            _print_top_transitions(
                f"A) bet_n={bn} (|ç‚¹å·®|,rate ç›‘æµ‹æ¡¶) Top",
                tmp_rate,
                CONT_MIN_SAMPLES,
                min(10, CONT_TOPK),
            )
            _print_top_transitions(
                f"B) bet_n={bn} (|ç‚¹å·®|,mean æ¡¶) Top",
                tmp_mean,
                CONT_MIN_SAMPLES,
                min(10, CONT_TOPK),
            )

    
    # ç‰©ç†é”æ­»ï¼šå¿…é¡»æ‰“å°ä¸¤å¤„å¼€å…³ï¼Œå¦åˆ™ç›´æ¥ä½œåºŸ
    if not _PRINTED_SWITCHES_HEADER:
        raise RuntimeError("âŒ ç¼ºå¤±è¡¨å¤´å¼€å…³è‡ªè¯ï¼šBOOT_FILTER/STRUCT_SCAN æœªæ‰“å°")
    if not _PRINTED_SWITCHES_PROOF:
        raise RuntimeError("âŒ ç¼ºå¤±å¼ºåˆ¶è‡ªè¯å¼€å…³ï¼šBOOT_FILTER/STRUCT_SCAN æœªæ‰“å°")

def main():
    try:
        
        # é¦–å±æ°´å°ï¼ˆç¡¬é”æ­»ï¼‰
        print(WATERMARK_TEXT)
        global _WATERMARK_PRINTED
        _WATERMARK_PRINTED = True
        
        # ã€å¼ºåˆ¶è‡ªè¯è¾“å‡ºã€‘ï¼ˆç¡¬é”æ­»ï¼‰
        print("ã€å¼ºåˆ¶è‡ªè¯è¾“å‡ºã€‘")
        print(f"ç»“æ„é—¸é—¨ï¼š{STRUCT_SCAN_TEXT}")
        print(f"é´çº§å¼€å…³ï¼š{BOOT_FILTER_TEXT}")
        print(f"BET_IN_FORBIDDEN_SEEN = {BET_IN_FORBIDDEN_SEEN} (0.00%)")
        print(f"PPBB_IDENTITY_CHECKED = {PPBB_CHECKED} | PPBB_MISMATCH = {PPBB_MISMATCH}")
        global _PROOF_BLOCK_PRINTED
        _PROOF_BLOCK_PRINTED = True
        
        # ç¡¬æ³¨å…¥è‡ªæ£€ï¼ˆå¿…é¡» raise é˜»æ–­ï¼Œä¸å¾—åé”™ï¼‰
        print("=== æ­£åœ¨æ‰§è¡Œç¡¬æ³¨å…¥è‡ªæ£€ ===")
        try:
            # ç”¨ä¾‹Aï¼šTè¡Œå†™å¿«ç…§ -> å¿…é¡»é˜»æ–­âœ…
            _ = write_star_snapshot("DECISION", {"r": "T", "seen_all": 9, "diff": 1, "rate": "None", "mean": "None", "shoe_id": "SELFTEST"}, 0)
            raise RuntimeError("SELF_TEST_FAIL: T_SNAPSHOT_NOT_BLOCKED")
        except RuntimeError:
            pass
        
        try:
            # ç”¨ä¾‹Bï¼šéDECISIONè¯»æŒ‡æ ‡ -> å¿…é¡»é˜»æ–­âœ…
            tmp = Snapshot({"diff": 1, "rate": None, "mean": None, "rate_raw": "None", "mean_raw": "None"}, boot_id="SELFTEST", idx=0, seen_all=9, rr="B", source="STAR_ROW")
            _ = secure_read_metric(tmp, "diff", "EXECUTE", who="STAR", idx=0, boot_id="SELFTEST", seen_all=9)
            raise RuntimeError("SELF_TEST_FAIL: NON_DECISION_METRIC_NOT_BLOCKED")
        except RuntimeError:
            pass
        
        try:
            # ç”¨ä¾‹Cï¼šæ‰§è¡Œæ¨è¿›ä¸­è¯»å–æŒ‡æ ‡ï¼ˆé€šè¿‡ MetricGuardRowï¼‰-> å¿…é¡»é˜»æ–­âœ…
            g = MetricGuardRow({"r": "B", "diff": 1, "rate": 0.1, "mean": 1.0})
            _ = g.get("rate")
            raise RuntimeError("SELF_TEST_FAIL: EXECUTE_METRIC_NOT_BLOCKED")
        except RuntimeError:
            pass
        
        print("ç¡¬æ³¨å…¥éªŒè¯=é€šè¿‡âœ…")
        print("éæ³•æŒ‡æ ‡è®¿é—®æ¨¡æ‹Ÿ=å·²é˜»æ–­âœ…")
        print("Tè¡Œå†™å¿«ç…§=å·²é˜»æ–­âœ…")
        print("é˜»æ–­æ–¹å¼=raiseâœ…(æœªåé”™)")
        print("=== è‡ªæ£€å®Œæˆ ===")
        global _SELFTEST_PASSED
        _SELFTEST_PASSED = True
        _audit_structure_slot_integrity()
        _audit_forbid_idx_offset()
        _print_source_hashes()
        csv_files = sorted([f for f in os.listdir(".") if f.lower().endswith(".csv")])
        if VERIFY_SPLIT_ENABLE and len(csv_files) >= 2:
            mid = len(csv_files) // 2
            _run_report(csv_files[:mid], "éªŒçœŸé˜¶æ®µï¼ˆå‰ 50%ï¼‰")
            _run_report(csv_files[mid:], "éªŒçœŸé˜¶æ®µï¼ˆå 50%ï¼‰")
        else:
            _run_report(csv_files, "ä¼˜åŒ–é˜¶æ®µï¼ˆå…¨é‡ï¼‰")
        
    except GuardViolation as gv:
        _print_single_screen_error(gv)
        sys.exit(getattr(gv, 'exit_code', 2))
    except (AssertionError, ValueError, KeyError, TypeError) as e:
        gv = _as_guard_from_exception(e)
        _print_single_screen_error(gv)
        sys.exit(getattr(gv, 'exit_code', 2))
    except Exception as e:
        gv = _as_guard_from_exception(e)
        _print_single_screen_error(gv)
        sys.exit(getattr(gv, 'exit_code', 2))


# =========================
# è½»é‡è‡ªå®¡ï¼ˆä»…ç”¨äºâ€œå‡€å€¼è½¬æ­£â€æç¤ºï¼›ä¸æ›¿ä»£ AUDIT_RUN=1 ä¸¥æ ¼å®¡æŸ¥ï¼‰
# ç›®æ ‡ï¼šä¸ä¸­æ–­ä¼˜åŒ–æµç¨‹ï¼›ä»…æç¤ºå…³é”®é£é™©ï¼›ä¸¥ç¦é€’å½’è‡ªå®¡
# =========================
AUTO_SELF_AUDIT_ON_POSITIVE = True   # å‡€å€¼>0 æ—¶è§¦å‘ä¸€æ¬¡â€œè½»é‡è‡ªå®¡æç¤ºâ€
IN_SELF_AUDIT = False               # é˜²é‡å…¥

def _get_total_pnl_for_self_audit():
    """
    å…¼å®¹ä¸åŒæ¨¡æ¿å˜é‡åï¼šå°½é‡è¯»å–â€œæ€»å‡€å€¼/æ€»åˆ©æ¶¦â€ã€‚
    æ‰¾ä¸åˆ°åˆ™è¿”å› Noneï¼ˆä¸è§¦å‘è‡ªå®¡ï¼‰ã€‚
    """
    for k in ("TOTAL_PNL", "total_pnl", "TOTAL_PROFIT", "total_profit", "profit_total", "NET_TOTAL", "net_total"):
        if k in globals():
            v = globals().get(k)
            try:
                return float(v)
            except Exception:
                return None
    return None

def _self_audit_light():
    """
    è½»é‡è‡ªå®¡ï¼š
    - åªåšâ€œå¿…é¡»ç«‹å³ä¸­æ–­â€çš„è‡´å‘½é¡¹ + è‹¥å¹²æç¤ºé¡¹
    - é»˜è®¤ä¸å½±å“ä¸»æµç¨‹ï¼ˆé™¤éè‡´å‘½é¡¹è¢«è§¦å‘ï¼‰
    """
    # è‡´å‘½é¡¹ï¼šç¦ä¸‹æ³¨åŒºå‡ºç°çœŸå®è½æ³¨ï¼ˆå¿…é¡»ä¸­æ–­ï¼Œé¿å…ç»“æœä¸å¯ç”¨ï¼‰
    bet_forbidden = globals().get("BET_IN_FORBIDDEN_SEEN", 0)
    try:
        bet_forbidden = int(bet_forbidden)
    except Exception:
        bet_forbidden = 0

    if bet_forbidden > 0:
        raise RuntimeError(f"BET_IN_FORBIDDEN_SEEN>0ï¼ˆ={bet_forbidden}ï¼‰â€”â€”ç¦ä¸‹æ³¨åŒºå‘ç”ŸçœŸå®è½æ³¨ï¼Œç»“æœä½œåºŸ")

    # æç¤ºé¡¹ï¼šåªåšâ€œå­˜åœ¨æ€§â€æç¤ºï¼Œä¸åšä¸¥æ ¼å£å¾„åˆ¤æ­»
    hints = []
    if globals().get("STRUCT_SCAN", None) is not None and (globals().get("STRUCT_SCAN") is False):
        hints.append("STRUCT_SCAN=OFF")
    if globals().get("BOOT_FILTER", None) is not None and (globals().get("BOOT_FILTER") is False):
        hints.append("BOOT_FILTER=OFF")

    # æ’ç­‰å¼é—­ç¯æç¤ºï¼ˆè‹¥å­˜åœ¨è¿™äº›è®¡æ•°å™¨æ‰æ£€æŸ¥ï¼‰
    entry = globals().get("total_entry", None)
    match = globals().get("total_match", None)
    mismatch = globals().get("total_mismatch", None)
    exhaustion = globals().get("total_exhaustion", None)
    stop = globals().get("total_stop", None)
    zero = globals().get("total_zero", None)

    try:
        if entry is not None:
            entry_i = int(entry)
            parts = []
            for v in (match, mismatch, exhaustion, stop, zero):
                if v is not None:
                    parts.append(int(v))
            if parts:
                if entry_i != sum(parts):
                    hints.append("æ’ç­‰å¼ä¸é—­ç¯ï¼ˆEntryâ‰ åˆ†æ”¯æ€»å’Œï¼‰")
    except Exception:
        # è½»é‡è‡ªå®¡ä¸å› è§£æå¤±è´¥æ‰“æ–­
        pass

    # è¾“å‡ºï¼šä¸€è¡Œæç¤ºï¼Œä¸åˆ·å±
    if hints:
        print("ã€è½»é‡è‡ªå®¡ã€‘âš ï¸ æç¤ºï¼š", " / ".join(hints))
    else:
        print("ã€è½»é‡è‡ªå®¡ã€‘âœ… é€šè¿‡ï¼ˆè½»é‡ï¼‰")

def _auto_self_audit_after_run():
    """
    ä»…åœ¨â€œéä¸¥æ ¼å®¡æŸ¥è·‘â€ä¸”å‡€å€¼>0 æ—¶è§¦å‘ä¸€æ¬¡è½»é‡è‡ªå®¡æç¤ºã€‚
    """
    global IN_SELF_AUDIT
    if IN_SELF_AUDIT:
        return
    if globals().get("AUDIT_RUN", 0) == 1:
        return
    if not globals().get("AUTO_SELF_AUDIT_ON_POSITIVE", False):
        return

    pnl = _get_total_pnl_for_self_audit()
    if pnl is None:
        return
    if pnl <= 0:
        return

    IN_SELF_AUDIT = True
    try:
        _self_audit_light()
    finally:
        IN_SELF_AUDIT = False

if __name__ == "__main__":
    main()
    _auto_self_audit_after_run()