# ã€ç‰ˆæœ¬æ°´å°ï¼ˆäº¤ä»˜éªŒæ”¶ç”¨ï½œé”æ­»ï¼‰ã€‘
# æ°´å°ï¼šğŸ°ğŸ°ğŸ°
# -*- coding: utf-8 -*-
import csv
import os

SCAN_MODE_LOCKED = "ä¸€æ¬¡æ€§æ‰«æ"  # æ‰«ææ–¹å¼é”æ­»ï¼šä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“ [cite: 12]
MONITOR_ENABLE = 1  # ç›‘æµ‹å¼€å…³ï¼š0=å…³ï¼›1=å¼€ï¼ˆç”¨äºåŠ¨æ€ç›‘æµ‹/åŠ¨æ€æ­¢æŸï¼‰ [cite: 12]
# å¤šæ¬¡å†³ç­–ï¼ˆåŠ¨æ€ç›‘æµ‹/åŠ¨æ€æ­¢æŸï½œé”æ­»ï¼‰ï¼šåŒä¸€ç¬”äº¤æ˜“å†…ï¼Œæ¯ä¸€æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘å…è®¸åšä¸€æ¬¡â€œç»§ç»­/STOPâ€å†³å®šï¼› [cite: 12]
# å†³ç­–æ—¶åˆ»è§†ä¸ºä¸€æ¬¡â€œæŠ•æ”¾ç‚¹â€ï¼Œåªå…è®¸è¯»å–è¯¥è¡ŒåŠå†å²æŒ‡æ ‡ï¼›ä¸¥ç¦ä½¿ç”¨è¯¥å†³ç­–å£ä¹‹åï¼ˆt+1åŠä»¥åï¼‰çš„ä»»ä½•ä¿¡æ¯ã€‚ [cite: 12]
VERIFY_SPLIT_ENABLE = 0  # éªŒçœŸåˆ†æ‹†å¼€å…³ï¼š0=å…³ï¼›1=å¼€ï¼ˆæŒ‰æ–‡ä»¶åæ’åºå‰50%/å50%åˆ†åˆ«è·‘ï¼‰ [cite: 12]

# ==========================
# æ®µé•¿ä¸è‡ªåœï¼ˆé”æ­»ï½œä»æ‰¹æ¬¡é¦–å¼€å§‹ï¼‰ [cite: 12]
# ==========================
def _is_bp(r):
    return r in ("B", "P") [cite: 12]

def _update_run(run_side, run_len, r):
    # çŠ¶æ€ T ä½ç§»é›¶åå·®ï¼šrun_side/run_len ä¸å˜ [cite: 13]
    if r == "T":
        return run_side, run_len [cite: 13]
    if not _is_bp(r):
        return run_side, run_len [cite: 13]
    if run_side is None or r != run_side:
        return r, 1 [cite: 13]
    return run_side, run_len + 1 [cite: 13]

def _compute_max_runs_first9(records):
    # åªçœ‹å‰ 9 å£ï¼ˆseen_all=1..9ï¼ŒçŠ¶æ€ B/P/T éƒ½ç®—ä½ç§»å£æ•°ï¼‰ [cite: 14]
    seen_all = 0 [cite: 14]
    run_side = None [cite: 14]
    run_len = 0 [cite: 14]
    max_run = {"B": 0, "P": 0} [cite: 14]
    for rec in records:
        seen_all += 1 [cite: 14]
        run_side, run_len = _update_run(run_side, run_len, rec["r"]) [cite: 14]
        if run_side in ("B","P"):
            if run_len > max_run[run_side]:
                max_run[run_side] = run_len [cite: 14]
        if seen_all >= 9:
            break [cite: 14]
    return max_run["B"], max_run["P"], seen_all [cite: 14]

def _self_stop_tracker_init():
    return {"run_side": None, "run_len": 0, "seen_b3": False, "seen_p3": False} [cite: 14]

def _self_stop_tracker_step(st, r):
    st["run_side"], st["run_len"] = _update_run(st["run_side"], st["run_len"], r) [cite: 15]
    if st["run_side"] == "B" and st["run_len"] >= 3:
        st["seen_b3"] = True [cite: 15]
    if st["run_side"] == "P" and st["run_len"] >= 3:
        st["seen_p3"] = True [cite: 15]
    return st [cite: 15]

def _should_self_stop(st):
    # ä¸¤è¾¹éƒ½æ›¾å‡ºç°æ®µé•¿â‰¥3 â†’ è‡ªåœ [cite: 15]
    return st["seen_b3"] and st["seen_p3"] [cite: 15]
from collections import defaultdict

# ==========================
# è¿ç»­ç»Ÿè®¡ï¼ˆäºŒæŒ‡æ ‡äºŒè¿å˜åŒ–ï½œé”æ­»ï¼‰ [cite: 15]
# ==========================
# ç›®æ ‡ï¼šåœ¨â€œå•æŒ‡æ ‡æ— è§„å¾‹â€çš„å‰æä¸‹ï¼Œåªè§‚å¯Ÿâ€œäºŒæŒ‡æ ‡äºŒè¿å˜åŒ–â€çš„åˆ†å¸ƒï¼Œç”¨äº STOP å€™é€‰ç­›é€‰ï¼› [cite: 15]
# çº¦æŸï¼šè¿ç»­ç»Ÿè®¡åªèƒ½åŸºäºâ€œæŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨â€åšäº‹åæ±‡æ€»ï¼›å†³ç­–é€»è¾‘ä»å¿…é¡»æ»¡è¶³â€œå†³ç­–å£åŸºå‡†ï¼ˆé›¶æœªæ¥ï¼‰â€ã€‚ [cite: 15]
#
# å¿«ç…§å£å¾„ï¼ˆé”æ­»ï½œå£å¾„ Bï¼‰ï¼šæ¯æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘è®°å½•ä¸€æ¬¡å¿«ç…§ï¼ˆå«çŠ¶æ€ T åçš„é‡å¤æŠ•æ”¾ï¼‰ï¼Œå¿«ç…§æ¥è‡ªâ€œæŠ•æ”¾ç‚¹å½“è¡Œâ€åŸå§‹æŒ‡æ ‡ã€‚ [cite: 15]
# è¿ç»­é•¿åº¦ï¼ˆé”æ­»ï¼‰ï¼šäºŒè¿ï¼ˆä¸Šä¸€æ¬¡â†’è¿™ä¸€æ¬¡ï¼‰ã€‚ [cite: 15]
#
# å¿«ç…§å­—æ®µï¼ˆå»ºè®®ç­–ç•¥è¿”å› snapshots åˆ—è¡¨ï¼Œæ¯æ¡è‡³å°‘åŒ…å«ï¼‰ï¼š [cite: 15]
#   - bet_n: ç¬¬å‡ æ¬¡å®é™…æŠ•æ”¾ï¼ˆä» 1 å¼€å§‹ï¼›å«çŠ¶æ€ T é‡å¤æŠ•æ”¾ä¼šå¯¼è‡´ bet_n > 4ï¼‰ [cite: 15]
#   - diff: ç‚¹å·®ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰ [cite: 15]
#   - rate: å˜åŒ–ç‡ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰ [cite: 15]
#   - mean: å‡å·®ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰ [cite: 15]
#   - trade_bust: æœ¬ç¬”äº¤æ˜“æœ€ç»ˆæ˜¯å¦é˜ˆå€¼å‡»ç©¿ï¼ˆ0/1ï¼Œç”¨äºè®¡ç®—â€œåç»­é˜ˆå€¼å‡»ç©¿ç‡â€ï¼‰ [cite: 15]
#
# è¾“å‡ºï¼ˆé”æ­»ï½œAI å‹å¥½ï¼‰ï¼š [cite: 15]
#   A) (|ç‚¹å·®|æ¡¶, rate ç›‘æµ‹æ¡¶) çš„äºŒè¿è½¬ç§»æ¦œï¼šS_{t-1}â†’S_tï¼ˆTopKï¼‰ [cite: 15]
#   B) (|ç‚¹å·®|æ¡¶, mean æ¡¶) çš„äºŒè¿è½¬ç§»æ¦œï¼šS_{t-1}â†’S_tï¼ˆTopKï¼‰ [cite: 15]
#   æ¯æ¡è½¬ç§»è¾“å‡ºï¼šå‡ºç°æ¬¡æ•°ã€åç»­é˜ˆå€¼å‡»ç©¿æ•°ã€åç»­é˜ˆå€¼å‡»ç©¿ç‡ï¼ˆexhaustion / å‡ºç°æ¬¡æ•°ï¼‰ [cite: 15]
#   é»˜è®¤åªè¾“å‡ºâ€œæ ·æœ¬é‡ >= é˜ˆå€¼â€çš„è½¬ç§»ï¼Œé¿å…å™ªå£°ã€‚ [cite: 15]
CONT_STATS_ENABLE = 1 [cite: 15]
CONT_MAX_BET_N = 12 [cite: 15]
CONT_MIN_SAMPLES = 500 [cite: 15]
CONT_TOPK = 20 [cite: 15]

def _abs_diff_bucket(diff):
    try:
        d = abs(int(diff)) [cite: 16]
    except Exception:
        d = 0 [cite: 16]
    if d < 0:
        d = 0 [cite: 16]
    if d > 9:
        d = 9 [cite: 16]
    return d  # 0..9ï¼ˆè¾“å‡ºæ—¶é€šå¸¸åªå…³æ³¨ 1..9ï¼‰ [cite: 16]

# å˜åŒ–ç‡ï¼šæ¿€æ´»é˜ˆå€¼ï¼ˆä¸‰æ¡£ï½œé”æ­»ï¼‰ [cite: 17]
def _rate_entry_bucket(rate):
    if rate is None:
        return "æ— æ•ˆ" [cite: 17]
    try:
        r = float(rate) [cite: 17]
    except Exception:
        return "æ— æ•ˆ" [cite: 17]
    if r <= -3:
        return "<=-3" [cite: 17]
    if -3 < r <= -2:
        return "(-3,-2]" [cite: 17]
    if -2 < r < 0:
        return "(-2,0)" [cite: 17]
    return "å…¶ä»–" [cite: 17]

# å˜åŒ–ç‡ï¼šç›‘æµ‹é˜ˆå€¼ï¼ˆä¸‰æ¡£ï½œé”æ­»ï¼‰ [cite: 18]
def _rate_monitor_bucket(rate):
    if rate is None:
        return "æ— æ•ˆ" [cite: 18]
    try:
        r = float(rate) [cite: 18]
    except Exception:
        return "æ— æ•ˆ" [cite: 18]
    if r < 0:
        return "<0" [cite: 18]
    if 0 <= r < 2:
        return "[0,2)" [cite: 18]
    return ">=2" [cite: 18]

# å‡å·®ï¼šç›‘æµ‹åˆ†æ¡¶ï¼ˆä¸¤ç±» + 0 å•åˆ—ï½œé”æ­»ï¼‰ [cite: 19]
def _mean_bucket(mean):
    if mean is None:
        return "æ— æ•ˆ" [cite: 19]
    try:
        m = float(mean) [cite: 19]
    except Exception:
        return "æ— æ•ˆ" [cite: 19]
    if m == 0:
        return "0" [cite: 19]
    if abs(m) >= 3:
        return "|mean|>=3" [cite: 19]
    return "|mean|<3" [cite: 19]

def _mean_flip_valid(prev_mean, curr_mean):
    # æœ‰æ•ˆè½¬å‘ï¼ˆé”æ­»ï¼‰ï¼šç¬¦å·ç¿»è½¬ä¸”ä¸¤ä¾§ |mean|>=1 [cite: 20]
    if prev_mean is None or curr_mean is None:
        return False [cite: 20]
    try:
        a = float(prev_mean) [cite: 20]
        b = float(curr_mean) [cite: 20]
    except Exception:
        return False [cite: 20]
    if a == 0 or b == 0:
        return False [cite: 20]
    if abs(a) < 1 or abs(b) < 1:
        return False [cite: 20]
    return (a > 0 and b < 0) or (a < 0 and b > 0) [cite: 20]

def _init_cont_agg():
    return {
        "pair_rate": {},         # key: (bet_n, prev_state, curr_state) -> [cnt, exhaustion] [cite: 21]
        "pair_mean": {},         # key: (bet_n, prev_state, curr_state) -> [cnt, exhaustion] [cite: 21]
        "pair_rate_overall": {}, # key: (prev_state, curr_state) -> [cnt, exhaustion] [cite: 21]
        "pair_mean_overall": {}, # key: (prev_state, curr_state) -> [cnt, exhaustion] [cite: 21]
        "max_bet_n_seen": 0, [cite: 21]
    }

def _agg_add(d, key, bust_flag):
    if key not in d:
        d[key] = [0, 0] [cite: 22]
    d[key][0] += 1 [cite: 22]
    d[key][1] += int(1 if bust_flag else 0) [cite: 22]

def _cont_consume_snapshots(agg, snapshots):
    # snapshots: list of dicts with bet_n,diff,rate,mean,trade_exhaustion [cite: 23]
    if not snapshots:
        return [cite: 23]
    snaps = [x for x in snapshots if isinstance(x, dict) and "bet_n" in x] [cite: 23]
    snaps.sort(key=lambda x: int(x.get("bet_n", 0))) [cite: 23]
    if len(snaps) < 2:
        return [cite: 23]

    bust_flag = int(snaps[-1].get("trade_bust", 0)) [cite: 23]
    for i in range(1, len(snaps)):
        a = snaps[i-1] [cite: 23]
        b = snaps[i] [cite: 23]
        try:
            bn = int(b.get("bet_n", 0)) [cite: 23]
        except Exception:
            bn = 0 [cite: 23]
        if bn > agg["max_bet_n_seen"]:
            agg["max_bet_n_seen"] = bn [cite: 23]

        prev_rate = (_abs_diff_bucket(a.get("diff", 0)), _rate_monitor_bucket(a.get("rate"))) [cite: 24]
        curr_rate = (_abs_diff_bucket(b.get("diff", 0)), _rate_monitor_bucket(b.get("rate"))) [cite: 24]
        prev_mean = (_abs_diff_bucket(a.get("diff", 0)), _mean_bucket(a.get("mean"))) [cite: 24]
        curr_mean = (_abs_diff_bucket(b.get("diff", 0)), _mean_bucket(b.get("mean"))) [cite: 24]

        _agg_add(agg["pair_rate"], (bn, prev_rate, curr_rate), bust_flag) [cite: 24]
        _agg_add(agg["pair_mean"], (bn, prev_mean, curr_mean), bust_flag) [cite: 24]
        _agg_add(agg["pair_rate_overall"], (prev_rate, curr_rate), bust_flag) [cite: 24]
        _agg_add(agg["pair_mean_overall"], (prev_mean, curr_mean), bust_flag) [cite: 24]

def _print_top_transitions(title, d, min_samples, topk):
    rows = [] [cite: 25]
    for k, (cnt, bust) in d.items():
        if cnt < min_samples:
            continue [cite: 25]
        br = bust / cnt if cnt else 0.0 [cite: 25]
        rows.append((br, cnt, bust, k)) [cite: 25]
    rows.sort(reverse=True, key=lambda x: (x[0], x[1])) [cite: 25]
    print(title) [cite: 25]
    if not rows:
        print("ï¼ˆæ— è¾“å‡ºï¼šæ ·æœ¬é‡ä¸è¶³ï¼‰") [cite: 25]
        return [cite: 25]
    for i, (br, cnt, bust, k) in enumerate(rows[:topk], 1):
        print(f"{i:02d}. {k} | æ¬¡æ•°={cnt} | é˜ˆå€¼å‡»ç©¿={bust} | é˜ˆå€¼å‡»ç©¿ç‡={br:.4f}") [cite: 26]


# ============================================================
# ç»Ÿä¸€ä»£ç æ¨¡æ¿ï¼ˆV4ï¼Œåºåˆ—é•¿åº¦å£å¾„ï½œä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“ï¼‰
# çº¦æŸï¼š
# 1) åªè¯»å–å½“å‰ç›®å½•ä¸‹æ‰€æœ‰ .csv
# 2) ä¸å†™æ­»ä»»ä½•ç»å¯¹è·¯å¾„
# 3) è‡ªåŠ¨è¯†åˆ«æ‰¹æ¬¡åˆ—/ç»“æœ/ç‚¹å·®/å˜åŒ–ç‡/å‡å·®
# 4) ç»“æœå¿…é¡»æ˜ å°„ä¸º B/P/T
# 5) ä¸¥æ ¼é›¶æœªæ¥ï¼šrun_strategy_on_boot å†…ä¸¥ç¦è®¿é—®æœªæ¥è¡Œ
# 6) â€œä¸‹ä¸€å£/ä¸‹ä¸€è¡Œâ€ç»Ÿä¸€å®šä¹‰ï¼šidx+1ï¼ˆä¸è·³è¿‡çŠ¶æ€ T ä½ç§»é›¶åå·®ï¼‰
# 7) å•è¾¹/åŒè¾¹ï¼šå‰ 9 å£åˆ†ç±»ï¼›å•è¾¹å¼±ç´¯è®¡ >=3 è½¬åŒè¾¹ï¼›äº¤æ˜“æ¬¡æ•°é™åˆ¶è§æ¨¡æ¿æ–‡æ¡£
#
# æ³¨æ„ï¼šæœªæ¥æ–°å¢/ä¿®æ”¹ç­–ç•¥ï¼Œåªæ”¹ run_strategy_on_boot(records) å†…éƒ¨é€»è¾‘
# ============================================================

# ============================================================
# ç»“æœæ˜ å°„è¡¨ï¼šå·²å®Œæˆ BPT å…¨é˜¶è„±æ•ï¼Œç‰©ç†åŒ¹é…å®éªŒå®¤æ ‡å‡†åŒ– CSV
# ============================================================
MAP_RESULT = {"B": "B", "P": "P", "T": "T"}

# ------------------------------------------------------------
# å·¥å…·ï¼šå®‰å…¨è¯»å– float / intï¼ˆåªè¯»ï¼Œä¸è®¡ç®—ï¼‰
# ------------------------------------------------------------
def safe_float(v, default=None):
    try:
        if v is None or v == "":
            return default
        return float(v)
    except Exception:
        return default

def safe_int(v, default=0):
    try:
        if v is None or v == "":
            return default
        return int(float(v))
    except Exception:
        return default

# ------------------------------------------------------------
# 1) æ•°æ®åŠ è½½ï¼ˆå›ºå®šï¼‰
# ------------------------------------------------------------
# ------------------------------------------------------------
# 0) åˆ—è¯†åˆ«ä¸æ˜ å°„ï¼ˆå›ºå®šï½œåªè¯»ï¼‰
# ------------------------------------------------------------
def detect_columns(sample_row):
    keys = list(sample_row.keys())
    def pick(cands):
        # 1:1 ç‰©ç†åŒ¹é… 
        for c in cands:
            if c in sample_row: return c
        # æ¨¡ç³ŠåŒ¹é… 
        for k in keys:
            for c in cands:
                if c.lower() in k.lower(): return k
        return None

# --- é”å®šæ‚¨çš„ç‰©ç†è¡¨å¤´ï¼ˆä»¥å£å¾„æ¨¡æ¿ä¸ºå”¯ä¸€çœŸæºï¼‰ ---
col_shoe   = pick(["Batch", "æ‰¹æ¬¡", "å…¨å±€æ‰¹æ¬¡å·", "shoe", "é´å·", "é´"])
col_result = pick(["Exhaustion", "ç»“æœ", "Result", "r", "åŒ¹é…é¡¹", "res"])
col_diff   = pick(["ç‚¹å·®", "diff"])
col_rate   = pick(["å˜åŒ–ç‡", "rate"])
col_mean   = pick(["å‡å·®", "mean"])

# ------------------------------------------------------------
# 2) æ‰¹æ¬¡çº§è¿‡æ»¤ï¼ˆåºåˆ—é•¿åº¦å£å¾„ï½œé”æ­»ï¼‰
# ------------------------------------------------------------
def boot_filter(records):
    b_run, p_run, seen_all = _compute_max_runs_first9(records)
    if seen_all < 9:
        return False
    if b_run >= 3 and p_run >= 3:
        return False
    return True



# ------------------------------------------------------------
# 3) å•æ‰¹æ¬¡ç­–ç•¥å…¥å£ï¼ˆåªå…è®¸æ”¹è¿™é‡Œï¼‰
# ------------------------------------------------------------
def run_strategy_on_boot(records):
    # 1. ç‰©ç†æ§½ä½åˆå§‹åŒ– 
    snapshots = []  # å­˜æ”¾â€œå®é™…æŠ•æ”¾å‰â€çš„å¿«ç…§åˆ—è¡¨
    entry, match, mismatch, exhaustion = 0, 0, 0, 0
    profit = 0.0

    # 2. ç­–ç•¥é€»è¾‘å¾ªç¯
    for idx, r in enumerate(records):
        # --- Aå±‚ï¼šç»“æ„æ¿€æ´» (DNAæ£€æµ‹) ---
        # [æ­¤å¤„ç”±ç­–ç•¥ç¡®å®šç»“æ„ï¼Œä¾‹å¦‚ï¼šä¸»è½´ >= 3]
        # --- Aå±‚ï¼šç»“æ„æ¿€æ´» (DNAæ£€æµ‹) ---
        # å¼ºåˆ¶é”æ­»ï¼šæ¿€æ´»å¿…é¡»æ»¡è¶³â€œè¾…è½´é•¿åº¦ == 1â€ (W1) ä¸”ç¬¦åˆ DNA ç»“æ„ 
        is_structure_active = (current_w_len == 1 and other_dna_conditions)

        if is_structure_active:
            # --- Bå±‚ï¼šç¥è°•å®¡è®¡ (Oracle Audit) ---
            # ç‰©ç†èŒèƒ½ï¼šä»…å¯¹å·²æ¿€æ´»çš„ç»“æ„æ‰§è¡Œâ€œé€šè¿‡/ä¸é€šè¿‡â€åˆ¤å®š
            # ä¸¥ç¦åœ¨æ­¤ç”Ÿæˆä»»ä½•ä¸‹æ³¨ä¿¡å·ã€‚
            is_oracle_pass = True # [æ­¤å¤„ç”±ç­–ç•¥è°ƒç”¨ å¤–éƒ¨å‚æ•° å‚æ•°è¿›è¡Œå®¡è®¡]

            if not is_oracle_pass:
                # å®¡è®¡ä¸é€šè¿‡ï¼šæ”¾å¼ƒæœ¬æ¬¡æ‰§è¡Œï¼Œç¨‹åºå¿…é¡»ç»§ç»­å‘åæ‰«æ
                continue

# --- Cå±‚ï¼šæ‰§è¡Œä¸è´Ÿå‘é˜»æ–­ (Negative Interception) ---
            entry += 1
            units = [1, 2, 4, 8] 
            is_settled = False 

            for b_idx, u in enumerate(units):
                # 1. ç‰©ç†æ­¥è¿›ï¼šä¸¥ç¦ä½¿ç”¨ records[idx:idx+4] åˆ‡ç‰‡ (éš”ç»æœªæ¥å‡½æ•°)
                # æ¯ä¸€ä¸ª b_idx å¯¹åº”æ—¶é—´è½´ä¸Šçš„ä¸€æ¬¡çœŸå®å‰è¡Œ
                current_exec_row = records[idx + b_idx] 
                
                # 2. ç‰©ç†å¿«ç…§ï¼šè®°å½•è¯¥å±‚çº§çš„çœŸå®æ•°æ® [cite: 26, 27]
                # å½’å› é”å®šï¼šsnapshots çš„ idx å§‹ç»ˆæŒ‡å‘æ¿€æ´»æ—¶åˆ»çš„è¡Œå·
                snap = {
                    'bet_n': b_idx + 1, 
                    'idx': idx, 
                    'diff': current_exec_row['diff'], 
                    'rate': current_exec_row['rate'], 
                    'mean': current_exec_row['mean']
                }
                snapshots.append(snap) # [cite: 30]

                # 3. åŠ¨æ€ç»“ç®—ï¼šé€è¡Œè¯»å–å½“å‰è¡Œçš„ç‰©ç†ç»“æœ [cite: 33, 34]
                if current_exec_row['r'] == target_side: 
                    match += 1
                    profit += (u * 0.95) # å‡è®¾èµ”ç‡
                    is_settled = True
                    break # ç‰©ç†æ–­æµï¼šä¸€æ—¦ Match ç«‹å³åœæ­¢ï¼Œä¸çœ‹æœªæ¥ç»“æœ

            # 4. æ±‡æ€»åˆ¤å®šï¼šå…¨åºåˆ—æœªåŒ¹é…
            if not is_settled:
                mismatch += 1
                profit -= sum(units)

            # 5. ä¸€é´ä¸€å•å…ƒï¼šæ‰§è¡Œå®Œæ¯•ç«‹å³è·³å‡º Batch å¾ªç¯
            break
    return {
        "entry": entry,
        "match": match,
        "mismatch": mismatch,
        "exhaustion": exhaustion,
        "profit": profit,
        "snapshots": snapshots, # å¿…é¡»è¿”å›ï¼Œç”¨äº TopK å½’å› 
        "trade_bust": 1 if exhaustion > 0 else 0
    } [cite: 26, 32]

def load_all_boots(csv_files):
    boots = defaultdict(list)
    print("æ£€æµ‹åˆ° CSV æ–‡ä»¶æ•°é‡:", len(csv_files))

    for i, fname in enumerate(csv_files, 1):
        if i % 10 == 0:
            print(f"è¿›åº¦: å·²å¤„ç† {i}/{len(csv_files)} ä¸ªæ–‡ä»¶")

        rows = []
        for enc in ("utf-8", "utf-8-sig", "gbk", "gb18030"):
            try:
                with open(fname, "r", encoding=enc) as f:
                    rows = list(csv.DictReader(f))
                break
            except Exception:
                rows = []

        if not rows:
            continue

        col_shoe, col_result, col_diff, col_rate, col_mean = detect_columns(rows[0])

        for r in rows:
            shoe = r.get(col_shoe)
            if shoe is None:
                continue

            res_raw = r.get(col_result)
            res = map_result(res_raw)
            if res not in ("B", "P", "T"):
                continue

            diff = safe_int(r.get(col_diff, 0), 0)
            rate = safe_float(r.get(col_rate), None) if col_rate else None
            mean = safe_float(r.get(col_mean), None) if col_mean else None

            # è¡¥é½ç‰©ç†ç´¢å¼• idxï¼Œç¡®ä¿ snapshots èƒ½å¤Ÿç²¾å‡†å¯¹æ ‡åŸå§‹è¡Œå·
            boots[shoe].append({
                "idx": len(boots[shoe]), 
                "r": res, 
                "diff": diff, 
                "rate": rate, 
                "mean": mean
            }) [cite: 30]

    print("æŒ‰æ‰¹æ¬¡åˆ†ç»„å®Œæˆï¼Œæ‰¹æ¬¡æ€»æ•°:", len(boots))
    return boots


def _run_report(csv_files, title):
    boots = load_all_boots(csv_files)
    total_boots = len(boots)

    playable_boots = 0
    skipped_boots = 0

    total_entry = 0
    total_match = 0
    total_mismatch = 0
    total_exhaustion = 0
    total_profit = 0.0

    cont_agg = _init_cont_agg() if CONT_STATS_ENABLE else None

    for _, records in boots.items():
        if not boot_filter(records):
            skipped_boots += 1
            continue
        playable_boots += 1

        out = run_strategy_on_boot(records)

        total_entry += int(out.get("entry", 0))
        total_match += int(out.get("match", 0))
        total_mismatch += int(out.get("mismatch", 0))
        total_exhaustion += int(out.get("exhaustion", 0))
        total_profit += float(out.get("profit", 0.0))

        if cont_agg is not None:
            _cont_consume_snapshots(cont_agg, out.get("snapshots") or [])

    print()
    print("============================================================")
def _run_report(csv_files, title):
    boots = load_all_boots(csv_files)
    
    # ... ç»Ÿè®¡é€»è¾‘ ...

    print() 
    # ============================================================
    # ç‰©ç†å®šä½é”šç‚¹ï¼šäº¤ä»˜éªŒæ”¶æ°´å°ï¼ˆé”æ­»ï½œå”¯ä¸€æœç´¢å®šä½ï¼‰
    # ============================================================
    print("ğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°") 
    print("============================================================")
    print(title)
    # ...
    print(title)
    print("============================================================")
    print("æ‰«ææ–¹å¼ï¼šä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“")
    print("æ®µé•¿å£å¾„ï¼šç¦æ­¢è·¨æ®µç´¯è®¡")
    print("æœ¯è¯­é”æ­»ï¼šåªæ‰¿è®¤ã€Œâ­ / æŠ•æ”¾ç‚¹ã€")
    print(f"ç›‘æµ‹å¼€å…³ï¼š{'å¼€' if MONITOR_ENABLE else 'å…³'}")
    print("é˜ˆå€¼å‡»ç©¿å½’å› ï¼šè·¯å¾„å¿«ç…§ï¼ˆæ¯æ¬¡å®é™…æŠ•æ”¾å‰éƒ½å¿«ç…§ï¼›å«çŠ¶æ€ T åçš„é‡å¤æŠ•æ”¾ï¼›å½’å› åªç”¨å¿«ç…§ï¼‰")
    print("------------------------------------------------------------")
    print("æ€»æ‰¹æ¬¡æ•°    :", total_boots)
    print("å¯å‚ä¸æ‰¹æ¬¡æ•°:", playable_boots)
    print("è·³è¿‡æ‰¹æ¬¡æ•°  :", skipped_boots)
    print("------------------------------------------------------------")
    print("æ¿€æ´»æ¬¡æ•°    :", total_entry)
    print("åŒ¹é…æ¬¡æ•°    :", total_match)
    print("ä¸åŒ¹é…æ¬¡æ•°  :", total_mismatch)
    print("é˜ˆå€¼å‡»ç©¿æ¬¡æ•°:", total_exhaustion)
    if total_entry > 0:
        match_rate = total_match / total_entry * 100
        exhaustion_rate = total_exhaustion / total_entry * 100
        print(f"åŒ¹é…ç‡      : {match_rate:.4f}%")
        print(f"é˜ˆå€¼å‡»ç©¿ç‡  : {exhaustion_rate:.4f}%")
        print(f"å•æ¬¡å¹³å‡å¢ç›Š: {total_profit / total_entry:.6f}")
    print("æ€»å‡€å€¼å¢ç›Š  :", round(total_profit, 2))

    if cont_agg is not None:
        print()
        print("------------------------------------------------------------")
        print("è¿ç»­ç»Ÿè®¡ï¼ˆäºŒæŒ‡æ ‡äºŒè¿å˜åŒ–ï½œäº‹åæ±‡æ€»ï½œå­¦æœ¯ç‰ˆï¼‰")
        print("è¯´æ˜ï¼šä»…åŸºäºæŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨ï¼ˆå«çŠ¶æ€ T é‡å¤æŠ•æ”¾ï¼‰ï¼›æ ·æœ¬é‡ä¸è¶³ä¸è¾“å‡ºã€‚")
        print("é˜ˆå€¼ï¼šmin_samples=%dï½œTopK=%d" % (CONT_MIN_SAMPLES, CONT_TOPK))

        _print_top_transitions(
            "A) (|ç‚¹å·®|,rate ç›‘æµ‹æ¡¶) Overall Top",
            cont_agg["pair_rate_overall"],
            CONT_MIN_SAMPLES,
            CONT_TOPK,
        )
        _print_top_transitions(
            "B) (|ç‚¹å·®|,mean æ¡¶) Overall Top",
            cont_agg["pair_mean_overall"],
            CONT_MIN_SAMPLES,
            CONT_TOPK,
        )

        max_bn = min(int(cont_agg.get("max_bet_n_seen", 0) or 0), CONT_MAX_BET_N)
        for bn in range(2, max_bn + 1):
            tmp_rate = {}
            tmp_mean = {}
            for (bn2, a, b), v in cont_agg["pair_rate"].items():
                if bn2 == bn:
                    tmp_rate[(a, b)] = v
            for (bn2, a, b), v in cont_agg["pair_mean"].items():
                if bn2 == bn:
                    tmp_mean[(a, b)] = v
            _print_top_transitions(
                f"A) bet_n={bn} (|ç‚¹å·®|,rate ç›‘æµ‹æ¡¶) Top",
                tmp_rate,
                CONT_MIN_SAMPLES,
                min(10, CONT_TOPK),
            )
            _print_top_transitions(
                f"B) bet_n={bn} (|ç‚¹å·®|,mean æ¡¶) Top",
                tmp_mean,
                CONT_MIN_SAMPLES,
                min(10, CONT_TOPK),
            )

    print("============================================================")


def main():
    csv_files = sorted([f for f in os.listdir(".") if f.lower().endswith(".csv")])
    if VERIFY_SPLIT_ENABLE and len(csv_files) >= 2:
        mid = len(csv_files) // 2
        _run_report(csv_files[:mid], "éªŒçœŸé˜¶æ®µï¼ˆå‰ 50%ï¼‰")
        _run_report(csv_files[mid:], "éªŒçœŸé˜¶æ®µï¼ˆå 50%ï¼‰")
    else:
        _run_report(csv_files, "ä¼˜åŒ–é˜¶æ®µï¼ˆå…¨é‡ï¼‰")


if __name__ == "__main__":
    main()