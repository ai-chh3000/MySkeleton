# ã€ç‰ˆæœ¬æ°´å°ï¼ˆäº¤ä»˜éªŒæ”¶ç”¨ï½œé”æ­»ï¼‰ã€‘
# æ°´å°ï¼šğŸ°ğŸ°ğŸ°
# -*- coding: utf-8 -*-
import csv
import os
import inspect
import hashlib
import re

# è¡¨å¤´è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡
_HEADER_MAPPING_PRINTED = False

# ==========================
# å…¨å±€å¼€å…³ï¼ˆå¿…é¡»æ˜¾å¼å®šä¹‰ï½œé¿å… NameErrorï¼‰
# ==========================
# ç›‘æµ‹å¼€å…³ï¼š0=å…³ï¼Œ1=å¼€ï¼ˆé»˜è®¤å…³ï¼›ä»…å½±å“â€œç›‘æµ‹/é›·è¾¾â€è¾“å‡ºï¼Œä¸å¾—å½±å“é›¶æœªæ¥ä¸ä¸‹æ³¨è·¯å¾„ï¼‰
MONITOR_ENABLE = 0

# éªŒè¯åˆ†æ‹†å¼€å…³ï¼š0=å…³ï¼Œ1=å¼€ï¼ˆé»˜è®¤å…³ï¼›è‹¥å¼€å¯ï¼Œå¿…é¡»ä»æ»¡è¶³é›¶æœªæ¥ä¸ä¸€æ¬¡æ€§æ‰«æçº¦æŸï¼‰
VERIFY_SPLIT_ENABLE = 0


# é´çº§å¼€å…³ï¼ˆé”æ­»ï¼‰ï¼šä»…é™åˆ¶â€œå®é™…è½æ³¨â€æ˜¯å¦å…è®¸å‘ç”Ÿåœ¨å‰8å£ï¼ˆseen_all=1..8ï¼‰
# BOOT_FILTER=ONâœ…ï¼šç¦ä¸‹æ³¨ seen_all=1..8ï¼›ç¬¬9å£èµ·å…è®¸
# BOOT_FILTER=OFFâ›”ï¼šé´é¦–å…è®¸ä¸‹æ³¨
BOOT_FILTER = 1  # 1=ONâœ…ï¼Œ0=OFFâ›”
BOOT_FILTER_TEXT = "BOOT_FILTER=ONâœ…(ç¦ä¸‹æ³¨ seen_all=1..8)" if BOOT_FILTER else "BOOT_FILTER=OFFâ›”(é´é¦–å…è®¸ä¸‹æ³¨)"
# ============================================================
# ç»“æ„æ‰«æå¼€å…³ï¼ˆç»“æ„é—¸é—¨ï½œé”æ­»ï¼‰
# ============================================================
STRUCT_SCAN = 1  # 1=ONâœ…ï¼Œ0=OFFâ›”ï¼ˆä»…è‡ªè¯ç”¨ï¼ŒOFFæ—¶ç¦æ­¢ä»»ä½•ç­–ç•¥æ‰§è¡Œï¼‰
STRUCT_SCAN_TEXT = "STRUCT_SCAN=ONâœ…(ç»“æ„æ‰«æå¼€å¯)" if STRUCT_SCAN else "STRUCT_SCAN=OFFâ›”(ç»“æ„æ‰«æå…³é—­-ä»…è‡ªè¯)"
# ============================================================
# ç»“æ„æ’æ§½åŒºï¼ˆç‰ˆæœ¬Aï½œå”¯ä¸€å…è®¸å‡ºç°ç»“æ„é€»è¾‘çš„åŒºåŸŸï½œé”æ­»ï¼‰
# - åç»­æ›´æ¢ç»“æ„ï¼šåªå…è®¸æ›¿æ¢ã€Œç»“æ„æ’æ§½åŒºå¼€å§‹/ç»“æŸã€ä¸¤è¡Œä¹‹é—´çš„å†…å®¹
# - å…¶ä½™ä»»ä½•ä½ç½®å‡ºç°ç»“æ„åˆ¤æ–­/ç»“æ„å‡½æ•°è§†ä¸ºæ±¡æŸ“ï¼ˆè‡ªæ£€ä¼šæ‹¦æˆªï¼‰
# ============================================================
# [STRUCT_SLOT_BEGIN]
STRUCT_SUMMARY_LINE = "ç»“æ„æ‘˜è¦ï¼šSâ‰¥3â†’W1-2â†’Sâ­ï¼ˆæ‰“Sï¼‰"
def scan_structure(records):
    """ç»“æ„æ‰«æï¼ˆç¤ºä¾‹ï¼šQ1ç»“æ„ï¼‰
    ç»“æ„ï¼šä¸»å¯¼è½´ç´¯è®¡â‰¥3 â†’ è¾…è½´ç´¯è®¡1~2 â†’ ä¸»å¯¼è½´â­ï¼ˆâ­å£=æŠ•æ”¾ç‚¹ï¼‰
    å£å¾„è¦ç‚¹ï¼š
    - ä»…BPå‚ä¸ç´¯è®¡ï¼›T/ç‚¹å·®0ä¸æ‰“æ–­ã€ä¸å‚ä¸ç´¯è®¡ï¼›ä¸”ç¦æ­¢è·¨æ®µç´¯è®¡
    - â­å¿…é¡»æ»¡è¶³ï¼šç»“æœä¸ºB/P ä¸” ç‚¹å·®é0ï¼ˆå¦åˆ™STRUCT_ERRORï¼‰
    - BOOT_FILTER=ONâœ…æ—¶ï¼šè‹¥â­è½åœ¨seen_all=1..8ï¼Œç¦æ­¢æŠ•æ”¾ï¼Œä½†å¿…é¡»ç»§ç»­æ‰«æç›´åˆ°å‡ºç°å¯æŠ•æ”¾â­æˆ–STRUCT_FAIL
    è¿”å›ï¼š
      ("STRUCT_OK", star_idx, strong_side, info_dict)
      ("STRUCT_FAIL", None, None, info_dict)
    """
    info = {
        "forbidden_star_cnt": 0,
        "forbidden_star_first_seen": None,
        "fail_reason": None,  # MAIN_LT3 / WEAK_GT2 / NO_CANDIDATE / ONLY_FORBIDDEN
    }

    if not records:
        info["fail_reason"] = "NO_CANDIDATE"
        return "STRUCT_FAIL", None, None, info

    strong = None
    weak = None

    run_side = None
    run_len = 0

    state = "FIND_S"   # FIND_S / WAIT_W / IN_W
    w_len = 0

    def _is_bp_valid(rec):
        rr = rec.get("r")
        if rr not in ("B", "P"):
            return False
        d = rec.get("diff")
        if d is None:
            return False
        try:
            if int(d) == 0:
                return False
        except Exception:
            return False
        return True

    for rec in records:
        if not _is_bp_valid(rec):
            continue

        rr = rec.get("r")

        if run_side is None:
            run_side = rr
            run_len = 1
        elif rr == run_side:
            run_len += 1
        else:
            run_side = rr
            run_len = 1

        if state == "FIND_S":
            if run_len >= 3:
                strong = run_side
                weak = "P" if strong == "B" else "B"
                state = "WAIT_W"
                w_len = 0
            continue

        if state == "WAIT_W":
            if rr == weak:
                state = "IN_W"
                w_len = 1
            continue

        if state == "IN_W":
            if rr == weak:
                w_len += 1
                if w_len >= 3:
                    info["fail_reason"] = "WEAK_GT2"
                    return "STRUCT_FAIL", None, None, info
                continue

            star_idx = rec.get("idx")
            star_seen = rec.get("seen_all")

            # â­åˆæ³•æ€§ï¼šå¿…é¡»ä¸ºBPä¸”ç‚¹å·®é0ï¼ˆå¦åˆ™STRUCT_ERRORï¼‰
            if rec.get("r") not in ("B", "P"):
                print("âŒâŒâŒ STRUCT_ERRORï¼šâ­è½åœ¨T | æ–‡ä»¶|Sub-Batch|idx|seen|r|diff =", _CTX_FILE, _CTX_SUBBATCH, star_idx, star_seen, rec.get("r"), rec.get("diff"))
                raise RuntimeError("STRUCT_ERRORï¼šâ­è½åœ¨T")
            try:
                if int(rec.get("diff")) == 0:
                    print("âŒâŒâŒ STRUCT_ERRORï¼šâ­ç‚¹å·®=0 | æ–‡ä»¶|Sub-Batch|idx|seen|r|diff =", _CTX_FILE, _CTX_SUBBATCH, star_idx, star_seen, rec.get("r"), rec.get("diff"))
                    raise RuntimeError("STRUCT_ERRORï¼šâ­ç‚¹å·®=0")
            except Exception:
                print("âŒâŒâŒ STRUCT_ERRORï¼šâ­ç‚¹å·®æ— æ³•è§£æ | æ–‡ä»¶|Sub-Batch|idx|seen|r|diff =", _CTX_FILE, _CTX_SUBBATCH, star_idx, star_seen, rec.get("r"), rec.get("diff"))
                raise RuntimeError("STRUCT_ERRORï¼šâ­ç‚¹å·®æ— æ³•è§£æ")

            if BOOT_FILTER and (star_seen is not None):
                try:
                    if 1 <= int(star_seen) <= 8:
                        info["forbidden_star_cnt"] += 1
                        if info["forbidden_star_first_seen"] is None:
                            info["forbidden_star_first_seen"] = int(star_seen)

                        # ç¦æŠ•æ”¾ï¼šç»§ç»­æ‰«æä¸‹ä¸€ä¸ªâ­
                        state = "WAIT_W"
                        w_len = 0
                        run_side = strong
                        run_len = 1
                        continue
                except Exception:
                    pass

            return "STRUCT_OK", int(star_idx), strong, info

    if strong is None:
        info["fail_reason"] = "MAIN_LT3"
    else:
        if info["forbidden_star_cnt"] > 0:
            info["fail_reason"] = "ONLY_FORBIDDEN"
        else:
            info["fail_reason"] = "NO_CANDIDATE"
    return "STRUCT_FAIL", None, None, info
# [STRUCT_SLOT_END]
STRUCT_DEF_HASH = hashlib.md5(STRUCT_SUMMARY_LINE.encode("utf-8")).hexdigest()[:8]
_STRUCT_SUMMARY_PRINTED = False


# ä¸Šä¸‹æ–‡ï¼ˆç”¨äºæœ€å°æº¯æºæ‰“å°ï¼‰
_CTX_FILE = ""
_CTX_SUBBATCH = ""


def _audit_forbid_idx_offset():
    """
    å®‰å…¨è‡ªæ£€ï¼ˆé”æ­»ï½œæ‰§è¡Œ/ç»“ç®—æ®µï¼‰ï¼š
    - ç¦æ­¢ï¼šä»¥ idx ä¸ºåŸºå‡†ç›´æ¥æ¨å¯¼â€œæœªæ¥è¡Œå·â€ï¼ˆä¾‹å¦‚ï¼šidx ä¸åç§»é‡æ‹¼æ¥å¾—åˆ°æŸè¡Œï¼‰
    - ç¦æ­¢ï¼šåœ¨æ‰§è¡Œ/ç»“ç®—æ®µå›è¯» diff/rate/mean ä½œä¸ºåˆ¤æ–­ä¾æ®
    è¯´æ˜ï¼šåªå®¡è®¡ run_strategy_on_boot() å†…â€œç»“ç®—å¼€å§‹é”šç‚¹â€ä¹‹åçš„ä»£ç ï¼Œé¿å…è¯¯ä¼¤â€œæŠ•æ”¾å‰å¿«ç…§â€ã€‚
    """
    print("=== å®‰å…¨è‡ªæ£€å¼€å§‹ ===")

    # 1) æŠ½å–ç­–ç•¥æºç ï¼ˆæ— æ³•è¯»å–åˆ™è·³è¿‡ï¼Œä½†ä¸å½±å“è¿è¡Œï¼‰
    try:
        src = inspect.getsource(run_strategy_on_boot)
    except Exception:
        print("âš  è‡ªæ£€è·³è¿‡ï¼šæ— æ³•è¯»å– run_strategy_on_boot æºç ï¼ˆä¸å½±å“è¿è¡Œï¼‰")
        print("=== å®‰å…¨è‡ªæ£€å®Œæˆ ===")
        return

    # 2) åªå®¡è®¡â€œæ‰§è¡Œ/ç»“ç®—æ®µâ€ï¼šä»é”šç‚¹å¼€å§‹å¾€å
    anchor = "# 3) æœ¬æ¬¡æŠ•æ”¾çš„ç»“ç®—"
    pos = src.find(anchor)
    audit_src = src[pos:] if pos >= 0 else src

    # 3) ç¦æ­¢ç‰‡æ®µï¼ˆæ‰§è¡Œ/ç»“ç®—æ®µï¼‰
    # æ³¨æ„ï¼šä¸ºäº†é¿å…â€œè‡ªæ£€å­—ç¬¦ä¸²æœ¬èº«â€è§¦å‘æ›´ä¸Šå±‚çš„æºç é›·è¾¾ï¼Œæœ¬å¤„ç”¨æ‹¼æ¥ç”Ÿæˆæ¨¡å¼ä¸²ã€‚
    a = "idx"
    sp = " +"
    lbr = "records["
    forbidden = [
        # æœªæ¥è¡Œå·ç›´ç®—ï¼ˆç¦æ­¢ï¼‰
        a + sp + " step_idx", a + "+step_idx",
        a + sp + " b_idx", a + "+b_idx",
        lbr + a + sp, lbr + a + "+",

        # ç»“ç®—/æ‰§è¡Œé˜¶æ®µå°†æ¸¸æ ‡æŒ‡å‘ç»“ç®—è¡Œå¹¶å›è¯»æŒ‡æ ‡ï¼ˆç¦æ­¢ï¼‰
        "settle_idx", "last_bet_idx",
        "records[settle_idx]", "records[last_bet_idx]",
        "records [settle_idx]", "records [last_bet_idx]",

        # ç»•è·¯å†™æ³•ï¼ˆç¦æ­¢ï¼‰ï¼šåŒºé—´è¯»å–/åŒºé—´å¾ªç¯/è¡¨æ ¼å¼ç´¢å¼•
        lbr + a + ":", lbr + a + " :", "records[ " + a + ":", "records[ " + a + " :",
        lbr + a + "+1:", lbr + a + sp + " 1:", lbr + a + "+1:",
        "range(" + a, "range(" + a + sp, "range( " + a,
        "iloc[",
    ]

    hit = [s for s in forbidden if s in audit_src]

    if hit:
        print("âŒâŒâŒ ä¸é€šè¿‡: æ‰§è¡Œ/ç»“ç®—æ®µæ£€æµ‹åˆ°ç¦æ­¢ç‰‡æ®µ:", ",".join(hit))
        lines = audit_src.splitlines()
        shown = 0
        for i, line in enumerate(lines, 1):
            if any(h in line for h in hit):
                print(f"  HIT|Line {i}|{line.strip()}")
                shown += 1
                if shown >= 6:
                    break
        print("=== å®‰å…¨è‡ªæ£€å®Œæˆ ===")
        raise RuntimeError("æ‰§è¡Œ/ç»“ç®—æ®µå­˜åœ¨ç¦æ­¢ç‰‡æ®µ")

    print("âœ… å®‰å…¨è‡ªæ£€é€šè¿‡ï¼šæ‰§è¡Œ/ç»“ç®—æ®µæœªæ£€æµ‹åˆ°ç¦æ­¢ç‰‡æ®µã€‚")
    print("=== å®‰å…¨è‡ªæ£€å®Œæˆ ===")

def _audit_structure_slot_integrity():
    """
    ç»“æ„æ’æ§½å®Œæ•´æ€§è‡ªæ£€ï¼ˆé”æ­»ï¼‰ï¼š
    - ç»“æ„æ’æ§½æ ‡è®°è¡Œå¿…é¡»ä¸”åªèƒ½å„å‡ºç° 1 æ¬¡ï¼š# [STRUCT_SLOT_BEGIN] / # [STRUCT_SLOT_END]
    - å¿…é¡»ä¸”åªèƒ½æœ‰ 1 ä¸ª def scan_structure(records):ï¼Œä¸”ä½äºæ’æ§½åŒºå†…
    - STRUCT_SUMMARY_LINE åªèƒ½åœ¨æ’æ§½åŒºå†…å®šä¹‰ä¸€æ¬¡
    """
    try:
        src = open(__file__, 'r', encoding='utf-8').read()
    except Exception:
        # æŸäº›ç¯å¢ƒä¸‹ __file__ ä¸å¯ç”¨æ—¶ï¼Œæ”¾è¡Œï¼›ä½†è¿™ä¼šé™ä½å®¡æŸ¥å¼ºåº¦
        return

    begin_ms = list(re.finditer(r'(?m)^[ \t]*#\s*\[STRUCT_SLOT_BEGIN\]\s*$', src))
    end_ms = list(re.finditer(r'(?m)^[ \t]*#\s*\[STRUCT_SLOT_END\]\s*$', src))
    if len(begin_ms) != 1 or len(end_ms) != 1:
        raise RuntimeError('âŒ ç»“æ„æ’æ§½æ ‡è®°è¡Œå¿…é¡»ä¸”åªèƒ½å„å‡ºç° 1 æ¬¡ï¼š# [STRUCT_SLOT_BEGIN] / # [STRUCT_SLOT_END]')

    b = begin_ms[0].end()
    e = end_ms[0].start()
    if e <= b:
        raise RuntimeError('âŒ ç»“æ„æ’æ§½æ ‡è®°é¡ºåºé”™è¯¯ï¼šBEGIN å¿…é¡»åœ¨ END ä¹‹å‰')

    slot = src[b:e]

    # 1) scan_structureï¼šå…¨æ–‡ä»¶åªèƒ½å®šä¹‰ 1 æ¬¡ï¼Œä¸”å¿…é¡»ä½äºæ’æ§½åŒºå†…
    all_defs = list(re.finditer(r'(?m)^[ \t]*def\s+scan_structure\s*\(', src))
    slot_defs = list(re.finditer(r'(?m)^[ \t]*def\s+scan_structure\s*\(', slot))
    if len(all_defs) != 1 or len(slot_defs) != 1:
        raise RuntimeError('âŒ scan_structure å¿…é¡»ä¸”åªèƒ½å®šä¹‰ 1 æ¬¡ï¼Œå¹¶ä¸”å¿…é¡»ä½äºç»“æ„æ’æ§½åŒºå†…')

    # 2) STRUCT_SUMMARY_LINEï¼šåªèƒ½åœ¨æ’æ§½åŒºå†…å®šä¹‰ä¸€æ¬¡
    all_sum = list(re.finditer(r'(?m)^[ \t]*STRUCT_SUMMARY_LINE\s*=', src))
    slot_sum = list(re.finditer(r'(?m)^[ \t]*STRUCT_SUMMARY_LINE\s*=', slot))
    if len(all_sum) != 1 or len(slot_sum) != 1:
        raise RuntimeError('âŒ STRUCT_SUMMARY_LINE å¿…é¡»ä¸”åªèƒ½å®šä¹‰ 1 æ¬¡ï¼Œå¹¶ä¸”å¿…é¡»ä½äºç»“æ„æ’æ§½åŒºå†…')
def _boot_filter_label():
    return "BOOT_FILTER=ONâœ…(ç¦ä¸‹æ³¨ seen_all=1..8)" if BOOT_FILTER else "BOOT_FILTER=OFFâ›”(é´é¦–å…è®¸ä¸‹æ³¨)"


# ==========================
# æ®µé•¿ä¸è‡ªåœï¼ˆé”æ­»ï½œä»æ‰¹æ¬¡é¦–å¼€å§‹ï¼‰  # [cite: 12]
# ==========================
def _is_bp(r):
    return r in ("B", "P")  # [cite: 12]

def _update_run(run_side, run_len, r):
    # çŠ¶æ€ T ä½ç§»é›¶åå·®ï¼šrun_side/run_len ä¸å˜  # [cite: 13]
    if r == "T":
        return run_side, run_len  # [cite: 13]
    if not _is_bp(r):
        return run_side, run_len  # [cite: 13]
    if run_side is None or r != run_side:
        return r, 1  # [cite: 13]
    return run_side, run_len + 1  # [cite: 13]

def _compute_max_runs_first9(records):
    # åªçœ‹å‰ 9 å£ï¼ˆseen_all=1..9ï¼ŒçŠ¶æ€ B/P/T éƒ½ç®—ä½ç§»å£æ•°ï¼‰  # [cite: 14]
    seen_all = 0  # [cite: 14]
    run_side = None  # [cite: 14]
    run_len = 0  # [cite: 14]
    max_run = {"B": 0, "P": 0}  # [cite: 14]
    for rec in records:
        seen_all += 1  # [cite: 14]
        run_side, run_len = _update_run(run_side, run_len, rec["r"])  # [cite: 14]
        if run_side in ("B","P"):
            if run_len > max_run[run_side]:
                max_run[run_side] = run_len  # [cite: 14]
        if seen_all >= 9:
            break  # [cite: 14]
    return max_run["B"], max_run["P"], seen_all  # [cite: 14]

def _self_stop_tracker_init():
    return {"run_side": None, "run_len": 0, "seen_b3": False, "seen_p3": False}  # [cite: 14]

def _self_stop_tracker_step(st, r):
    st["run_side"], st["run_len"] = _update_run(st["run_side"], st["run_len"], r)  # [cite: 15]
    if st["run_side"] == "B" and st["run_len"] >= 3:
        st["seen_b3"] = True  # [cite: 15]
    if st["run_side"] == "P" and st["run_len"] >= 3:
        st["seen_p3"] = True  # [cite: 15]
    return st  # [cite: 15]

def _should_self_stop(st):
    # ä¸¤è¾¹éƒ½æ›¾å‡ºç°æ®µé•¿â‰¥3 â†’ è‡ªåœ  # [cite: 15]
    return st["seen_b3"] and st["seen_p3"]  # [cite: 15]
from collections import defaultdict

# ==========================
# è¿ç»­ç»Ÿè®¡ï¼ˆäºŒæŒ‡æ ‡äºŒè¿å˜åŒ–ï½œé”æ­»ï¼‰  # [cite: 15]
# ==========================
# ç›®æ ‡ï¼šåœ¨â€œå•æŒ‡æ ‡æ— è§„å¾‹â€çš„å‰æä¸‹ï¼Œåªè§‚å¯Ÿâ€œäºŒæŒ‡æ ‡äºŒè¿å˜åŒ–â€çš„åˆ†å¸ƒï¼Œç”¨äº STOP å€™é€‰ç­›é€‰ï¼›  # [cite: 15]
# çº¦æŸï¼šè¿ç»­ç»Ÿè®¡åªèƒ½åŸºäºâ€œæŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨â€åšäº‹åæ±‡æ€»ï¼›å†³ç­–é€»è¾‘ä»å¿…é¡»æ»¡è¶³â€œå†³ç­–å£åŸºå‡†ï¼ˆé›¶æœªæ¥ï¼‰â€ã€‚  # [cite: 15]
#
# å¿«ç…§å£å¾„ï¼ˆé”æ­»ï½œå£å¾„ Bï¼‰ï¼šæ¯æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘è®°å½•ä¸€æ¬¡å¿«ç…§ï¼ˆå«çŠ¶æ€ T åçš„é‡å¤æŠ•æ”¾ï¼‰ï¼Œå¿«ç…§æ¥è‡ªâ€œæŠ•æ”¾ç‚¹å½“è¡Œâ€åŸå§‹æŒ‡æ ‡ã€‚  # [cite: 15]
# è¿ç»­é•¿åº¦ï¼ˆé”æ­»ï¼‰ï¼šäºŒè¿ï¼ˆä¸Šä¸€æ¬¡â†’è¿™ä¸€æ¬¡ï¼‰ã€‚  # [cite: 15]
#
# å¿«ç…§å­—æ®µï¼ˆå»ºè®®ç­–ç•¥è¿”å› snapshots åˆ—è¡¨ï¼Œæ¯æ¡è‡³å°‘åŒ…å«ï¼‰ï¼š  # [cite: 15]
#   - bet_n: ç¬¬å‡ æ¬¡å®é™…æŠ•æ”¾ï¼ˆä» 1 å¼€å§‹ï¼›å«çŠ¶æ€ T é‡å¤æŠ•æ”¾ä¼šå¯¼è‡´ bet_n > 4ï¼‰  # [cite: 15]
#   - diff: ç‚¹å·®ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - rate: å˜åŒ–ç‡ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - mean: å‡å·®ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - trade_bust: æœ¬ç¬”äº¤æ˜“æœ€ç»ˆæ˜¯å¦é˜ˆå€¼å‡»ç©¿ï¼ˆ0/1ï¼Œç”¨äºè®¡ç®—â€œåç»­é˜ˆå€¼å‡»ç©¿ç‡â€ï¼‰  # [cite: 15]
#
# è¾“å‡ºï¼ˆé”æ­»ï½œAI å‹å¥½ï¼‰ï¼š  # [cite: 15]
#   A) (|ç‚¹å·®|æ¡¶, rate ç›‘æµ‹æ¡¶) çš„äºŒè¿è½¬ç§»æ¦œï¼šS_{t-1}â†’S_tï¼ˆTopKï¼‰  # [cite: 15]
#   B) (|ç‚¹å·®|æ¡¶, mean æ¡¶) çš„äºŒè¿è½¬ç§»æ¦œï¼šS_{t-1}â†’S_tï¼ˆTopKï¼‰  # [cite: 15]
#   æ¯æ¡è½¬ç§»è¾“å‡ºï¼šå‡ºç°æ¬¡æ•°ã€åç»­é˜ˆå€¼å‡»ç©¿æ•°ã€åç»­é˜ˆå€¼å‡»ç©¿ç‡ï¼ˆexhaustion / å‡ºç°æ¬¡æ•°ï¼‰  # [cite: 15]
#   é»˜è®¤åªè¾“å‡ºâ€œæ ·æœ¬é‡ >= é˜ˆå€¼â€çš„è½¬ç§»ï¼Œé¿å…å™ªå£°ã€‚  # [cite: 15]
CONT_STATS_ENABLE = 0  # [cite: 15]
CONT_MAX_BET_N = 12  # [cite: 15]
CONT_MIN_SAMPLES = 500  # [cite: 15]
CONT_TOPK = 20  # [cite: 15]


def _abs_diff_bucket(diff):
    """L2/L3/L4 æ³¨ä½å¿«ç…§ï¼šä¸»åˆ†å¸ƒ |diff|=1..9ï¼›çº é”™è®¡æ•°ï¼š|diff|=0 ä¸ 9+ åˆå¹¶ï¼ˆä¸è¿›å…¥1..9ï¼‰ã€‚"""
    try:
        d = abs(int(diff))
    except Exception:
        d = 0
    if 1 <= d <= 9:
        return str(d)  # "1".."9"
    return "çº é”™(0/9+)"


# å˜åŒ–ç‡ï¼šæ¿€æ´»é˜ˆå€¼ï¼ˆä¸‰æ¡£ï½œé”æ­»ï¼‰  # [cite: 17]
def _rate_entry_bucket(rate):
    if rate is None:
        return "æ— æ•ˆ"  # [cite: 17]
    try:
        r = float(rate)  # [cite: 17]
    except Exception:
        return "æ— æ•ˆ"  # [cite: 17]
    if r <= -3:
        return "<=-3"  # [cite: 17]
    if -3 < r <= -2:
        return "(-3,-2]"  # [cite: 17]
    if -2 < r < 0:
        return "(-2,0)"  # [cite: 17]
    return "å…¶ä»–"  # [cite: 17]

# å˜åŒ–ç‡ï¼šç›‘æµ‹é˜ˆå€¼ï¼ˆä¸‰æ¡£ï½œé”æ­»ï¼‰  # [cite: 18]

def _rate_monitor_bucket(rate):
    """L2/L3/L4 æ³¨ä½å¿«ç…§å˜åŒ–ç‡åˆ†æ¡¶ï¼ˆä¸­æ–‡æ¡¶åé”æ­»ï¼‰ã€‚"""
    if rate is None:
        return "æ— æ•ˆ"
    try:
        r = float(rate)
    except Exception:
        return "æ— æ•ˆ"
    if r < 0:
        return "å‡é€Ÿ"
    if 0 <= r < 2:
        return "åŠ é€Ÿ"
    return "æå€¼"


# å‡å·®ï¼šç›‘æµ‹åˆ†æ¡¶ï¼ˆä¸¤ç±» + 0 å•åˆ—ï½œé”æ­»ï¼‰  # [cite: 19]

def _mean_bucket(mean):
    """L2/L3/L4 æ³¨ä½å¿«ç…§å‡å·®ç»å¯¹å€¼åˆ†æ¡¶ï¼ˆ<3 / â‰¥3ï¼›æ— æ•ˆå•åˆ—ç”¨äºçº é”™è®¡æ•°ï¼‰ã€‚"""
    if mean is None:
        return "æ— æ•ˆ"
    try:
        m = abs(float(mean))
    except Exception:
        return "æ— æ•ˆ"
    if m < 3:
        return "<3"
    return "â‰¥3"

def _l1_abs_diff_bucket(diff):
    """L1 æŠ•æ”¾ç‚¹ç‚¹å·®åˆ†å¸ƒï¼š|diff|=0..9 + 9+ï¼ˆ9+å•åˆ—ï¼‰ã€‚"""
    try:
        d = abs(int(diff))
    except Exception:
        d = 0
    if d >= 10:
        return "9+"
    return str(d)  # "0".."9"

def _l1_rate_bucket(rate):
    """L1 æŠ•æ”¾ç‚¹å˜åŒ–ç‡åˆ†æ¡¶ï¼ˆä¸­æ–‡æ¡¶åé”æ­»ï¼‰ã€‚"""
    if rate is None:
        return "æ— æ•ˆ"
    try:
        r = float(rate)
    except Exception:
        return "æ— æ•ˆ"
    if r > -2:
        return "å‰å°"
    if -3 < r <= -2:
        return "å‰å¤§"
    return "æå€¼"

def _l1_mean_bucket(diff, mean):
    """L1 æŠ•æ”¾ç‚¹å‡å·®åˆ†æ¡¶ï¼šæœ‰æ•ˆåŒå‘/æœ‰æ•ˆåå‘/ä¸­è½´ï¼›meanæ— æ•ˆè¿”å›(None, True)"""
    if mean is None:
        return None, True
    try:
        m = float(mean)
    except Exception:
        return None, True
    try:
        d = float(diff)
    except Exception:
        d = 0.0

    # diff=0 å¼ºåˆ¶ä¸­è½´
    if d == 0:
        return "ä¸­è½´", False

    # mean=0 / |mean|<1 å½’ä¸­è½´
    if abs(m) < 1:
        return "ä¸­è½´", False

    # |mean|>=1ï¼šæŒ‰ç¬¦å·åˆ¤åŒå‘/åå‘
    same = (m > 0 and d > 0) or (m < 0 and d < 0)
    return ("æœ‰æ•ˆåŒå‘" if same else "æœ‰æ•ˆåå‘"), False



def _init_cont_agg():
    return {
        "pair_rate": {},         # key: (bet_n, prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_mean": {},         # key: (bet_n, prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_rate_overall": {}, # key: (prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_mean_overall": {}, # key: (prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "max_bet_n_seen": 0,  # [cite: 21]
    }

def _agg_add(d, key, bust_flag):
    if key not in d:
        d[key] = [0, 0]  # [cite: 22]
    d[key][0] += 1  # [cite: 22]
    d[key][1] += int(1 if bust_flag else 0)  # [cite: 22]

def _cont_consume_snapshots(agg, snapshots):
    # snapshots: list of dicts with bet_n,diff,rate,mean,trade_exhaustion  # [cite: 23]
    if not snapshots:
        return  # [cite: 23]
    snaps = [x for x in snapshots if isinstance(x, dict) and "bet_n" in x]  # [cite: 23]
    snaps.sort(key=lambda x: int(x.get("bet_n", 0)))  # [cite: 23]
    if len(snaps) < 2:
        return  # [cite: 23]

    bust_flag = int(snaps[-1].get("trade_bust", 0))  # [cite: 23]
    for i in range(1, len(snaps)):
        a = snaps[i-1]  # [cite: 23]
        b = snaps[i]  # [cite: 23]
        try:
            bn = int(b.get("bet_n", 0))  # [cite: 23]
        except Exception:
            bn = 0  # [cite: 23]
        if bn > agg["max_bet_n_seen"]:
            agg["max_bet_n_seen"] = bn  # [cite: 23]

        prev_rate = (_abs_diff_bucket(a.get("diff", 0)), _rate_monitor_bucket(a.get("rate")))  # [cite: 24]
        curr_rate = (_abs_diff_bucket(b.get("diff", 0)), _rate_monitor_bucket(b.get("rate")))  # [cite: 24]
        prev_mean = (_abs_diff_bucket(a.get("diff", 0)), _mean_bucket(a.get("mean")))  # [cite: 24]
        curr_mean = (_abs_diff_bucket(b.get("diff", 0)), _mean_bucket(b.get("mean")))  # [cite: 24]

        _agg_add(agg["pair_rate"], (bn, prev_rate, curr_rate), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_mean"], (bn, prev_mean, curr_mean), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_rate_overall"], (prev_rate, curr_rate), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_mean_overall"], (prev_mean, curr_mean), bust_flag)  # [cite: 24]

def _print_top_transitions(title, d, min_samples, topk):
    rows = []  # [cite: 25]
    for k, (cnt, bust) in d.items():
        if cnt < min_samples:
            continue  # [cite: 25]
        br = bust / cnt if cnt else 0.0  # [cite: 25]
        rows.append((br, cnt, bust, k))  # [cite: 25]
    rows.sort(reverse=True, key=lambda x: (x[0], x[1]))  # [cite: 25]
    print(title)  # [cite: 25]
    if not rows:
        print("ï¼ˆæ— è¾“å‡ºï¼šæ ·æœ¬é‡ä¸è¶³ï¼‰")  # [cite: 25]
        return  # [cite: 25]
    for i, (br, cnt, bust, k) in enumerate(rows[:topk], 1):
        print(f"{i:02d}. {k} | æ¬¡æ•°={cnt} | é˜ˆå€¼å‡»ç©¿={bust} | é˜ˆå€¼å‡»ç©¿ç‡={br:.4f}")  # [cite: 26]


# ============================================================
# ç»Ÿä¸€ä»£ç æ¨¡æ¿ï¼ˆV4ï¼Œåºåˆ—é•¿åº¦å£å¾„ï½œä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“ï¼‰
# çº¦æŸï¼š
# 1) åªè¯»å–å½“å‰ç›®å½•ä¸‹æ‰€æœ‰ .csv
# 2) ä¸å†™æ­»ä»»ä½•ç»å¯¹è·¯å¾„
# 3) è‡ªåŠ¨è¯†åˆ«æ‰¹æ¬¡åˆ—/ç»“æœ/ç‚¹å·®/å˜åŒ–ç‡/å‡å·®
# 4) ç»“æœå¿…é¡»æ˜ å°„ä¸º B/P/T
# 5) ä¸¥æ ¼é›¶æœªæ¥ï¼šrun_strategy_on_boot å†…ä¸¥ç¦è®¿é—®æœªæ¥è¡Œ
# 6) â€œä¸‹ä¸€å£/ä¸‹ä¸€è¡Œâ€ç»Ÿä¸€å®šä¹‰ï¼šç´§éšæŠ•æ”¾ç‚¹çš„ä¸‹ä¸€è¡Œï¼ˆä¸è·³è¿‡çŠ¶æ€ T ä½ç§»é›¶åå·®ï¼‰
# 7) å•è¾¹/åŒè¾¹ï¼šå‰ 9 å£åˆ†ç±»ï¼›å•è¾¹å¼±ç´¯è®¡ >=3 è½¬åŒè¾¹ï¼›äº¤æ˜“æ¬¡æ•°é™åˆ¶è§æ¨¡æ¿æ–‡æ¡£
#
# æ³¨æ„ï¼šæœªæ¥æ–°å¢/ä¿®æ”¹ç­–ç•¥ï¼Œåªæ”¹ run_strategy_on_boot(records) å†…éƒ¨é€»è¾‘
# ============================================================

# ============================================================
# ç»“æœæ˜ å°„è¡¨ï¼šå·²å®Œæˆ BPT å…¨é˜¶è„±æ•ï¼Œç‰©ç†åŒ¹é…å®éªŒå®¤æ ‡å‡†åŒ– CSV
# ============================================================
MAP_RESULT = {"B": "B", "P": "P", "T": "T"}

def map_result(v):
    if v is None:
        return None
    s = str(v).strip()
    if s in MAP_RESULT:
        return MAP_RESULT[s]
    s2 = s.upper()
    if s2 in MAP_RESULT:
        return MAP_RESULT[s2]
    return None

# ------------------------------------------------------------
# å·¥å…·ï¼šå®‰å…¨è¯»å– float / intï¼ˆåªè¯»ï¼Œä¸è®¡ç®—ï¼‰
# ------------------------------------------------------------
def safe_float(v, default=None):
    try:
        if v is None or v == "":
            return default
        return float(v)
    except Exception:
        return default


def _is_raw_missing(x):
    if x is None:
        return True
    s = str(x).strip().lower()
    return (s == "" or s == "none" or s == "nan")

def safe_int(v, default=0):
    try:
        if v is None or v == "":
            return default
        return int(float(v))
    except Exception:
        return default

# ------------------------------------------------------------
# 1) æ•°æ®åŠ è½½ï¼ˆå›ºå®šï¼‰
# ------------------------------------------------------------
# ------------------------------------------------------------
# 0) åˆ—è¯†åˆ«ä¸æ˜ å°„ï¼ˆå›ºå®šï½œåªè¯»ï¼‰
# ------------------------------------------------------------
def _norm_key(k):
    return str(k).strip().lower() if k is not None else ""

def _first_hit(keys, candidates):
    key_norm = { _norm_key(k): k for k in keys }
    for c in candidates:
        cc = _norm_key(c)
        if cc in key_norm:
            return key_norm[cc]
    return None

def detect_columns(row0):
    """
    è¾“å…¥ï¼šrow0ï¼ˆDictReader è¯»åˆ°çš„ä¸€è¡Œ dictï¼‰
    è¾“å‡ºï¼šcol_batch, col_end, col_result, col_diff, col_rate, col_mean

    é´è¾¹ç•Œå£å¾„ï¼ˆé”æ­»ï¼‰ï¼š
    - æ‰¹æ¬¡/é´å·ï¼šSub-Batch
    - é´ç»“æŸï¼šé´ç»“æŸï¼ˆä»…æœ€åä¸€å£ä¸º1ï¼Œå…¶ä½™ä¸º0ï¼›è‹¥ç¼ºå¤±/ä¸ä¸€è‡´åˆ™æŠ¥é”™ï¼‰
    """
    keys = list(row0.keys()) if isinstance(row0, dict) else []

    # Sub-Batchï¼ˆé´å·/æ‰¹æ¬¡å·ï¼‰
    col_batch = _first_hit(keys, ["Sub-Batch", "sub-batch", "sub_batch", "subbatch", "æ‰¹æ¬¡", "æ‰¹æ¬¡å·", "batch", "Batch"])
    # é´ç»“æŸ
    col_end = _first_hit(keys, ["é´ç»“æŸ", "shoe_end", "shoe end", "end", "End", "ç»“æŸ", "boot_end", "BootEnd"])

    # ç»“æœåˆ—ï¼šå¸¸è§ Exhaustionï¼ˆå€¼ä¸ºB/P/Tï¼‰
    col_result = _first_hit(keys, ["Exhaustion", "exhaustion", "ç»“æœ", "result", "Result", "Outcome", "outcome"])

    # ç‚¹å·®/å˜åŒ–ç‡/å‡å·®ï¼ˆæ”¯æŒ 2/M3ï¼‰
    col_diff = _first_hit(keys, ["ç‚¹å·®", "diff", "Diff", "spread", "Spread", "delta", "Delta"])
    col_rate = _first_hit(keys, ["å˜åŒ–ç‡", "rate", "Rate", "roc", "ROC", "r", "R", "2"])
    col_mean = _first_hit(keys, ["å‡å·®", "mean", "Mean", "avg", "Avg", "average", "Average", "M3", "m3"])

    return col_batch, col_end, col_result, col_diff, col_rate, col_mean


def _print_header_mapping_once(row0, cols):
    """è¡¨å¤´è¯†åˆ«è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡ï¼›ç»ä¸å½±å“ä¸»æµç¨‹ã€‚"""
    global _HEADER_MAPPING_PRINTED
    if _HEADER_MAPPING_PRINTED:
        return
    _HEADER_MAPPING_PRINTED = True

    try:
        sample_row = row0 if isinstance(row0, dict) else {}

        col_batch, col_end, col_result, col_diff, col_rate, col_mean = cols

        print("==================================================")
        print("è¡¨å¤´è¯†åˆ«ï¼ˆè‡ªè¯ï½œä¸€æ¬¡æ€§æ‰“å°ï¼‰")
        print("æ‰¹æ¬¡(Sub-Batch) ->", col_batch)
        print("é´ç»“æŸ ->", col_end)
        print("ç»“æœ ->", col_result)
        print("ç‚¹å·® ->", col_diff)
        print("å˜åŒ–ç‡ ->", col_rate)
        print("å‡å·® ->", col_mean)

        # æ ·ä¾‹è¡Œï¼šåªå±•ç¤ºå‰12ä¸ªé”®
        d = {}
        show_keys = list(sample_row.keys())[:12]
        for k in show_keys:
            d[k] = sample_row.get(k)
        print("æ ·ä¾‹è¡Œ(åŸå§‹):", d)
        print("==================================================")
    except Exception as e:
        print("âš  è¡¨å¤´è‡ªè¯æ‰“å°å¤±è´¥ï¼ˆä¸å½±å“è¿è¡Œï¼‰:", str(e))


def boot_filter(records):
    # é´çº§å®Œæ•´æ€§ï¼šä¸å­˜åœ¨ä¸è¶³ 9 å£çš„é´ï¼›è‹¥å‘ç°åˆ™æŠ¥é”™å¹¶è¾“å‡ºè¯´æ˜ï¼ˆé”æ­»ï¼‰
    if records is None or len(records) < 9:
        # è¯æ®åªéœ€æ‰“å°ä¸€æ¬¡ï¼šæ–‡ä»¶|Sub-Batch|idxï¼ˆè‹¥ç¼ºå¤±åˆ™å°½é‡è¾“å‡ºå·²æœ‰ä¿¡æ¯ï¼‰
        f = None
        sb = None
        last_idx = None
        try:
            if records:
                f = records[0].get("file")
                sb = records[0].get("sub_batch")
                last_idx = records[-1].get("idx")
        except Exception:
            pass
        print("âŒâŒâŒ é´çº§å®Œæ•´æ€§å¤±è´¥ï¼šä¸è¶³9å£ | æ–‡ä»¶|Sub-Batch|idx =", f, sb, last_idx)
        raise RuntimeError("é´çº§å®Œæ•´æ€§å¤±è´¥ï¼šä¸è¶³9å£")
    return True



# ------------------------------------------------------------
# 3) å•æ‰¹æ¬¡ç­–ç•¥å…¥å£ï¼ˆåªå…è®¸æ”¹è¿™é‡Œï¼‰
# ------------------------------------------------------------
def run_strategy_on_boot(records):
    snapshots = []
    star_snap = None

    entry, match, mismatch, exhaustion = 0, 0, 0, 0
    profit = 0.0

    if not STRUCT_SCAN:
        return {
            "entry": 0, "match": 0, "mismatch": 0, "exhaustion": 0, "profit": 0.0,
            "snapshots": [], "star_snap": None, "trade_bust": 0,
            "struct_status": "STRUCT_SKIP", "struct_fail_reason": None, "struct_info": None,
        }

    status, star_idx, strong_side, info = scan_structure(records)
    if status != "STRUCT_OK":
        return {
            "entry": 0, "match": 0, "mismatch": 0, "exhaustion": 0, "profit": 0.0,
            "snapshots": [], "star_snap": None, "trade_bust": 0,
            "struct_status": "STRUCT_FAIL",
            "struct_fail_reason": (info.get("fail_reason") if isinstance(info, dict) else None),
            "struct_info": info,
        }

    star_row = records[star_idx]
    star_seen = star_row.get("seen_all")

    if star_row.get("r") not in ("B", "P"):
        print("âŒâŒâŒ STRUCT_ERRORï¼šâ­è½åœ¨T | æ–‡ä»¶|Sub-Batch|idx|seen|r|diff =", _CTX_FILE, _CTX_SUBBATCH, star_idx, star_seen, star_row.get("r"), star_row.get("diff"))
        raise RuntimeError("STRUCT_ERRORï¼šâ­è½åœ¨T")
    try:
        if int(star_row.get("diff")) == 0:
            print("âŒâŒâŒ STRUCT_ERRORï¼šâ­ç‚¹å·®=0 | æ–‡ä»¶|Sub-Batch|idx|seen|r|diff =", _CTX_FILE, _CTX_SUBBATCH, star_idx, star_seen, star_row.get("r"), star_row.get("diff"))
            raise RuntimeError("STRUCT_ERRORï¼šâ­ç‚¹å·®=0")
    except Exception:
        print("âŒâŒâŒ STRUCT_ERRORï¼šâ­ç‚¹å·®æ— æ³•è§£æ | æ–‡ä»¶|Sub-Batch|idx|seen|r|diff =", _CTX_FILE, _CTX_SUBBATCH, star_idx, star_seen, star_row.get("r"), star_row.get("diff"))
        raise RuntimeError("STRUCT_ERRORï¼šâ­ç‚¹å·®æ— æ³•è§£æ")

    star_snap = {
        "file": star_row.get("file"),
        "sub_batch": star_row.get("sub_batch"),
        "idx": star_idx,
        "seen_all": star_seen,
        "r": star_row.get("r"),
        "diff": star_row.get("diff"),
        "rate": star_row.get("rate"),
        "mean": star_row.get("mean"),
        "rate_raw": star_row.get("rate_raw"),
        "mean_raw": star_row.get("mean_raw"),
    }

    target_side = strong_side
    entry += 1

    units = [1, 2, 4, 8]
    is_settled = False

    j = star_idx
    j += 1
    bet_n = 1
    max_bet = len(units)

    while bet_n <= max_bet and j < len(records):
        decision_row = records[j]

        if BOOT_FILTER:
            seen = decision_row.get("seen_all")
            if seen is not None:
                try:
                    if 1 <= int(seen) <= 8:
                        j += 1
                        continue
                except Exception:
                    pass

        snap = {
            "file": decision_row.get("file"),
            "sub_batch": decision_row.get("sub_batch"),
            "idx": decision_row.get("idx"),
            "seen_all": decision_row.get("seen_all"),
            "r": decision_row.get("r"),
            "diff": decision_row.get("diff"),
            "rate": decision_row.get("rate"),
            "mean": decision_row.get("mean"),
            "rate_raw": decision_row.get("rate_raw"),
            "mean_raw": decision_row.get("mean_raw"),
        }
        snapshots.append(snap)

        rr = decision_row.get("r")
        if rr == "T":
            j += 1
            continue

        u = units[bet_n - 1]
        if rr == target_side:
            match += 1
            profit += (u * 0.95 if target_side == "B" else u * 1.0)
            is_settled = True
            break
        else:
            profit -= u
            bet_n += 1
            j += 1
            continue

    trade_bust_flag = 0
    if not is_settled:
        mismatch += 1
        exhaustion += 1
        trade_bust_flag = 1

    for _s in snapshots:
        if isinstance(_s, dict):
            _s["trade_bust"] = trade_bust_flag

    return {
        "entry": entry,
        "match": match,
        "mismatch": mismatch,
        "exhaustion": exhaustion,
        "profit": profit,
        "snapshots": snapshots,
        "star_snap": star_snap,
        "trade_bust": 1 if exhaustion > 0 else 0,
        "struct_status": "STRUCT_OK",
        "struct_fail_reason": None,
        "struct_info": info,
    }

def load_all_boots(csv_files):
    # boots: list of (meta, records)
    boots = []  # æ¯ä¸ªå…ƒç´ ï¼š({"file":..., "sub_batch":...}, [records...])

    print("æ£€æµ‹åˆ° CSV æ–‡ä»¶æ•°é‡:", len(csv_files))

    for i, fname in enumerate(csv_files, 1):
        if i % 10 == 0:
            print(f"è¿›åº¦: å·²å¤„ç† {i}/{len(csv_files)} ä¸ªæ–‡ä»¶")

        rows = []
        for enc in ("utf-8", "utf-8-sig", "gbk", "gb18030"):
            try:
                with open(fname, "r", encoding=enc) as f:
                    rows = list(csv.DictReader(f))
                break
            except Exception:
                rows = []

        if not rows:
            continue

        col_batch, col_end, col_result, col_diff, col_rate, col_mean = detect_columns(rows[0])
        _print_header_mapping_once(rows[0], (col_batch, col_end, col_result, col_diff, col_rate, col_mean))

        if col_batch is None or col_end is None:
            print("âŒâŒâŒ è¡¨å¤´ç¼ºå¤±ï¼šå¿…é¡»åŒæ—¶å­˜åœ¨ Sub-Batch ä¸ é´ç»“æŸ | æ–‡ä»¶ =", fname)
            raise RuntimeError("è¡¨å¤´ç¼ºå¤±ï¼šSub-Batch / é´ç»“æŸ")

        current_batch = None
        current_records = []
        seen_all = 0
        end_seen = 0

        def _finalize_boot():
            nonlocal current_batch, current_records, seen_all, end_seen
            if current_batch is None:
                return
            if not current_records:
                return

            # é´ç»“æŸä¸€è‡´æ€§ï¼šä»…æœ€åä¸€å£ä¸º1ï¼Œå…¶ä½™ä¸º0ï¼ˆé”æ­»ï¼‰
            if end_seen != 1:
                print("âŒâŒâŒ é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šé´ç»“æŸ=1æ¬¡æ•°!=1 | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch, (current_records[-1].get("idx") if current_records else None))
                raise RuntimeError("é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šé´ç»“æŸ=1æ¬¡æ•°!=1")
            if safe_int(current_records[-1].get("shoe_end"), 0) != 1:
                print("âŒâŒâŒ é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæœ€åä¸€å£é´ç»“æŸ!=1 | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch, current_records[-1].get("idx"))
                raise RuntimeError("é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæœ€åä¸€å£é´ç»“æŸ!=1")

            boots.append(({"file": fname, "sub_batch": current_batch}, current_records))

            # reset
            current_batch = None
            current_records = []
            seen_all = 0
            end_seen = 0

        for row_i, r in enumerate(rows):
            batch = r.get(col_batch)

            # å­æ‰¹æ¬¡å¯åŠ¨
            if current_batch is None:
                current_batch = batch

            # Sub-Batch å˜æ›´å¿…é¡»ä¸é´ç»“æŸå¯¹é½ï¼ˆé”æ­»ï¼‰ï¼šæœªé‡åˆ°é´ç»“æŸ=1 ä¸å…è®¸å˜æ›´
            if batch != current_batch:
                print("âŒâŒâŒ é´è¾¹ç•Œå¤±è´¥ï¼šSub-Batch åœ¨é´ç»“æŸå‰å‘ç”Ÿå˜æ›´ | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch, (current_records[-1].get("idx") if current_records else None))
                raise RuntimeError("é´è¾¹ç•Œå¤±è´¥ï¼šSub-Batch å˜æ›´æœªå¯¹é½é´ç»“æŸ")

            res_raw = r.get(col_result)
            res = map_result(res_raw)
            if res not in ("B", "P", "T"):
                # æ— æ³•æ˜ å°„çš„ä¸å…¥åº“ï¼ˆé”æ­»ï¼‰
                continue

            diff = safe_int(r.get(col_diff, 0), 0)
            rate_raw = (r.get(col_rate) if col_rate else None)
            mean_raw = (r.get(col_mean) if col_mean else None)
            rate = safe_float(rate_raw, None) if col_rate else None
            mean = safe_float(mean_raw, None) if col_mean else None
            shoe_end = safe_int(r.get(col_end, 0), 0)

            seen_all += 1
            rec = {
                "idx": seen_all - 1,
                "seen_all": seen_all,
                "r": res,
                "diff": diff,
                "rate": rate,
                "mean": mean,
            "rate_raw": rate_raw,
            "mean_raw": mean_raw,
                "file": fname,
                "sub_batch": current_batch,
                "shoe_end": shoe_end,
            }
            current_records.append(rec)

            if shoe_end == 1:
                end_seen += 1
                _finalize_boot()

        # æ–‡ä»¶ç»“æŸï¼šè‹¥ä»æœ‰æœªå°å£çš„é´ â†’ æŠ¥é”™
        if current_batch is not None:
            if current_records:
                print("âŒâŒâŒ é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæ–‡ä»¶ç»“æŸä»æœªé‡åˆ°é´ç»“æŸ=1 | æ–‡ä»¶|Sub-Batch|idx =", fname, current_batch, current_records[-1].get("idx"))
                raise RuntimeError("é´ç»“æŸä¸€è‡´æ€§å¤±è´¥ï¼šæ–‡ä»¶ç»“æŸæœªå°å£")

    print("æŒ‰ Sub-Batch + é´ç»“æŸ åˆ†é´å®Œæˆï¼Œé´æ€»æ•°:", len(boots))
    return boots

def _run_report(csv_files, title):
    boots = load_all_boots(csv_files)
    total_boots = len(boots)

    playable_boots = 0
    skipped_boots = 0

    total_entry = 0
    total_match = 0
    total_mismatch = 0
    total_exhaustion = 0
    total_profit = 0.0

    # ------------------------------------------------------------
    # L1 é”æ­»æ ‡é¢˜ç»Ÿè®¡ï¼ˆæŠ•æ”¾ç‚¹å½“è¡Œï¼‰
    # ------------------------------------------------------------
    l1_diff_dist = defaultdict(int)  # key: '0'..'9','9+'
    l1_rate_dist = defaultdict(int)  # key: å‰å°/å‰å¤§/æå€¼/æ— æ•ˆ
    l1_mean_dist = defaultdict(int)  # key: æœ‰æ•ˆåŒå‘/æœ‰æ•ˆåå‘/ä¸­è½´
    STAR_ON_T = 0
    STAR_DIFF0_AND_R_IN_BP = 0
    MEAN_MISSING_RAW = 0  # æ•°æ®ç¼ºå¤±-ä»…ç»Ÿè®¡
    MEAN_PARSE_FAIL = 0     # è§£æå¤±è´¥-ç›®æ ‡=0
    STRUCT_SCAN_CALLS = 0
    STRUCT_OK = 0
    STRUCT_FAIL = 0
    MISS_MAIN_LT3 = 0
    MISS_WEAK_GT2 = 0
    MISS_NO_CANDIDATE = 0
    MISS_ONLY_FORBIDDEN = 0



    cont_agg = _init_cont_agg() if CONT_STATS_ENABLE else None

    # ------------------------------------------------------------
    # æ‰¹æ¬¡å¤„ç†è¿›åº¦è¾“å‡ºï¼ˆåªæ‰“å°ï½œä¸å‚ä¸ä»»ä½•åˆ¤æ–­ï¼‰
    # ------------------------------------------------------------
    def _print_batch_progress(done, total, bar_width=20, force_newline=False):
        if total <= 0:
            return
        if done < 0:
            done = 0
        if done > total:
            done = total
        ratio = done / total
        filled = int(ratio * bar_width)
        if filled < 0:
            filled = 0
        if filled > bar_width:
            filled = bar_width
        bar = ("=" * filled) + (" " * (bar_width - filled))
        pct = ratio * 100.0
        line = f"è¿›åº¦: [{bar}] {pct:.1f}% ({done:,}/{total:,} æ‰¹æ¬¡)"
        if force_newline:
            print(line)
        else:
            print("\r" + line, end="", flush=True)

    if total_boots > 0:
        print()
        print(f"å¼€å§‹å¤„ç† {total_boots:,} ä¸ªæ‰¹æ¬¡...")

    step = max(1, total_boots // 200) if total_boots > 0 else 1

    for n, (meta, rec) in enumerate(boots, 1):
        if total_boots > 0 and (n == 1 or n == total_boots or (n % step == 0)):
            _print_batch_progress(n, total_boots)
        boot_filter(rec)  # é´çº§å®Œæ•´æ€§æ ¡éªŒï¼ˆä¸è¶³9å£ç›´æ¥æŠ¥é”™ï¼‰

        playable_boots += 1
        global _CTX_FILE, _CTX_SUBBATCH
        _CTX_FILE = meta.get('file', '')
        _CTX_SUBBATCH = meta.get('sub_batch', '')
        out = run_strategy_on_boot(rec)

        # L1 æŠ•æ”¾ç‚¹å½“è¡Œç»Ÿè®¡ï¼šä»…ä½¿ç”¨ star_snapï¼ˆå–å€¼å£é”æ­»ï¼‰
        star = out.get("star_snap")
        if isinstance(star, dict):
            sr = star.get("r")
            sd = star.get("diff")
            srate = star.get("rate")
            smean = star.get("mean")

            if sr == "T":
                STAR_ON_T += 1
            elif sr in ("B", "P"):
                if safe_int(sd, 0) == 0:
                    STAR_DIFF0_AND_R_IN_BP += 1

                l1_diff_dist[_l1_abs_diff_bucket(sd)] += 1
                l1_rate_dist[_l1_rate_bucket(srate)] += 1

                # L1å‡å·®åˆ†æ¡¶ï¼šåŒºåˆ†ç¼ºå¤±/è§£æå¤±è´¥ï¼ˆè§£æå¤±è´¥ç›®æ ‡=0ï¼‰
                mean_raw = star.get("mean_raw")
                mean_val = smean

                if _is_raw_missing(mean_raw):
                    if mean_val is None:
                        MEAN_MISSING_RAW += 1
                        mb = None
                    else:
                        mb, _ = _l1_mean_bucket(sd, mean_val)
                else:
                    if mean_val is None:
                        MEAN_PARSE_FAIL += 1
                        mb = None
                    else:
                        mb, _ = _l1_mean_bucket(sd, mean_val)

                if mb is not None:
                    l1_mean_dist[mb] += 1

        # ç»“æ„æ‰«æè‡ªè¯ç»Ÿè®¡
        if STRUCT_SCAN:
            STRUCT_SCAN_CALLS += 1
            if out.get("struct_status") == "STRUCT_OK":
                STRUCT_OK += 1
            elif out.get("struct_status") == "STRUCT_FAIL":
                STRUCT_FAIL += 1
                fr = out.get("struct_fail_reason")
                if fr == "MAIN_LT3":
                    MISS_MAIN_LT3 += 1
                elif fr == "WEAK_GT2":
                    MISS_WEAK_GT2 += 1
                elif fr == "NO_CANDIDATE":
                    MISS_NO_CANDIDATE += 1
                elif fr == "ONLY_FORBIDDEN":
                    MISS_ONLY_FORBIDDEN += 1

        total_entry += int(out.get("entry", 0))
        total_match += int(out.get("match", 0))
        total_mismatch += int(out.get("mismatch", 0))
        total_exhaustion += int(out.get("exhaustion", 0))
        total_profit += float(out.get("profit", 0.0))

        if cont_agg is not None:
            _cont_consume_snapshots(cont_agg, out.get("snapshots") or [])

    if total_boots > 0:
        print()  # ç»“æŸè¿›åº¦è¡Œ

    print()
    print("============================================================")
    print("ğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°")
    print("============================================================")
    print(title)
    print("============================================================")
    print("æ‰«ææ–¹å¼ï¼šä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“")
    print("æ®µé•¿å£å¾„ï¼šç¦æ­¢è·¨æ®µç´¯è®¡")
    print("æœ¯è¯­é”æ­»ï¼šåªæ‰¿è®¤ã€Œâ­ / æŠ•æ”¾ç‚¹ã€")
    print(f"ç»“æ„é—¸é—¨ï¼š{STRUCT_SCAN_TEXT}")
    print(f"{STRUCT_SUMMARY_LINE} | HASH={STRUCT_DEF_HASH}")
    global _STRUCT_SUMMARY_PRINTED
    _STRUCT_SUMMARY_PRINTED = True
    print(f"ç›‘æµ‹å¼€å…³ï¼š{'å¼€' if MONITOR_ENABLE else 'å…³'}")
    print("é˜ˆå€¼å‡»ç©¿å½’å› ï¼šè·¯å¾„å¿«ç…§ï¼ˆæ¯æ¬¡å®é™…æŠ•æ”¾å‰éƒ½å¿«ç…§ï¼›å«çŠ¶æ€ T åçš„é‡å¤æŠ•æ”¾ï¼›å½’å› åªç”¨å¿«ç…§ï¼‰")
    print("------------------------------------------------------------")
    print("TOTAL_BOOT       :", total_boots)
    print(_boot_filter_label())
    print("------------------------------------------------------------")
    print("æ€»æ‰¹æ¬¡æ•°    :", total_boots)
    print("å¯å‚ä¸æ‰¹æ¬¡æ•°:", playable_boots)
    print("è·³è¿‡æ‰¹æ¬¡æ•°  :", skipped_boots)
    print("------------------------------------------------------------")
    print("æ¿€æ´»æ¬¡æ•°    :", total_entry)
    print("åŒ¹é…æ¬¡æ•°    :", total_match)
    print("ä¸åŒ¹é…æ¬¡æ•°  :", total_mismatch)
    print("é˜ˆå€¼å‡»ç©¿æ¬¡æ•°:", total_exhaustion)
    if total_entry > 0:
        match_rate = total_match / total_entry * 100.0
        exhaustion_rate = total_exhaustion / total_entry * 100.0
        print(f"åŒ¹é…ç‡      : {match_rate:.4f}%")
        print(f"é˜ˆå€¼å‡»ç©¿ç‡  : {exhaustion_rate:.4f}%")
        print(f"å•æ¬¡å¹³å‡å¢ç›Š: {total_profit / total_entry:.6f}")
    print("æ€»å‡€å€¼å¢ç›Š  :", round(total_profit, 2))

    print()
    print("------------------------------------------------------------")
    print("[é”æ­»æ ‡é¢˜] L1ç‚¹å·®åˆ†å¸ƒï¼ˆæŠ•æ”¾ç‚¹ï½œ|ç‚¹å·®|=0..9 + 9+ï¼‰:")
    for k in [str(i) for i in range(0, 10)] + ["9+"]:
        if k in l1_diff_dist:
            print(f"  {k}: {l1_diff_dist[k]}")
    print("------------------------------------------------------------")
    print("[é”æ­»æ ‡é¢˜] L1å˜åŒ–ç‡åˆ†æ¡¶ï¼ˆæŠ•æ”¾ç‚¹ï½œå‰å°/å‰å¤§/æå€¼/æ— æ•ˆï¼‰:")
    for k in ["å‰å°", "å‰å¤§", "æå€¼", "æ— æ•ˆ"]:
        if k in l1_rate_dist:
            print(f"  {k}: {l1_rate_dist[k]}")
    print("------------------------------------------------------------")
    print("[é”æ­»æ ‡é¢˜] L1å‡å·®åˆ†æ¡¶ï¼ˆæŠ•æ”¾ç‚¹ï½œæœ‰æ•ˆåŒå‘/æœ‰æ•ˆåå‘/ä¸­è½´ï¼‰:")
    for k in ["æœ‰æ•ˆåŒå‘", "æœ‰æ•ˆåå‘", "ä¸­è½´"]:
        if k in l1_mean_dist:
            print(f"  {k}: {l1_mean_dist[k]}")
    print("------------------------------------------------------------")
    print("è‡ªè¯é¡¹ï¼ˆæ¯æ¬¡è·‘å¿…å‡ºï¼‰:")
    print("  STAR_ON_T:", STAR_ON_T)
    print("  STAR_DIFF0_AND_R_IN_BP:", STAR_DIFF0_AND_R_IN_BP)
    print("  MEAN_MISSING_RAW:", MEAN_MISSING_RAW)
    print("  MEAN_PARSE_FAIL:", MEAN_PARSE_FAIL)


    if cont_agg is not None:
        print()
        print("------------------------------------------------------------")
        print("è¿ç»­ç»Ÿè®¡ï¼ˆäºŒæŒ‡æ ‡äºŒè¿å˜åŒ–ï½œäº‹åæ±‡æ€»ï½œå­¦æœ¯ç‰ˆï¼‰")
        print("è¯´æ˜ï¼šä»…åŸºäºæŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨ï¼ˆå«çŠ¶æ€ T é‡å¤æŠ•æ”¾ï¼‰ï¼›æ ·æœ¬é‡ä¸è¶³ä¸è¾“å‡ºã€‚")
        print("é˜ˆå€¼ï¼šmin_samples=%dï½œTopK=%d" % (CONT_MIN_SAMPLES, CONT_TOPK))

        _print_top_transitions(
            "A) (|ç‚¹å·®|,rate ç›‘æµ‹æ¡¶) Overall Top",
            cont_agg["pair_rate_overall"],
            CONT_MIN_SAMPLES,
            CONT_TOPK,
        )
        _print_top_transitions(
            "B) (|ç‚¹å·®|,mean æ¡¶) Overall Top",
            cont_agg["pair_mean_overall"],
            CONT_MIN_SAMPLES,
            CONT_TOPK,
        )

        max_bn = min(int(cont_agg.get("max_bet_n_seen", 0) or 0), CONT_MAX_BET_N)
        for bn in range(2, max_bn + 1):
            tmp_rate = {}
            tmp_mean = {}
            for (bn2, a, b), v in cont_agg["pair_rate"].items():
                if bn2 == bn:
                    tmp_rate[(a, b)] = v
            for (bn2, a, b), v in cont_agg["pair_mean"].items():
                if bn2 == bn:
                    tmp_mean[(a, b)] = v

            _print_top_transitions(
                f"A) bet_n={bn} (|ç‚¹å·®|,rate ç›‘æµ‹æ¡¶) Top",
                tmp_rate,
                CONT_MIN_SAMPLES,
                min(10, CONT_TOPK),
            )
            _print_top_transitions(
                f"B) bet_n={bn} (|ç‚¹å·®|,mean æ¡¶) Top",
                tmp_mean,
                CONT_MIN_SAMPLES,
                min(10, CONT_TOPK),
            )

    print("============================================================")

def main():
    _audit_structure_slot_integrity()
    _audit_forbid_idx_offset()
    csv_files = sorted([f for f in os.listdir(".") if f.lower().endswith(".csv")])
    if VERIFY_SPLIT_ENABLE and len(csv_files) >= 2:
        mid = len(csv_files) // 2
        _run_report(csv_files[:mid], "éªŒçœŸé˜¶æ®µï¼ˆå‰ 50%ï¼‰")
        _run_report(csv_files[mid:], "éªŒçœŸé˜¶æ®µï¼ˆå 50%ï¼‰")
    else:
        _run_report(csv_files, "ä¼˜åŒ–é˜¶æ®µï¼ˆå…¨é‡ï¼‰")

if __name__ == "__main__":
    main()
