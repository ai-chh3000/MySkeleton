# ã€ç‰ˆæœ¬æ°´å°ï¼ˆäº¤ä»˜éªŒæ”¶ç”¨ï½œé”æ­»ï¼‰ã€‘
# æ°´å°ï¼šğŸ°ğŸ°ğŸ°
# -*- coding: utf-8 -*-
import csv
import os
import inspect

# è¡¨å¤´è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡
_HEADER_MAPPING_PRINTED = False


def _audit_forbid_idx_offset():
    """
    å®‰å…¨è‡ªæ£€ï¼ˆé”æ­»ï½œæ‰§è¡Œ/ç»“ç®—æ®µï¼‰ï¼š
    - ç¦æ­¢ï¼šidx + åç§»é‡ / records[idx + ...] ç­‰â€œç›´ç®—æœªæ¥è¡Œå·â€
    - ç¦æ­¢ï¼šåœ¨æ‰§è¡Œ/ç»“ç®—æ®µå›è¯» diff/rate/mean ä½œä¸ºåˆ¤æ–­ä¾æ®
    è¯´æ˜ï¼šåªå®¡è®¡ run_strategy_on_boot() å†…â€œç»“ç®—å¼€å§‹é”šç‚¹â€ä¹‹åçš„ä»£ç ï¼Œé¿å…è¯¯ä¼¤â€œæŠ•æ”¾å‰å¿«ç…§â€ã€‚
    """
    print("=== å®‰å…¨è‡ªæ£€å¼€å§‹ ===")

    # 1) æŠ½å–ç­–ç•¥æºç ï¼ˆæ— æ³•è¯»å–åˆ™è·³è¿‡ï¼Œä½†ä¸å½±å“è¿è¡Œï¼‰
    try:
        src = inspect.getsource(run_strategy_on_boot)
    except Exception:
        print("âš  è‡ªæ£€è·³è¿‡ï¼šæ— æ³•è¯»å– run_strategy_on_boot æºç ï¼ˆä¸å½±å“è¿è¡Œï¼‰")
        print("=== å®‰å…¨è‡ªæ£€å®Œæˆ ===")
        return

    # 2) åªå®¡è®¡â€œæ‰§è¡Œ/ç»“ç®—æ®µâ€ï¼šä»é”šç‚¹å¼€å§‹å¾€å
    anchor = "# 3) æœ¬æ¬¡æŠ•æ”¾çš„ç»“ç®—"
    pos = src.find(anchor)
    audit_src = src[pos:] if pos >= 0 else src

    # 3) ç¦æ­¢ç‰‡æ®µï¼ˆæ‰§è¡Œ/ç»“ç®—æ®µï¼‰
    forbidden = [
        # æœªæ¥è¡Œå·ç›´ç®—ï¼ˆç¦æ­¢ï¼‰
        "idx + step_idx", "idx+step_idx",
        "idx + b_idx", "idx+b_idx",
        "records[idx +", "records[idx+",

        # ç»“ç®—/æ‰§è¡Œé˜¶æ®µå°†æ¸¸æ ‡æŒ‡å‘ç»“ç®—è¡Œå¹¶å›è¯»æŒ‡æ ‡ï¼ˆç¦æ­¢ï¼‰
        "settle_idx", "last_bet_idx",
        "records[settle_idx]", "records[last_bet_idx]",
        "records [settle_idx]", "records [last_bet_idx]",

        # ç»•è·¯å†™æ³•ï¼ˆç¦æ­¢ï¼‰ï¼šåŒºé—´è¯»å–/åŒºé—´å¾ªç¯/è¡¨æ ¼å¼ç´¢å¼•
        "records[idx:","records[idx :","records[ idx:","records[ idx :",
        "records[idx+1:","records[idx + 1:","records[idx +1:",
        "range(idx","range(idx +","range( idx",
        "iloc[",

    ]

    hit = [s for s in forbidden if s in audit_src]

    if hit:
        print("âŒâŒâŒ ä¸é€šè¿‡: æ‰§è¡Œ/ç»“ç®—æ®µæ£€æµ‹åˆ°ç¦æ­¢ç‰‡æ®µ:", ",".join(hit))
        lines = audit_src.splitlines()
        shown = 0
        for i, line in enumerate(lines, 1):
            if any(h in line for h in hit):
                print(f"è¯æ®è¡Œ{i}: {line.strip()}")
                shown += 1
                if shown >= 5:
                    break
        print("=== å®‰å…¨è‡ªæ£€å®Œæˆ ===")
        raise RuntimeError("å®‰å…¨è‡ªæ£€å¤±è´¥ï¼šæ‰§è¡Œ/ç»“ç®—æ®µå­˜åœ¨ç¦æ­¢ç‰‡æ®µ")

    print("âœ…âœ…âœ… é€šè¿‡: æ‰§è¡Œ/ç»“ç®—æ®µæœªæ£€æµ‹åˆ°ç¦æ­¢ç‰‡æ®µ")
    print("=== å®‰å…¨è‡ªæ£€å®Œæˆ ===")


SCAN_MODE_LOCKED = "ä¸€æ¬¡æ€§æ‰«æ"  # æ‰«ææ–¹å¼é”æ­»ï¼šä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“
MONITOR_ENABLE = 1  # ç›‘æµ‹å¼€å…³ï¼š0=å…³ï¼›1=å¼€ï¼ˆç”¨äºåŠ¨æ€ç›‘æµ‹/åŠ¨æ€æ­¢æŸï¼‰  # [cite: 12]
# å¤šæ¬¡å†³ç­–ï¼ˆåŠ¨æ€ç›‘æµ‹/åŠ¨æ€æ­¢æŸï½œé”æ­»ï¼‰ï¼šåŒä¸€ç¬”äº¤æ˜“å†…ï¼Œæ¯ä¸€æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘å…è®¸åšä¸€æ¬¡â€œç»§ç»­/STOPâ€å†³å®šï¼›  # [cite: 12]
# å†³ç­–æ—¶åˆ»è§†ä¸ºä¸€æ¬¡â€œæŠ•æ”¾ç‚¹â€ï¼Œåªå…è®¸è¯»å–è¯¥è¡ŒåŠå†å²æŒ‡æ ‡ï¼›ä¸¥ç¦ä½¿ç”¨è¯¥å†³ç­–å£ä¹‹åï¼ˆt+1åŠä»¥åï¼‰çš„ä»»ä½•ä¿¡æ¯ã€‚  # [cite: 12]
VERIFY_SPLIT_ENABLE = 0  # éªŒçœŸåˆ†æ‹†å¼€å…³ï¼š0=å…³ï¼›1=å¼€ï¼ˆæŒ‰æ–‡ä»¶åæ’åºå‰50%/å50%åˆ†åˆ«è·‘ï¼‰  # [cite: 12]

# ==========================
# æ®µé•¿ä¸è‡ªåœï¼ˆé”æ­»ï½œä»æ‰¹æ¬¡é¦–å¼€å§‹ï¼‰  # [cite: 12]
# ==========================
def _is_bp(r):
    return r in ("B", "P")  # [cite: 12]

def _update_run(run_side, run_len, r):
    # çŠ¶æ€ T ä½ç§»é›¶åå·®ï¼šrun_side/run_len ä¸å˜  # [cite: 13]
    if r == "T":
        return run_side, run_len  # [cite: 13]
    if not _is_bp(r):
        return run_side, run_len  # [cite: 13]
    if run_side is None or r != run_side:
        return r, 1  # [cite: 13]
    return run_side, run_len + 1  # [cite: 13]

def _compute_max_runs_first9(records):
    # åªçœ‹å‰ 9 å£ï¼ˆseen_all=1..9ï¼ŒçŠ¶æ€ B/P/T éƒ½ç®—ä½ç§»å£æ•°ï¼‰  # [cite: 14]
    seen_all = 0  # [cite: 14]
    run_side = None  # [cite: 14]
    run_len = 0  # [cite: 14]
    max_run = {"B": 0, "P": 0}  # [cite: 14]
    for rec in records:
        seen_all += 1  # [cite: 14]
        run_side, run_len = _update_run(run_side, run_len, rec["r"])  # [cite: 14]
        if run_side in ("B","P"):
            if run_len > max_run[run_side]:
                max_run[run_side] = run_len  # [cite: 14]
        if seen_all >= 9:
            break  # [cite: 14]
    return max_run["B"], max_run["P"], seen_all  # [cite: 14]

def _self_stop_tracker_init():
    return {"run_side": None, "run_len": 0, "seen_b3": False, "seen_p3": False}  # [cite: 14]

def _self_stop_tracker_step(st, r):
    st["run_side"], st["run_len"] = _update_run(st["run_side"], st["run_len"], r)  # [cite: 15]
    if st["run_side"] == "B" and st["run_len"] >= 3:
        st["seen_b3"] = True  # [cite: 15]
    if st["run_side"] == "P" and st["run_len"] >= 3:
        st["seen_p3"] = True  # [cite: 15]
    return st  # [cite: 15]

def _should_self_stop(st):
    # ä¸¤è¾¹éƒ½æ›¾å‡ºç°æ®µé•¿â‰¥3 â†’ è‡ªåœ  # [cite: 15]
    return st["seen_b3"] and st["seen_p3"]  # [cite: 15]
from collections import defaultdict

# ==========================
# è¿ç»­ç»Ÿè®¡ï¼ˆäºŒæŒ‡æ ‡äºŒè¿å˜åŒ–ï½œé”æ­»ï¼‰  # [cite: 15]
# ==========================
# ç›®æ ‡ï¼šåœ¨â€œå•æŒ‡æ ‡æ— è§„å¾‹â€çš„å‰æä¸‹ï¼Œåªè§‚å¯Ÿâ€œäºŒæŒ‡æ ‡äºŒè¿å˜åŒ–â€çš„åˆ†å¸ƒï¼Œç”¨äº STOP å€™é€‰ç­›é€‰ï¼›  # [cite: 15]
# çº¦æŸï¼šè¿ç»­ç»Ÿè®¡åªèƒ½åŸºäºâ€œæŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨â€åšäº‹åæ±‡æ€»ï¼›å†³ç­–é€»è¾‘ä»å¿…é¡»æ»¡è¶³â€œå†³ç­–å£åŸºå‡†ï¼ˆé›¶æœªæ¥ï¼‰â€ã€‚  # [cite: 15]
#
# å¿«ç…§å£å¾„ï¼ˆé”æ­»ï½œå£å¾„ Bï¼‰ï¼šæ¯æ¬¡ã€å®é™…æŠ•æ”¾å‰ã€‘è®°å½•ä¸€æ¬¡å¿«ç…§ï¼ˆå«çŠ¶æ€ T åçš„é‡å¤æŠ•æ”¾ï¼‰ï¼Œå¿«ç…§æ¥è‡ªâ€œæŠ•æ”¾ç‚¹å½“è¡Œâ€åŸå§‹æŒ‡æ ‡ã€‚  # [cite: 15]
# è¿ç»­é•¿åº¦ï¼ˆé”æ­»ï¼‰ï¼šäºŒè¿ï¼ˆä¸Šä¸€æ¬¡â†’è¿™ä¸€æ¬¡ï¼‰ã€‚  # [cite: 15]
#
# å¿«ç…§å­—æ®µï¼ˆå»ºè®®ç­–ç•¥è¿”å› snapshots åˆ—è¡¨ï¼Œæ¯æ¡è‡³å°‘åŒ…å«ï¼‰ï¼š  # [cite: 15]
#   - bet_n: ç¬¬å‡ æ¬¡å®é™…æŠ•æ”¾ï¼ˆä» 1 å¼€å§‹ï¼›å«çŠ¶æ€ T é‡å¤æŠ•æ”¾ä¼šå¯¼è‡´ bet_n > 4ï¼‰  # [cite: 15]
#   - diff: ç‚¹å·®ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - rate: å˜åŒ–ç‡ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - mean: å‡å·®ï¼ˆåŸå§‹åˆ—ï¼Œåªè¯»ï¼‰  # [cite: 15]
#   - trade_bust: æœ¬ç¬”äº¤æ˜“æœ€ç»ˆæ˜¯å¦é˜ˆå€¼å‡»ç©¿ï¼ˆ0/1ï¼Œç”¨äºè®¡ç®—â€œåç»­é˜ˆå€¼å‡»ç©¿ç‡â€ï¼‰  # [cite: 15]
#
# è¾“å‡ºï¼ˆé”æ­»ï½œAI å‹å¥½ï¼‰ï¼š  # [cite: 15]
#   A) (|ç‚¹å·®|æ¡¶, rate ç›‘æµ‹æ¡¶) çš„äºŒè¿è½¬ç§»æ¦œï¼šS_{t-1}â†’S_tï¼ˆTopKï¼‰  # [cite: 15]
#   B) (|ç‚¹å·®|æ¡¶, mean æ¡¶) çš„äºŒè¿è½¬ç§»æ¦œï¼šS_{t-1}â†’S_tï¼ˆTopKï¼‰  # [cite: 15]
#   æ¯æ¡è½¬ç§»è¾“å‡ºï¼šå‡ºç°æ¬¡æ•°ã€åç»­é˜ˆå€¼å‡»ç©¿æ•°ã€åç»­é˜ˆå€¼å‡»ç©¿ç‡ï¼ˆexhaustion / å‡ºç°æ¬¡æ•°ï¼‰  # [cite: 15]
#   é»˜è®¤åªè¾“å‡ºâ€œæ ·æœ¬é‡ >= é˜ˆå€¼â€çš„è½¬ç§»ï¼Œé¿å…å™ªå£°ã€‚  # [cite: 15]
CONT_STATS_ENABLE = 1  # [cite: 15]
CONT_MAX_BET_N = 12  # [cite: 15]
CONT_MIN_SAMPLES = 500  # [cite: 15]
CONT_TOPK = 20  # [cite: 15]


def _abs_diff_bucket(diff):
    """L2/L3/L4 æ³¨ä½å¿«ç…§ï¼šä¸»åˆ†å¸ƒ |diff|=1..9ï¼›çº é”™è®¡æ•°ï¼š|diff|=0 ä¸ 9+ åˆå¹¶ï¼ˆä¸è¿›å…¥1..9ï¼‰ã€‚"""
    try:
        d = abs(int(diff))
    except Exception:
        d = 0
    if 1 <= d <= 9:
        return str(d)  # "1".."9"
    return "çº é”™(0/9+)"


# å˜åŒ–ç‡ï¼šæ¿€æ´»é˜ˆå€¼ï¼ˆä¸‰æ¡£ï½œé”æ­»ï¼‰  # [cite: 17]
def _rate_entry_bucket(rate):
    if rate is None:
        return "æ— æ•ˆ"  # [cite: 17]
    try:
        r = float(rate)  # [cite: 17]
    except Exception:
        return "æ— æ•ˆ"  # [cite: 17]
    if r <= -3:
        return "<=-3"  # [cite: 17]
    if -3 < r <= -2:
        return "(-3,-2]"  # [cite: 17]
    if -2 < r < 0:
        return "(-2,0)"  # [cite: 17]
    return "å…¶ä»–"  # [cite: 17]

# å˜åŒ–ç‡ï¼šç›‘æµ‹é˜ˆå€¼ï¼ˆä¸‰æ¡£ï½œé”æ­»ï¼‰  # [cite: 18]

def _rate_monitor_bucket(rate):
    """L2/L3/L4 æ³¨ä½å¿«ç…§å˜åŒ–ç‡åˆ†æ¡¶ï¼ˆä¸­æ–‡æ¡¶åé”æ­»ï¼‰ã€‚"""
    if rate is None:
        return "æ— æ•ˆ"
    try:
        r = float(rate)
    except Exception:
        return "æ— æ•ˆ"
    if r < 0:
        return "å‡é€Ÿ"
    if 0 <= r < 2:
        return "åŠ é€Ÿ"
    return "æå€¼"


# å‡å·®ï¼šç›‘æµ‹åˆ†æ¡¶ï¼ˆä¸¤ç±» + 0 å•åˆ—ï½œé”æ­»ï¼‰  # [cite: 19]

def _mean_bucket(mean):
    """L2/L3/L4 æ³¨ä½å¿«ç…§å‡å·®ç»å¯¹å€¼åˆ†æ¡¶ï¼ˆ<3 / â‰¥3ï¼›æ— æ•ˆå•åˆ—ç”¨äºçº é”™è®¡æ•°ï¼‰ã€‚"""
    if mean is None:
        return "æ— æ•ˆ"
    try:
        m = abs(float(mean))
    except Exception:
        return "æ— æ•ˆ"
    if m < 3:
        return "<3"
    return "â‰¥3"

def _l1_abs_diff_bucket(diff):
    """L1 æŠ•æ”¾ç‚¹ç‚¹å·®åˆ†å¸ƒï¼š|diff|=0..9 + 9+ï¼ˆ9+å•åˆ—ï¼‰ã€‚"""
    try:
        d = abs(int(diff))
    except Exception:
        d = 0
    if d >= 10:
        return "9+"
    return str(d)  # "0".."9"

def _l1_rate_bucket(rate):
    """L1 æŠ•æ”¾ç‚¹å˜åŒ–ç‡åˆ†æ¡¶ï¼ˆä¸­æ–‡æ¡¶åé”æ­»ï¼‰ã€‚"""
    if rate is None:
        return "æ— æ•ˆ"
    try:
        r = float(rate)
    except Exception:
        return "æ— æ•ˆ"
    if r > -2:
        return "å‰å°"
    if -3 < r <= -2:
        return "å‰å¤§"
    return "æå€¼"

def _l1_mean_bucket(diff, mean):
    """L1 æŠ•æ”¾ç‚¹å‡å·®åˆ†æ¡¶ï¼šæœ‰æ•ˆåŒå‘/æœ‰æ•ˆåå‘/ä¸­è½´ï¼›meanæ— æ•ˆè¿”å›(None, True)"""
    if mean is None:
        return None, True
    try:
        m = float(mean)
    except Exception:
        return None, True
    try:
        d = float(diff)
    except Exception:
        d = 0.0

    # diff=0 å¼ºåˆ¶ä¸­è½´
    if d == 0:
        return "ä¸­è½´", False

    # mean=0 / |mean|<1 å½’ä¸­è½´
    if abs(m) < 1:
        return "ä¸­è½´", False

    # |mean|>=1ï¼šæŒ‰ç¬¦å·åˆ¤åŒå‘/åå‘
    same = (m > 0 and d > 0) or (m < 0 and d < 0)
    return ("æœ‰æ•ˆåŒå‘" if same else "æœ‰æ•ˆåå‘"), False



def _init_cont_agg():
    return {
        "pair_rate": {},         # key: (bet_n, prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_mean": {},         # key: (bet_n, prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_rate_overall": {}, # key: (prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "pair_mean_overall": {}, # key: (prev_state, curr_state) -> [cnt, exhaustion]  # [cite: 21]
        "max_bet_n_seen": 0,  # [cite: 21]
    }

def _agg_add(d, key, bust_flag):
    if key not in d:
        d[key] = [0, 0]  # [cite: 22]
    d[key][0] += 1  # [cite: 22]
    d[key][1] += int(1 if bust_flag else 0)  # [cite: 22]

def _cont_consume_snapshots(agg, snapshots):
    # snapshots: list of dicts with bet_n,diff,rate,mean,trade_exhaustion  # [cite: 23]
    if not snapshots:
        return  # [cite: 23]
    snaps = [x for x in snapshots if isinstance(x, dict) and "bet_n" in x]  # [cite: 23]
    snaps.sort(key=lambda x: int(x.get("bet_n", 0)))  # [cite: 23]
    if len(snaps) < 2:
        return  # [cite: 23]

    bust_flag = int(snaps[-1].get("trade_bust", 0))  # [cite: 23]
    for i in range(1, len(snaps)):
        a = snaps[i-1]  # [cite: 23]
        b = snaps[i]  # [cite: 23]
        try:
            bn = int(b.get("bet_n", 0))  # [cite: 23]
        except Exception:
            bn = 0  # [cite: 23]
        if bn > agg["max_bet_n_seen"]:
            agg["max_bet_n_seen"] = bn  # [cite: 23]

        prev_rate = (_abs_diff_bucket(a.get("diff", 0)), _rate_monitor_bucket(a.get("rate")))  # [cite: 24]
        curr_rate = (_abs_diff_bucket(b.get("diff", 0)), _rate_monitor_bucket(b.get("rate")))  # [cite: 24]
        prev_mean = (_abs_diff_bucket(a.get("diff", 0)), _mean_bucket(a.get("mean")))  # [cite: 24]
        curr_mean = (_abs_diff_bucket(b.get("diff", 0)), _mean_bucket(b.get("mean")))  # [cite: 24]

        _agg_add(agg["pair_rate"], (bn, prev_rate, curr_rate), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_mean"], (bn, prev_mean, curr_mean), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_rate_overall"], (prev_rate, curr_rate), bust_flag)  # [cite: 24]
        _agg_add(agg["pair_mean_overall"], (prev_mean, curr_mean), bust_flag)  # [cite: 24]

def _print_top_transitions(title, d, min_samples, topk):
    rows = []  # [cite: 25]
    for k, (cnt, bust) in d.items():
        if cnt < min_samples:
            continue  # [cite: 25]
        br = bust / cnt if cnt else 0.0  # [cite: 25]
        rows.append((br, cnt, bust, k))  # [cite: 25]
    rows.sort(reverse=True, key=lambda x: (x[0], x[1]))  # [cite: 25]
    print(title)  # [cite: 25]
    if not rows:
        print("ï¼ˆæ— è¾“å‡ºï¼šæ ·æœ¬é‡ä¸è¶³ï¼‰")  # [cite: 25]
        return  # [cite: 25]
    for i, (br, cnt, bust, k) in enumerate(rows[:topk], 1):
        print(f"{i:02d}. {k} | æ¬¡æ•°={cnt} | é˜ˆå€¼å‡»ç©¿={bust} | é˜ˆå€¼å‡»ç©¿ç‡={br:.4f}")  # [cite: 26]


# ============================================================
# ç»Ÿä¸€ä»£ç æ¨¡æ¿ï¼ˆV4ï¼Œåºåˆ—é•¿åº¦å£å¾„ï½œä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“ï¼‰
# çº¦æŸï¼š
# 1) åªè¯»å–å½“å‰ç›®å½•ä¸‹æ‰€æœ‰ .csv
# 2) ä¸å†™æ­»ä»»ä½•ç»å¯¹è·¯å¾„
# 3) è‡ªåŠ¨è¯†åˆ«æ‰¹æ¬¡åˆ—/ç»“æœ/ç‚¹å·®/å˜åŒ–ç‡/å‡å·®
# 4) ç»“æœå¿…é¡»æ˜ å°„ä¸º B/P/T
# 5) ä¸¥æ ¼é›¶æœªæ¥ï¼šrun_strategy_on_boot å†…ä¸¥ç¦è®¿é—®æœªæ¥è¡Œ
# 6) â€œä¸‹ä¸€å£/ä¸‹ä¸€è¡Œâ€ç»Ÿä¸€å®šä¹‰ï¼šidx+1ï¼ˆä¸è·³è¿‡çŠ¶æ€ T ä½ç§»é›¶åå·®ï¼‰
# 7) å•è¾¹/åŒè¾¹ï¼šå‰ 9 å£åˆ†ç±»ï¼›å•è¾¹å¼±ç´¯è®¡ >=3 è½¬åŒè¾¹ï¼›äº¤æ˜“æ¬¡æ•°é™åˆ¶è§æ¨¡æ¿æ–‡æ¡£
#
# æ³¨æ„ï¼šæœªæ¥æ–°å¢/ä¿®æ”¹ç­–ç•¥ï¼Œåªæ”¹ run_strategy_on_boot(records) å†…éƒ¨é€»è¾‘
# ============================================================

# ============================================================
# ç»“æœæ˜ å°„è¡¨ï¼šå·²å®Œæˆ BPT å…¨é˜¶è„±æ•ï¼Œç‰©ç†åŒ¹é…å®éªŒå®¤æ ‡å‡†åŒ– CSV
# ============================================================
MAP_RESULT = {"B": "B", "P": "P", "T": "T"}

def map_result(v):
    if v is None:
        return None
    s = str(v).strip()
    if s in MAP_RESULT:
        return MAP_RESULT[s]
    s2 = s.upper()
    if s2 in MAP_RESULT:
        return MAP_RESULT[s2]
    return None

# ------------------------------------------------------------
# å·¥å…·ï¼šå®‰å…¨è¯»å– float / intï¼ˆåªè¯»ï¼Œä¸è®¡ç®—ï¼‰
# ------------------------------------------------------------
def safe_float(v, default=None):
    try:
        if v is None or v == "":
            return default
        return float(v)
    except Exception:
        return default

def safe_int(v, default=0):
    try:
        if v is None or v == "":
            return default
        return int(float(v))
    except Exception:
        return default

# ------------------------------------------------------------
# 1) æ•°æ®åŠ è½½ï¼ˆå›ºå®šï¼‰
# ------------------------------------------------------------
# ------------------------------------------------------------
# 0) åˆ—è¯†åˆ«ä¸æ˜ å°„ï¼ˆå›ºå®šï½œåªè¯»ï¼‰
# ------------------------------------------------------------
def _norm_key(k):
    return str(k).strip().lower() if k is not None else ""

def _first_hit(keys, candidates):
    key_norm = { _norm_key(k): k for k in keys }
    for c in candidates:
        cc = _norm_key(c)
        if cc in key_norm:
            return key_norm[cc]
    return None

def detect_columns(row0):
    """
    è¾“å…¥ï¼šrow0ï¼ˆDictReader è¯»åˆ°çš„ä¸€è¡Œ dictï¼‰
    è¾“å‡ºï¼šcol_shoe, col_result, col_diff, col_rate, col_mean
    ç›®æ ‡ï¼šä¸€æ¬¡æ€§è§£å†³ä½ ç°æœ‰ CSV çš„å¤šç§è¡¨å¤´ï¼ˆå« 2=å˜åŒ–ç‡ã€M3=å‡å·®ã€Exhaustion=B/P/Tã€BB/PP ç­‰ï¼‰ã€‚
    """
    keys = list(row0.keys()) if isinstance(row0, dict) else []

    # é´å·ï¼ˆè‹¥æ²¡æœ‰ï¼Œå…è®¸é€€åŒ–åˆ°å±€å·ï¼‰
    col_shoe = _first_hit(keys, ["é´", "é´å·", "shoe", "Shoe", "æœ¬é´", "æœ¬é´é´å·", "å…¨å±€é´å·", "æœ¬å·é´å·"])
    if col_shoe is None:
        col_shoe = _first_hit(keys, ["å±€å·", "hand", "Hand", "round", "Round"])
    if col_shoe is None and keys:
        col_shoe = keys[0]

    # ç»“æœåˆ—ï¼šä½ æ•°æ®å¸¸è§ Exhaustionï¼ˆå€¼ä¸ºB/P/Tï¼‰
    col_result = _first_hit(keys, ["Exhaustion", "exhaustion", "ç»“æœ", "result", "Result", "Outcome", "outcome"])

    # ç‚¹å·®/å˜åŒ–ç‡/å‡å·®ï¼ˆæ”¯æŒ 2/M3ï¼‰
    col_diff = _first_hit(keys, ["ç‚¹å·®", "diff", "Diff", "spread", "Spread", "delta", "Delta"])
    col_rate = _first_hit(keys, ["å˜åŒ–ç‡", "rate", "Rate", "roc", "ROC", "r", "R", "2"])
    col_mean = _first_hit(keys, ["å‡å·®", "mean", "Mean", "avg", "Avg", "average", "Average", "M3", "m3"])

    return col_shoe, col_result, col_diff, col_rate, col_mean

def _print_header_mapping_once(row0, cols):
    """è¡¨å¤´è¯†åˆ«è‡ªè¯ï¼šåªæ‰“å°ä¸€æ¬¡ï¼›ç»ä¸å½±å“ä¸»æµç¨‹ã€‚"""
    global _HEADER_MAPPING_PRINTED
    if _HEADER_MAPPING_PRINTED:
        return
    _HEADER_MAPPING_PRINTED = True

    try:
        sample_row = row0 if isinstance(row0, dict) else {}
        keys = list(sample_row.keys())

        # æ¸…ç†è¡¨å¤´é”®ï¼šå» BOMã€å»é¦–å°¾ç©ºæ ¼ï¼ˆä¸ä¿®æ”¹åŸæ•°æ®ï¼Œåªç”¨äºåŒ¹é…ï¼‰
        norm_map = {}
        for k in keys:
            if isinstance(k, str):
                kk = k.lstrip("\ufeff").strip()
            else:
                kk = k
            norm_map[kk] = k
        norm_keys = list(norm_map.keys())

        def pick(cands):
            # 1:1 ç‰©ç†åŒ¹é…ï¼ˆä¼˜å…ˆåŸé”®ï¼‰
            for c in cands:
                if c in sample_row:
                    return c
            # 1:1 ç‰©ç†åŒ¹é…ï¼ˆæ¸…ç†åé”®ï¼‰
            for c in cands:
                if c in norm_map:
                    return norm_map[c]
            # æ¨¡ç³ŠåŒ¹é…ï¼ˆæ¸…ç†åé”®ï¼‰
            for k in norm_keys:
                for c in cands:
                    if isinstance(k, str) and isinstance(c, str) and (c.lower() in k.lower()):
                        return norm_map.get(k, k)
            return None

        # cols æ˜¯ detect_columns ä¼ å…¥çš„ç»“æœï¼›è‹¥ä¸º None åˆ™å›é€€æ¨æ–­
        col_shoe, col_result, col_diff, col_rate, col_mean = cols

        # å…œåº•æ¨æ–­ï¼šåªåœ¨ç¼ºå¤±æ—¶è¡¥
        if col_shoe is None:   col_shoe = pick(["å±€å·", "hand", "Hand", "No", "no", "shoe", "é´å·", "é´"])
        if col_result is None: col_result = pick(["Exhaustion", "ç»“æœ", "result", "Result", "r", "R"])
        if col_diff is None:   col_diff = pick(["ç‚¹å·®", "diff", "Diff", "spread", "Spread"])
        if col_rate is None:   col_rate = pick(["å˜åŒ–ç‡", "rate", "Rate", "2", "R2"])
        if col_mean is None:   col_mean = pick(["å‡å·®", "mean", "Mean", "M3", "m3", "avg", "Avg"])

        print("==================================================")
        print("è¡¨å¤´è¯†åˆ«ï¼ˆè‡ªè¯ï½œä¸€æ¬¡æ€§æ‰“å°ï¼‰")
        print("é´ ->", col_shoe)
        print("ç»“æœ ->", col_result)
        print("ç‚¹å·® ->", col_diff)
        print("å˜åŒ–ç‡ ->", col_rate)
        print("å‡å·® ->", col_mean)

        # æ ·ä¾‹è¡Œï¼šåªå±•ç¤ºå‰12ä¸ªé”®
        d = {}
        show_keys = list(sample_row.keys())[:12]
        for k in show_keys:
            d[k] = sample_row.get(k)
        print("æ ·ä¾‹è¡Œ(åŸå§‹):", d)
        print("==================================================")
    except Exception as e:
        # åªè¦ä¸»æµç¨‹èƒ½è·‘ï¼Œè‡ªè¯å¤±è´¥ä¸å½±å“æ‰§è¡Œ
        print("âš  è¡¨å¤´è‡ªè¯æ‰“å°å¤±è´¥ï¼ˆä¸å½±å“è¿è¡Œï¼‰:", str(e))

def boot_filter(records):
    b_run, p_run, seen_all = _compute_max_runs_first9(records)
    if seen_all < 9:
        return False
    if b_run >= 3 and p_run >= 3:
        return False
    return True



# ------------------------------------------------------------
# 3) å•æ‰¹æ¬¡ç­–ç•¥å…¥å£ï¼ˆåªå…è®¸æ”¹è¿™é‡Œï¼‰
# ------------------------------------------------------------
def run_strategy_on_boot(records):
    # 1. ç‰©ç†æ§½ä½åˆå§‹åŒ–
    snapshots = []  # å­˜æ”¾â€œå®é™…æŠ•æ”¾å‰â€çš„å¿«ç…§åˆ—è¡¨
    star_snap = None  # æŠ•æ”¾ç‚¹å½“è¡Œå¿«ç…§ï¼ˆL1ï¼‰

    entry, match, mismatch, exhaustion = 0, 0, 0, 0
    profit = 0.0

    # 2. ç­–ç•¥é€»è¾‘å¾ªç¯
    # ç»“æ„æ‰«ææ¨¡å—è¾“å‡ºï¼ˆæ¨¡æ¿å ä½ï¼šé»˜è®¤ä¸æ¿€æ´»ï¼Œé¿å… NameErrorï¼‰
    current_w_len = 0
    other_dna_conditions = False
    target_side = "B"

    for idx, r in enumerate(records):
        # --- Aå±‚ï¼šç»“æ„æ¿€æ´»ï¼ˆæ¨¡æ¿å ä½ï½œå¾…æ¥å…¥çœŸå®ç»“æ„æ‰«æè¾“å‡ºï¼‰---
        # æœ€å°æ¿€æ´»æ¡ä»¶ï¼šæŠ•æ”¾ç‚¹å¿…é¡» idx>=9 ä¸” æœ¬è¡Œç»“æœä¸ºB/Pï¼ˆçŠ¶æ€Tä¸å…è®¸ä½œä¸ºæŠ•æ”¾ç‚¹ï¼‰
        rr = r.get("r") if isinstance(r, dict) else None
        is_structure_active = (idx >= 9 and rr in ("B", "P"))

        if is_structure_active:
            # --- æŠ•æ”¾ç‚¹å½“è¡Œå¿«ç…§ï¼ˆL1ï¼‰---
            star_snap = {
                'idx': idx,
                'r': rr,
                'diff': r.get('diff'),
                'rate': r.get('rate'),
                'mean': r.get('mean'),
            }

            # --- Bå±‚ï¼šç¥è°•å®¡è®¡ (Oracle Audit) ---
            # ç‰©ç†èŒèƒ½ï¼šä»…å¯¹å·²æ¿€æ´»çš„ç»“æ„æ‰§è¡Œâ€œé€šè¿‡/ä¸é€šè¿‡â€åˆ¤å®š
            # ä¸¥ç¦åœ¨æ­¤ç”Ÿæˆä»»ä½•ä¸‹æ³¨ä¿¡å·ã€‚
            is_oracle_pass = True # [æ­¤å¤„ç”±ç­–ç•¥è°ƒç”¨ å¤–éƒ¨å‚æ•° å‚æ•°è¿›è¡Œå®¡è®¡]

            if not is_oracle_pass:
                # å®¡è®¡ä¸é€šè¿‡ï¼šæ”¾å¼ƒæœ¬æ¬¡æ‰§è¡Œï¼Œç¨‹åºå¿…é¡»ç»§ç»­å‘åæ‰«æ
                continue

            # --- Cå±‚ï¼šæ‰§è¡Œä¸è´Ÿå‘é˜»æ–­ (Negative Interception) ---
            entry += 1
            units = [1, 2, 4, 8]
            is_settled = False

            # ç‰©ç†æ¸¸æ ‡ï¼šä»â€œæŠ•æ”¾ç‚¹ä¸‹ä¸€è¡Œâ€å¼€å§‹é€è¡Œæ¨è¿›ï¼ˆä¸å…è®¸ idx + åç§»é‡ ç›´ç®—ï¼‰
            j = idx + 1
            bet_n = 1
            max_bet = len(units)

            while bet_n <= max_bet and j < len(records):
                # 1) å†³ç­–å£å¿«ç…§ï¼šæ¯æ¬¡â€œå®é™…æŠ•æ”¾å‰â€å¿…é¡»è®°å½•ä¸€æ¬¡æŒ‡æ ‡å¿«ç…§
                decision_row = records[j]  # æœ¬æ¬¡å³å°†æŠ•æ”¾çš„è¡Œ

                snap = {
                    'bet_n': bet_n,    # ç¬¬å‡ æ³¨ï¼ˆåªåœ¨å®Œæˆä¸€æ¬¡æœ‰æ•ˆç»“ç®—åæ‰æ¨è¿›ï¼‰
                    'idx': j,          # å¿«ç…§è¡Œå·=æœ¬æ¬¡å®é™…æŠ•æ”¾å‰çš„è¡Œå·ï¼ˆä¸æ˜¯æŠ•æ”¾ç‚¹è¡Œå·ï¼‰
                    'diff': decision_row['diff'],
                    'rate': decision_row['rate'],
                    'mean': decision_row['mean'],
                }
                snapshots.append(snap)

                # 2) STOP åˆ¤æ–­åªèƒ½å‘ç”Ÿåœ¨è¿™é‡Œï¼ˆæŠ•æ”¾ç‚¹/å†³ç­–å£ï¼‰ï¼Œåªè¯» snap / snapshots
                #    è‹¥è§¦å‘ STOPï¼šè®°å½•â€œæå‰æ­¢æŸâ€å¹¶ breakï¼ˆç»“æŸæœ¬æ‰¹æ¬¡äº¤æ˜“ï¼‰
                # if should_stop(snapshots):
                #     early_stop += 1
                #     break

                # 3) æœ¬æ¬¡æŠ•æ”¾çš„ç»“ç®—ï¼šåªè¯»ç»“æœ rï¼ˆæ‰§è¡Œ/ç»“ç®—é˜¶æ®µç¦è¯»ä»»ä½•æŒ‡æ ‡ï¼‰
                r = decision_row['r']

                # çŠ¶æ€Tï¼š0é€€å›ä¸æ¨è¿› bet_nï¼Œä½† j å¿…é¡»å‰è¿›ï¼Œä¸‹ä¸€æ¬¡æŠ•æ”¾å‰ä»è¦å†è®°ä¸€æ¡å¿«ç…§
                if r == 'T':
                    j += 1
                    continue

                # éçŠ¶æ€Tï¼šå®Œæˆä¸€æ¬¡æœ‰æ•ˆç»“ç®—
                u = units[bet_n - 1]

                if r == target_side:
                    match += 1
                    profit += (u * 0.95 if target_side == 'B' else u * 1.0)
                    is_settled = True
                    break
                else:
                    # æœªåŒ¹é…ï¼šæœ¬æ³¨äºæŸå…¥è´¦ï¼›æ¨è¿›åˆ°ä¸‹ä¸€æ¬¡æŠ•æ”¾ï¼ˆbet_n + 1ï¼‰ï¼Œå¹¶ç‰©ç†å‰è¿›åˆ°ä¸‹ä¸€è¡Œ
                    profit -= u
                    bet_n += 1
                    j += 1
                    continue

            # 4. æ±‡æ€»åˆ¤å®šï¼šå…¨åºåˆ—æœªåŒ¹é…
            trade_bust_flag = 0
            if not is_settled:
                mismatch += 1
                exhaustion += 1
                trade_bust_flag = 1

            # trade_bust å›å¡«ï¼šè¿ç»­ç»Ÿè®¡åªå…è®¸è¯» snapshots
            for _s in snapshots:
                if isinstance(_s, dict):
                    _s["trade_bust"] = trade_bust_flag

            # 5. ä¸€é´ä¸€å•å…ƒï¼šæ‰§è¡Œå®Œæ¯•ç«‹å³è·³å‡º Batch å¾ªç¯
            break
    return {
        "entry": entry,
        "match": match,
        "mismatch": mismatch,
        "exhaustion": exhaustion,
        "profit": profit,
        "snapshots": snapshots, # å¿…é¡»è¿”å›ï¼Œç”¨äº TopK å½’å› 
        "star_snap": star_snap,  # æŠ•æ”¾ç‚¹å½“è¡Œå¿«ç…§ï¼ˆç”¨äºL1ç»Ÿè®¡ï¼‰
        "trade_bust": 1 if exhaustion > 0 else 0
    }  # [cite: 26, 32]

def load_all_boots(csv_files):
    boots = defaultdict(list)
    print("æ£€æµ‹åˆ° CSV æ–‡ä»¶æ•°é‡:", len(csv_files))

    for i, fname in enumerate(csv_files, 1):
        if i % 10 == 0:
            print(f"è¿›åº¦: å·²å¤„ç† {i}/{len(csv_files)} ä¸ªæ–‡ä»¶")

        rows = []
        for enc in ("utf-8", "utf-8-sig", "gbk", "gb18030"):
            try:
                with open(fname, "r", encoding=enc) as f:
                    rows = list(csv.DictReader(f))
                break
            except Exception:
                rows = []

        if not rows:
            continue

        col_shoe, col_result, col_diff, col_rate, col_mean = detect_columns(rows[0])

        _print_header_mapping_once(rows[0], (col_shoe, col_result, col_diff, col_rate, col_mean))
        for r in rows:
            shoe = r.get(col_shoe)
            if shoe is None:
                continue

            res_raw = r.get(col_result)
            res = map_result(res_raw)
            if res not in ("B", "P", "T"):
                continue

            diff = safe_int(r.get(col_diff, 0), 0)
            rate = safe_float(r.get(col_rate), None) if col_rate else None
            mean = safe_float(r.get(col_mean), None) if col_mean else None

            # è¡¥é½ç‰©ç†ç´¢å¼• idxï¼Œç¡®ä¿ snapshots èƒ½å¤Ÿç²¾å‡†å¯¹æ ‡åŸå§‹è¡Œå·
            boots[shoe].append({
                "idx": len(boots[shoe]),
                "r": res,
                "diff": diff,
                "rate": rate,
                "mean": mean
            })  # [cite: 30]

    print("æŒ‰æ‰¹æ¬¡åˆ†ç»„å®Œæˆï¼Œæ‰¹æ¬¡æ€»æ•°:", len(boots))
    return boots

def _run_report(csv_files, title):
    boots = load_all_boots(csv_files)
    total_boots = len(boots)

    playable_boots = 0
    skipped_boots = 0

    total_entry = 0
    total_match = 0
    total_mismatch = 0
    total_exhaustion = 0
    total_profit = 0.0

    # ------------------------------------------------------------
    # L1 é”æ­»æ ‡é¢˜ç»Ÿè®¡ï¼ˆæŠ•æ”¾ç‚¹å½“è¡Œï¼‰
    # ------------------------------------------------------------
    l1_diff_dist = defaultdict(int)  # key: '0'..'9','9+'
    l1_rate_dist = defaultdict(int)  # key: å‰å°/å‰å¤§/æå€¼/æ— æ•ˆ
    l1_mean_dist = defaultdict(int)  # key: æœ‰æ•ˆåŒå‘/æœ‰æ•ˆåå‘/ä¸­è½´
    STAR_ON_T = 0
    STAR_DIFF0_AND_R_IN_BP = 0
    MEAN_INVALID_BUG = 0


    cont_agg = _init_cont_agg() if CONT_STATS_ENABLE else None

    # ------------------------------------------------------------
    # æ‰¹æ¬¡å¤„ç†è¿›åº¦è¾“å‡ºï¼ˆåªæ‰“å°ï½œä¸å‚ä¸ä»»ä½•åˆ¤æ–­ï¼‰
    # ------------------------------------------------------------
    def _print_batch_progress(done, total, bar_width=20, force_newline=False):
        if total <= 0:
            return
        if done < 0:
            done = 0
        if done > total:
            done = total
        ratio = done / total
        filled = int(ratio * bar_width)
        if filled < 0:
            filled = 0
        if filled > bar_width:
            filled = bar_width
        bar = ("=" * filled) + (" " * (bar_width - filled))
        pct = ratio * 100.0
        line = f"è¿›åº¦: [{bar}] {pct:.1f}% ({done:,}/{total:,} æ‰¹æ¬¡)"
        if force_newline:
            print(line)
        else:
            print("\r" + line, end="", flush=True)

    if total_boots > 0:
        print()
        print(f"å¼€å§‹å¤„ç† {total_boots:,} ä¸ªæ‰¹æ¬¡...")

    step = max(1, total_boots // 200) if total_boots > 0 else 1

    for n, (_, rec) in enumerate(boots.items(), 1):
        if total_boots > 0 and (n == 1 or n == total_boots or (n % step == 0)):
            _print_batch_progress(n, total_boots)

        if not boot_filter(rec):
            skipped_boots += 1
            continue

        playable_boots += 1
        out = run_strategy_on_boot(rec)

        # L1 æŠ•æ”¾ç‚¹å½“è¡Œç»Ÿè®¡ï¼šä»…ä½¿ç”¨ star_snapï¼ˆå–å€¼å£é”æ­»ï¼‰
        star = out.get("star_snap")
        if isinstance(star, dict):
            sr = star.get("r")
            sd = star.get("diff")
            srate = star.get("rate")
            smean = star.get("mean")

            if sr == "T":
                STAR_ON_T += 1
            elif sr in ("B", "P"):
                if safe_int(sd, 0) == 0:
                    STAR_DIFF0_AND_R_IN_BP += 1

                l1_diff_dist[_l1_abs_diff_bucket(sd)] += 1
                l1_rate_dist[_l1_rate_bucket(srate)] += 1

                mb, inv = _l1_mean_bucket(sd, smean)
                if inv:
                    MEAN_INVALID_BUG += 1
                else:
                    l1_mean_dist[mb] += 1

        total_entry += int(out.get("entry", 0))
        total_match += int(out.get("match", 0))
        total_mismatch += int(out.get("mismatch", 0))
        total_exhaustion += int(out.get("exhaustion", 0))
        total_profit += float(out.get("profit", 0.0))

        if cont_agg is not None:
            _cont_consume_snapshots(cont_agg, out.get("snapshots") or [])

    if total_boots > 0:
        print()  # ç»“æŸè¿›åº¦è¡Œ

    print()
    print("============================================================")
    print("ğŸš€ğŸš€ğŸš€ ğŸ”ğŸ”ğŸ” ğŸ°ğŸ°ğŸ°")
    print("============================================================")
    print(title)
    print("============================================================")
    print("æ‰«ææ–¹å¼ï¼šä¸€æ¬¡æ€§æ‰«æï½œä¸€æ¬¡æ€§äº¤æ˜“")
    print("æ®µé•¿å£å¾„ï¼šç¦æ­¢è·¨æ®µç´¯è®¡")
    print("æœ¯è¯­é”æ­»ï¼šåªæ‰¿è®¤ã€Œâ­ / æŠ•æ”¾ç‚¹ã€")
    print(f"ç›‘æµ‹å¼€å…³ï¼š{'å¼€' if MONITOR_ENABLE else 'å…³'}")
    print("é˜ˆå€¼å‡»ç©¿å½’å› ï¼šè·¯å¾„å¿«ç…§ï¼ˆæ¯æ¬¡å®é™…æŠ•æ”¾å‰éƒ½å¿«ç…§ï¼›å«çŠ¶æ€ T åçš„é‡å¤æŠ•æ”¾ï¼›å½’å› åªç”¨å¿«ç…§ï¼‰")
    print("------------------------------------------------------------")
    print("æ€»æ‰¹æ¬¡æ•°    :", total_boots)
    print("å¯å‚ä¸æ‰¹æ¬¡æ•°:", playable_boots)
    print("è·³è¿‡æ‰¹æ¬¡æ•°  :", skipped_boots)
    print("------------------------------------------------------------")
    print("æ¿€æ´»æ¬¡æ•°    :", total_entry)
    print("åŒ¹é…æ¬¡æ•°    :", total_match)
    print("ä¸åŒ¹é…æ¬¡æ•°  :", total_mismatch)
    print("é˜ˆå€¼å‡»ç©¿æ¬¡æ•°:", total_exhaustion)
    if total_entry > 0:
        match_rate = total_match / total_entry * 100.0
        exhaustion_rate = total_exhaustion / total_entry * 100.0
        print(f"åŒ¹é…ç‡      : {match_rate:.4f}%")
        print(f"é˜ˆå€¼å‡»ç©¿ç‡  : {exhaustion_rate:.4f}%")
        print(f"å•æ¬¡å¹³å‡å¢ç›Š: {total_profit / total_entry:.6f}")
    print("æ€»å‡€å€¼å¢ç›Š  :", round(total_profit, 2))

    print()
    print("------------------------------------------------------------")
    print("[é”æ­»æ ‡é¢˜] L1ç‚¹å·®åˆ†å¸ƒï¼ˆæŠ•æ”¾ç‚¹ï½œ|ç‚¹å·®|=0..9 + 9+ï¼‰:")
    for k in [str(i) for i in range(0, 10)] + ["9+"]:
        if k in l1_diff_dist:
            print(f"  {k}: {l1_diff_dist[k]}")
    print("------------------------------------------------------------")
    print("[é”æ­»æ ‡é¢˜] L1å˜åŒ–ç‡åˆ†æ¡¶ï¼ˆæŠ•æ”¾ç‚¹ï½œå‰å°/å‰å¤§/æå€¼/æ— æ•ˆï¼‰:")
    for k in ["å‰å°", "å‰å¤§", "æå€¼", "æ— æ•ˆ"]:
        if k in l1_rate_dist:
            print(f"  {k}: {l1_rate_dist[k]}")
    print("------------------------------------------------------------")
    print("[é”æ­»æ ‡é¢˜] L1å‡å·®åˆ†æ¡¶ï¼ˆæŠ•æ”¾ç‚¹ï½œæœ‰æ•ˆåŒå‘/æœ‰æ•ˆåå‘/ä¸­è½´ï¼‰:")
    for k in ["æœ‰æ•ˆåŒå‘", "æœ‰æ•ˆåå‘", "ä¸­è½´"]:
        if k in l1_mean_dist:
            print(f"  {k}: {l1_mean_dist[k]}")
    print("------------------------------------------------------------")
    print("è‡ªè¯é¡¹ï¼ˆæ¯æ¬¡è·‘å¿…å‡ºï¼‰:")
    print("  STAR_ON_T:", STAR_ON_T)
    print("  STAR_DIFF0_AND_R_IN_BP:", STAR_DIFF0_AND_R_IN_BP)
    print("  MEAN_INVALID_BUG:", MEAN_INVALID_BUG)


    if cont_agg is not None:
        print()
        print("------------------------------------------------------------")
        print("è¿ç»­ç»Ÿè®¡ï¼ˆäºŒæŒ‡æ ‡äºŒè¿å˜åŒ–ï½œäº‹åæ±‡æ€»ï½œå­¦æœ¯ç‰ˆï¼‰")
        print("è¯´æ˜ï¼šä»…åŸºäºæŠ•æ”¾å‰å¿«ç…§åˆ—è¡¨ï¼ˆå«çŠ¶æ€ T é‡å¤æŠ•æ”¾ï¼‰ï¼›æ ·æœ¬é‡ä¸è¶³ä¸è¾“å‡ºã€‚")
        print("é˜ˆå€¼ï¼šmin_samples=%dï½œTopK=%d" % (CONT_MIN_SAMPLES, CONT_TOPK))

        _print_top_transitions(
            "A) (|ç‚¹å·®|,rate ç›‘æµ‹æ¡¶) Overall Top",
            cont_agg["pair_rate_overall"],
            CONT_MIN_SAMPLES,
            CONT_TOPK,
        )
        _print_top_transitions(
            "B) (|ç‚¹å·®|,mean æ¡¶) Overall Top",
            cont_agg["pair_mean_overall"],
            CONT_MIN_SAMPLES,
            CONT_TOPK,
        )

        max_bn = min(int(cont_agg.get("max_bet_n_seen", 0) or 0), CONT_MAX_BET_N)
        for bn in range(2, max_bn + 1):
            tmp_rate = {}
            tmp_mean = {}
            for (bn2, a, b), v in cont_agg["pair_rate"].items():
                if bn2 == bn:
                    tmp_rate[(a, b)] = v
            for (bn2, a, b), v in cont_agg["pair_mean"].items():
                if bn2 == bn:
                    tmp_mean[(a, b)] = v

            _print_top_transitions(
                f"A) bet_n={bn} (|ç‚¹å·®|,rate ç›‘æµ‹æ¡¶) Top",
                tmp_rate,
                CONT_MIN_SAMPLES,
                min(10, CONT_TOPK),
            )
            _print_top_transitions(
                f"B) bet_n={bn} (|ç‚¹å·®|,mean æ¡¶) Top",
                tmp_mean,
                CONT_MIN_SAMPLES,
                min(10, CONT_TOPK),
            )

    print("============================================================")

def main():
    _audit_forbid_idx_offset()
    csv_files = sorted([f for f in os.listdir(".") if f.lower().endswith(".csv")])
    if VERIFY_SPLIT_ENABLE and len(csv_files) >= 2:
        mid = len(csv_files) // 2
        _run_report(csv_files[:mid], "éªŒçœŸé˜¶æ®µï¼ˆå‰ 50%ï¼‰")
        _run_report(csv_files[mid:], "éªŒçœŸé˜¶æ®µï¼ˆå 50%ï¼‰")
    else:
        _run_report(csv_files, "ä¼˜åŒ–é˜¶æ®µï¼ˆå…¨é‡ï¼‰")

if __name__ == "__main__":
    main()
